// lib/topics.ts

export const courseTopics = {
  html: [
    
    {
      "title": "The Evolution of HTML",
      "note": "👉 HTML (HyperText Markup Language) is the core language used to create web pages. \n\n 👉It has evolved significantly since its creation in the early 1990s, gaining features that made the web more interactive, accessible, and modern.\n\n\ \n\n\⫷⫸⫷⫸⫷⫸⫷⫸HTML Evolution Timeline:⫷⫸⫷⫸⫷⫸\n\nVersion    Year    Key Features\n--------   ----    -----------\nHTML 1.0   1993    Simple; only basic tags like headings, paragraphs, and links.\nHTML 2.0   1995    Standardized HTML; included forms and tables.\nHTML 3.2   1997    Introduced styles, scripts, and applets.\nHTML 4.01  1999    Supported CSS and better structure for layout.\nHTML5      2014    Supports audio, video, canvas, local storage, semantic tags, and mobile-friendly design.\n\nWhy the Evolution Was Important:\n- Older versions were limited to static content\n- Newer versions brought structure, multimedia, and interactivity\n- HTML5 made websites more responsive, powerful, and mobile-compatible\n\nSummary of Major Milestones:\n- HTML 1.0 – Birth of HTML with basic tags only\n- HTML 4.01 – Introduced separation of content and style (via CSS)\n- HTML5 – Supports media, canvas, semantic structure, and modern web standards\n\nKey Terms:\n- Semantic Tags: Tags like <article>, <section>, <header> that give meaning to content\n- Canvas: A tag for drawing graphics using JavaScript\n- Responsive Design: Layouts that adjust to screen size using CSS techniques",
      "code": "<!DOCTYPE html>\n<html>\n<head>\n  <title>HTML Evolution</title>\n</head>\n<body>\n  <h1>HTML Through the Years</h1>\n  <p>From simple documents to rich applications</p>\n</body>\n</html>"
    },
    {
      "title": "Importance of HTML",
      "note": "HTML (HyperText Markup Language) is the backbone of the web. Every webpage you visit—from Google to social media platforms—is built on HTML. It defines the structure of content and tells the browser how to display text, images, links, and more.\n\nWhy HTML is Essential:\n- Structures Content: Without HTML, browsers wouldn't know how to organize or present web content\n- Universal Language: HTML is understood by all web browsers\n- Accessibility: Helps screen readers and other assistive technologies interpret content\n- SEO Friendly: Search engines use HTML structure to understand and rank pages\n\nKey Points:\n- HTML provides the basic structure of sites\n- All other web technologies (CSS, JavaScript) build upon HTML\n- Proper HTML structure is crucial for accessibility and SEO",
      "code": "<!DOCTYPE html>\n<html>\n<head>\n  <title>My First Page</title>\n</head>\n<body>\n  <h1>Welcome to HTML</h1>\n  <p>This is the foundation of the web.</p>\n</body>\n</html>"
    },
    {
      "title": "Writing HTML Editors",
      "note": "You can write HTML using any text editor, but using a specialized code editor makes development faster and easier. These editors offer features like syntax highlighting, auto-completion, and live preview.\n\nCommon HTML Editors:\n- Notepad: Basic text editor on Windows. Simple and lightweight\n- Visual Studio Code (VS Code): A free and powerful editor with extensions, IntelliSense, and live server preview\n- Sublime Text: A fast, minimalist editor with great performance and customization\n- Atom: Open-source and beginner-friendly, though no longer officially supported\n\nEditor Features to Look For:\n- Syntax highlighting\n- Auto-completion\n- Error detection\n- Live preview\n- Version control integration",
      "code": "<!-- Sample HTML in VS Code -->\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Page</title>\n</head>\n<body>\n  <h1>Hello from VS Code</h1>\n</body>\n</html>"
    },
    {
      "title": "HTML Document Structure",
      "note": "Every HTML document follows a specific structure to help browsers understand and render content correctly. The basic layout includes a document declaration, root element, metadata section, and the content body.\n\nEssential Tags:\n- <!DOCTYPE html> – Declares the document type (HTML5)\n- <html> – Root element of the page\n- <head> – Contains metadata like title, styles, and links\n- <body> – Holds the visible content (text, images, buttons, etc.)\n\nDocument Structure Rules:\n1. Start with DOCTYPE declaration\n2. Wrap entire document in <html> tags\n3. <head> section comes before <body>\n4. Only one <head> and one <body> per document",
      "code": "<!DOCTYPE html>\n<html>\n<head>\n  <title>My First Web Page</title>\n</head>\n<body>\n  <h1>Welcome to My Website</h1>\n  <p>This is a basic HTML structure.</p>\n</body>\n</html>"
    },
    {
      "title": "Understanding HTML Elements & Attributes",
      "note": "HTML elements are the building blocks of web pages. They define the structure and content of a page. Elements usually come in pairs: an opening tag and a closing tag.\n\nWhat is an HTML Element?\nAn element typically consists of:\n- An opening tag <tagname>\n- Content\n- A closing tag </tagname>\n\nWhat are Attributes?\nAttributes provide additional information about HTML elements. They are written in the opening tag and usually come in name/value pairs.\n\nCommon Attributes:\n- href – Specifies the URL for a link\n- src – Specifies the path of an image\n- alt – Provides alternative text for images\n- class and id – Used for styling and scripting",
      "code": "<a href=\"https://example.com\">Visit Example</a>\n<img src=\"image.jpg\" alt=\"Sample Image\">\n<p class=\"intro\">This is a paragraph with a class.</p>"
    },
    {
      "title": "Headings, Paragraphs & Line Breaks",
      "note": "HTML provides a set of tags to structure your text content clearly.\n\nHeadings (<h1> to <h6>):\nHeadings organize content into sections, with <h1> as the most important and <h6> as the least.\n\nParagraphs (<p>):\nUse <p> to group sentences into paragraphs.\n\nLine Breaks (<br>):\nThe <br> tag inserts a line break without starting a new paragraph.\n\nBest Practices:\n- Use headings in order (h1 then h2, etc.)\n- Don't skip heading levels\n- Use paragraphs for blocks of text\n- Use line breaks sparingly - prefer semantic structure",
      "code": "<h1>Main Heading</h1>\n<h2>Subheading</h2>\n<p>This is a paragraph of text.</p>\n<p>This is line one.<br>\nThis is line two after a break.</p>"
    },
    {
      "title": "Inline Style & Formatting Text",
      "note": "You can format parts of your text inline using HTML tags to emphasize or style specific sections without affecting entire blocks.\n\nCommon Formatting Tags:\n- <b> — Makes text bold\n- <i> — Makes text italic\n- <u> — Underlines the text\n- <mark> — Highlights text\n- <small> — Makes text smaller\n- <del> — Shows deleted (strikethrough) text\n\nInline Styles:\nYou can apply custom styles directly using the style attribute.\n\nBest Practices:\n- Prefer semantic tags (<strong>, <em>) over presentational tags (<b>, <i>)\n- Use CSS for complex styling\n- Keep inline styles minimal",
      "code": "<p>This is <b>bold</b> and this is <i>italic</i> text.</p>\n<p>Here is a <span style=\"color:blue;\">blue colored text</span>.</p>\n<p>This is <mark>highlighted</mark> and this is <del>deleted</del> text.</p>"
    },
    {
      "title": "Quoting Text, Comments",
      "note": "In HTML, you can include quotations and comments to clarify your content and your code.\n\nQuoting Text:\n- <blockquote>: Use for longer, block-level quotes. Browsers usually indent blockquotes\n- <q>: Use for short, inline quotations inside a paragraph\n\nAdding Comments:\nComments are notes in your HTML code that do not appear in the browser. They help explain the code for yourself or other developers.\n\nComment Syntax:\n<!-- This is a comment -->\n\nBest Practices:\n- Use comments to explain complex sections\n- Keep comments up-to-date\n- Don't over-comment obvious code\n- Use comments to mark sections",
      "code": "<blockquote>\n  This is a long quote that stands out as a separate block of text.\n</blockquote>\n\n<p>He said, <q>This is a short inline quote.</q></p>\n\n<!-- This is a comment that won't be visible -->"
    },
    {
      "title": "Adding Color and CSS",
      "note": "You can style your HTML content by adding colors and other design properties using CSS (Cascading Style Sheets). CSS can be applied inline, embedded in the page, or linked as an external stylesheet.\n\nAdding Color Inline:\nUse the style attribute directly on an HTML element to change its color.\n\nUsing CSS Classes:\nDefine colors in CSS classes and apply them to multiple elements.\n\nExternal Stylesheets:\nYou can also put all your CSS rules in a separate file (e.g., styles.css) and link it in your HTML.\n\nColor Value Types:\n- Named colors (red, blue)\n- HEX codes (#FF0000)\n- RGB values (rgb(255, 0, 0))\n- HSL values (hsl(0, 100%, 50%))",
      "code": "<p style=\"color: red;\">This text is red.</p>\n<h1 style=\"color: #007BFF;\">This heading is blue.</h1>\n\n<style>\n  .text-red { color: red; }\n  .text-green { color: green; }\n</style>\n\n<p class=\"text-red\">This text is red.</p>\n<p class=\"text-green\">This text is green.</p>"
    },
    {
      "title": "Favicon and Page Title",
      "note": "Every webpage should have a title that appears in the browser tab, and a favicon, the small icon displayed next to the page title.\n\nSetting the Page Title:\nUse the <title> tag inside the <head> section to set the page title.\n\nAdding a Favicon:\nThe favicon is usually a small image file like favicon.ico or PNG. Add it using the <link> tag in the <head>.\n\nFavicon Best Practices:\n- Size should be 16x16 or 32x32 pixels\n- Use .ico format for maximum compatibility\n- Place in root directory for automatic detection\n- Can use PNG for modern browsers\n\nSEO Considerations:\n- Keep title under 60 characters\n- Include important keywords\n- Make it descriptive and unique",
      "code": "<head>\n  <title>My Awesome Website</title>\n  <link rel=\"icon\" href=\"favicon.ico\" type=\"image/x-icon\">\n</head>"
    },
    {
      "title": "Tables, Lists (Ordered/Unordered)",
      "note": "HTML provides special tags to display data in tabular form and organize content using lists.\n\nTables:\nUse the <table> tag to display data in rows and columns.\n\nTable Elements:\n- <tr> – Table row\n- <th> – Table header cell\n- <td> – Table data cell\n\nLists:\nOrganize items using lists:\n- <ul> — Unordered list (bulleted)\n- <ol> — Ordered list (numbered)\n- <li> — List item\n\nList Best Practices:\n- Use unordered lists for items without sequence\n- Use ordered lists for steps or rankings\n- Nest lists for hierarchical data\n- Keep table usage for tabular data only",
      "code": "<table border=\"1\">\n  <tr>\n    <th>Name</th>\n    <th>Age</th>\n  </tr>\n  <tr>\n    <td>Alice</td>\n    <td>30</td>\n  </tr>\n</table>\n\n<ul>\n  <li>Apple</li>\n  <li>Banana</li>\n</ul>\n\n<ol>\n  <li>First Item</li>\n  <li>Second Item</li>\n</ol>"
    },
    {
      "title": "Class and ID Attributes",
      "note": "The class and id attributes are used to uniquely identify or group HTML elements. These attributes are essential for applying styles with CSS and manipulating elements with JavaScript.\n\nThe class Attribute:\n- Assigns one or more classes to an element\n- Multiple elements can share the same class\n- Used to apply styles to groups of elements\n\nThe id Attribute:\n- Assigns a unique identifier to an element\n- An id must be unique on the entire page\n- Useful for styling single elements or accessing them via JavaScript\n\nBest Practices:\n- Use meaningful names\n- Follow naming conventions (kebab-case)\n- Don't overuse IDs\n- Use classes for reusable styles",
      "code": "<div class=\"card highlight\">\n  This is a card with two classes.\n</div>\n\n<h1 id=\"main-title\">Welcome to My Site</h1>\n\n<script>\n  const title = document.getElementById('main-title');\n  title.style.color = 'blue';\n</script>"
    },
    {
      "title": "Using iframe",
      "note": "The <iframe> tag allows you to embed another HTML page within your current page. It is commonly used for embedding videos, maps, or other external content.\n\niframe Attributes:\n- src: URL of the page to embed\n- width: Width in pixels or percentage\n- height: Height in pixels or percentage\n- frameborder: Show/hide border (0 or 1)\n- allowfullscreen: Allow fullscreen mode\n\nSecurity Considerations:\n- Only embed content from trusted sources\n- Use sandbox attribute to restrict capabilities\n- Be aware of clickjacking risks\n- Consider performance impact\n\nCommon Uses:\n- Embedding YouTube videos\n- Google Maps integration\n- Third-party widgets\n- Documentation examples",
      "code": "<iframe \n  src=\"https://www.example.com\" \n  width=\"600\" \n  height=\"400\"\n  frameborder=\"0\"\n  allowfullscreen>\n</iframe>"
    },
    {
      "title": "JavaScript in HTML",
      "note": "Add interactivity to your web pages by including JavaScript using the <script> tag.\n\nWays to Include JavaScript:\n1. Inline scripts (directly in HTML)\n2. Internal scripts (in <script> tags)\n3. External scripts (linked .js files)\n\nScript Placement:\n- In <head> for early execution\n- Before </body> for better page load performance\n\nBest Practices:\n- Prefer external scripts\n- Use async/defer attributes when needed\n- Keep JavaScript separate from HTML\n- Follow progressive enhancement principles",
      "code": "<script>\n  alert('Hello, world!');\n</script>\n\n<!-- External script -->\n<script src=\"script.js\"></script>"
    },
    {
      "title": "Understanding File Paths",
      "note": "File paths tell the browser where to find resources like images, CSS files, or other pages.\n\nTypes of Paths:\n- Relative Path: Location relative to the current file\n  Example: images/photo.jpg\n- Absolute Path: Full URL starting with a protocol\n  Example: https://example.com/images/photo.jpg\n- Root-relative Path: Starts from website root\n  Example: /images/photo.jpg\n\nPath Navigation:\n- ./ Current directory\n- ../ Parent directory\n- / Root directory\n\nBest Practices:\n- Use relative paths for portability\n- Be consistent with path styles\n- Test paths after moving files\n- Consider URL structure for SEO",
      "code": "<!-- Relative path -->\n<img src=\"images/logo.png\" alt=\"Logo\">\n\n<!-- Absolute path -->\n<img src=\"https://example.com/images/logo.png\" alt=\"Logo\">\n\n<!-- Root-relative path -->\n<link href=\"/css/styles.css\" rel=\"stylesheet\">"
    },
    {
      "title": "Layout Techniques & Responsive Design",
      "note": "Use CSS techniques like Flexbox, Grid, and media queries to build layouts that adapt smoothly to different screen sizes and devices.\n\nKey Techniques:\n- Flexbox: One-dimensional layout for rows or columns\n- Grid: Two-dimensional layout system with rows and columns\n- Media Queries: Apply styles conditionally based on screen size or device\n\nResponsive Principles:\n- Mobile-first approach\n- Fluid grids\n- Flexible images\n- Media queries\n\nViewport Meta Tag:\nEssential for responsive design:\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">",
      "code": "<!DOCTYPE html>\n<html>\n<head>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <style>\n    .container {\n      display: grid;\n      grid-template-columns: 1fr 1fr;\n    }\n    @media (max-width: 600px) {\n      .container { grid-template-columns: 1fr; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div>Column 1</div>\n    <div>Column 2</div>\n  </div>\n</body>\n</html>"
    },
    {
      "title": "Semantic HTML",
      "note": "Semantic HTML uses meaningful tags that describe the purpose of the content, improving accessibility and SEO.\n\nCommon Semantic Tags:\n- <header> - Defines introductory content or navigation\n- <nav> - Contains navigation links\n- <main> - Represents the main content\n- <article> - Self-contained composition\n- <section> - Thematic grouping of content\n- <footer> - Footer section with info about the page\n\nBenefits:\n- Better accessibility\n- Improved SEO\n- Easier code maintenance\n- Clearer document structure\n\nNon-semantic Elements:\n- <div> - Generic block container\n- <span> - Generic inline container\n\nWhen to Use:\n- Always prefer semantic elements when appropriate\n- Use div/span only when no semantic element fits",
      "code": "<header>\n  <h1>Website Title</h1>\n  <nav>\n    <a href=\"/\">Home</a>\n    <a href=\"/about\">About</a>\n  </nav>\n</header>\n\n<main>\n  <article>\n    <h2>Article Title</h2>\n    <p>Article content...</p>\n  </article>\n</main>\n\n<footer>\n  <p>Copyright 2023</p>\n</footer>"
    },
    {
      "title": "Writing Clean Code",
      "note": "Writing clean, well-structured HTML makes your code easier to read, maintain, and debug.\n\nTips for Clean Code:\n- Use proper indentation for nested elements\n- Add comments to explain sections\n- Use meaningful tag and attribute names\n- Avoid inline styles when possible; prefer CSS classes\n- Keep your code DRY (Don't Repeat Yourself)\n- Validate your HTML\n\nHTML Validation:\n- Check for missing closing tags\n- Ensure proper nesting\n- Verify attribute values\n- Use W3C validator\n\nOrganization Tips:\n- Logical section grouping\n- Consistent naming conventions\n- Separate structure (HTML), presentation (CSS), and behavior (JS)",
      "code": "<!-- Main navigation -->\n<nav class=\"primary-nav\">\n  <ul>\n    <li><a href=\"/\">Home</a></li>\n    <li><a href=\"/about\">About</a></li>\n  </ul>\n</nav>\n\n<!-- Main content section -->\n<main>\n  <article class=\"blog-post\">\n    <h1>Post Title</h1>\n    <p>Well-structured content...</p>\n  </article>\n</main>"
    },
    {
      "title": "HTML Entities, Symbols, Images",
      "note": "HTML entities are special codes used to display reserved characters like &, <, >, and copyright symbols.\n\nCommon Entities:\n- &amp; - &\n- &lt; - <\n- &gt; - >\n- &copy; - ©\n- &reg; - ®\n\nEmbedding Images:\nUse <img> tag with src and alt attributes\n\nImage Formats:\n- JPEG: For photographs\n- PNG: For transparency\n- GIF: For animations\n- SVG: For vector graphics\n\nBest Practices:\n- Always include alt text\n- Optimize image sizes\n- Use responsive images\n- Consider lazy loading",
      "code": "<p>Use &amp; for ampersand, &lt; for less than</p>\n<p>Copyright &copy; 2023</p>\n\n<img src=\"logo.png\" alt=\"Company Logo\" width=\"200\" height=\"100\">"
    },
    {
      "title": "Charset & URL Encoding",
      "note": "Set the character encoding to UTF-8 to support most characters worldwide using the meta tag.\n\nCharset Declaration:\n<meta charset=\"UTF-8\">\n\nURL Encoding:\nUsed to encode special characters in URLs, replacing spaces and reserved characters with codes like %20.\n\nCommon Encodings:\n- Space: %20\n- <: %3C\n- >: %3E\n- &: %26\n- =: %3D\n\nBest Practices:\n- Always include charset meta tag early in <head>\n- Encode URLs properly\n- Use encodeURIComponent() in JavaScript\n- Test with special characters",
      "code": "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Page with UTF-8</title>\n</head>\n<body>\n  <p>Supports special characters: ñ, ü, 汉字</p>\n</body>\n</html>"
    },
    {
      "title": "HTML Forms & Input Types",
      "note": "Forms collect user input and are built using the <form> tag with various input types.\n\nCommon Input Types:\n- text – Single line text input\n- password – Password input\n- email – Email input with validation\n- number – Numeric input\n- checkbox – Multiple choices\n- radio – Single choice\n- submit – Button to submit form\n\nForm Attributes:\n- action: Where to send form data\n- method: HTTP method (GET/POST)\n- name: Identifies form\n- autocomplete: Enable/disable autofill\n\nBest Practices:\n- Always include labels\n- Use proper input types\n- Add validation\n- Make forms accessible",
      "code": "<form action=\"/submit\" method=\"post\">\n  <label for=\"username\">Username:</label>\n  <input type=\"text\" id=\"username\" name=\"username\" required>\n  \n  <label for=\"email\">Email:</label>\n  <input type=\"email\" id=\"email\" name=\"email\">\n  \n  <input type=\"submit\" value=\"Submit\">\n</form>"
    },
    {
      "title": "Form Attributes & Validation",
      "note": "Use HTML attributes to validate user input before submitting a form.\n\nCommon Validation Attributes:\n- required – Makes a field mandatory\n- minlength / maxlength – Set minimum/maximum length of input\n- pattern – Regular expression to enforce input format\n- type=\"email\" – Validates email format\n- type=\"number\" – Validates numeric input within a range\n\nAdditional Attributes:\n- placeholder: Hint text\n- readonly: Can't be modified\n- disabled: Can't be interacted with\n- autofocus: Automatically focused\n\nClient-side vs Server-side:\n- HTML validation is client-side only\n- Always validate on server too\n- Provide clear error messages",
      "code": "<form>\n  <label for=\"username\">Username (3+ letters):</label>\n  <input type=\"text\" id=\"username\" name=\"username\" \n         required minlength=\"3\" pattern=\"[A-Za-z]+\">\n  \n  <label for=\"age\">Age (1-120):</label>\n  <input type=\"number\" id=\"age\" name=\"age\" min=\"1\" max=\"120\">\n  \n  <input type=\"submit\" value=\"Submit\">\n</form>"
    },
    {
      "title": "Canvas and SVG Basics",
      "note": "Use the <canvas> element with JavaScript to draw graphics dynamically, or <svg> for scalable vector graphics defined in markup.\n\nCanvas:\n- Pixel-based drawing\n- Requires JavaScript\n- Good for games, data visualization\n\nSVG:\n- Vector-based\n- XML format\n- Good for icons, logos\n\nKey Differences:\n- Canvas is raster, SVG is vector\n- Canvas is scripted, SVG is declarative\n- Canvas better for complex animations\n- SVG better for resolution independence\n\nWhen to Use:\n- Canvas: Dynamic, pixel-based graphics\n- SVG: Resolution-independent graphics",
      "code": "<!-- Canvas example -->\n<canvas id=\"myCanvas\" width=\"200\" height=\"100\"></canvas>\n<script>\n  const canvas = document.getElementById('myCanvas');\n  const ctx = canvas.getContext('2d');\n  ctx.fillStyle = 'green';\n  ctx.fillRect(10, 10, 150, 75);\n</script>\n\n<!-- SVG example -->\n<svg width=\"100\" height=\"100\">\n  <circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"blue\" />\n</svg>"
    },
    {
      "title": "Embedding Audio, Video, Plugins",
      "note": "HTML5 introduced native support for audio and video with the <audio> and <video> tags, making plugins mostly obsolete.\n\nMedia Elements:\n- <audio>: For sound content\n- <video>: For video content\n\nCommon Attributes:\n- controls: Shows playback controls\n- autoplay: Starts automatically\n- loop: Loops the media\n- muted: Starts muted\n- preload: Hints how to load\n\nFormats:\n- Audio: MP3, WAV, OGG\n- Video: MP4, WebM, OGG\n\nBest Practices:\n- Include multiple sources\n- Provide fallback content\n- Consider accessibility\n- Optimize file sizes\n- Use poster images for video",
      "code": "<video width=\"320\" height=\"240\" controls>\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>\n\n<audio controls>\n  <source src=\"audio.mp3\" type=\"audio/mpeg\">\n  Your browser does not support the audio element.\n</audio>"
    }
  ],
  css: [
    
      {
  "title": "CSS Introduction",
  "note": "CSS (Cascading Style Sheets) is the language used to style and layout web pages. It controls colors, fonts, spacing, positioning, and even animations. While HTML provides the structure of a page, CSS defines its presentation, making websites visually appealing and easier to maintain.",
  "code": "<style>\n  body {\n    background-color: #f0f8ff;\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    color: #333;\n  }\n\n  h1 {\n    color: #2c3e50;\n    text-align: center;\n    text-transform: uppercase;\n  }\n\n  p {\n    font-size: 18px;\n    line-height: 1.6;\n    background-color: #ecf0f1;\n    padding: 10px;\n    border-left: 5px solid #3498db;\n  }\n\n  button {\n    background-color: #3498db;\n    color: white;\n    border: none;\n    padding: 10px 20px;\n    font-size: 16px;\n    border-radius: 5px;\n    cursor: pointer;\n  }\n\n  button:hover {\n    background-color: #2980b9;\n  }\n</style>\n\n<h1>Welcome to CSS</h1>\n<p>CSS makes websites beautiful by controlling colors, fonts, spacing, and layout. With CSS, we can separate content from design, making web pages more professional and consistent.</p>\n<button>Click Me</button>"

    },
    {
  "title": "CSS Syntax",
  "note": "A CSS rule defines how HTML elements are displayed on a web page. Each rule consists of a **selector** (which targets the HTML element) and a **declaration block** (enclosed in curly braces {}). Inside the declaration block, you define one or more **properties** and their corresponding **values**, separated by a colon and ending with a semicolon. This structure allows developers to apply multiple styles to elements in a clean and organized way.",
  "code": "<style>\n  /* Targeting the body element */\n  body {\n    background-color: #f0f8ff;\n    font-family: Arial, sans-serif;\n    color: #333;\n    margin: 20px;\n  }\n\n  /* Targeting all paragraphs */\n  p {\n    font-size: 16px;\n    line-height: 1.5;\n    color: #2c3e50;\n    padding: 10px;\n    border-left: 4px solid #3498db;\n  }\n\n  /* Targeting h1 elements */\n  h1 {\n    text-align: center;\n    color: #2980b9;\n    text-transform: uppercase;\n  }\n</style>\n\n<h1>CSS Syntax Example</h1>\n<p>This paragraph demonstrates the basic CSS syntax. The selector defines which HTML element to style, and the declaration block contains one or more properties with their values.</p>"
},
    {
  "title": "CSS Selectors",
  "note": "CSS selectors are used to **target HTML elements** so that styles can be applied to them. They determine **which elements** a particular set of styles affects. Common selector types include:\n- **Element selector**: targets all elements of a specific type (e.g., p, h1, div)\n- **Class selector**: targets elements with a specific class (e.g., .myClass)\n- **ID selector**: targets a unique element with a specific ID (e.g., #myId)\n- **Attribute selector**: targets elements based on an attribute value (e.g., [type='text'])\n- **Group selector**: applies the same style to multiple selectors at once (e.g., h1, h2, p)\nUsing selectors effectively helps keep your CSS organized and reusable.",
  "code": "<style>\n  /* Element selector */\n  p {\n    color: green;\n    line-height: 1.5;\n  }\n\n  /* Class selector */\n  .highlight {\n    font-size: 18px;\n    background-color: #f9f9a9;\n    padding: 5px;\n  }\n\n  /* ID selector */\n  #mainTitle {\n    margin: 20px 0;\n    text-align: center;\n    color: #2980b9;\n  }\n\n  /* Attribute selector */\n  input[type='text'] {\n    border: 2px solid #3498db;\n    padding: 5px;\n  }\n\n  /* Group selector */\n  h1, h2, p {\n    font-family: Arial, sans-serif;\n  }\n</style>\n\n<h1 id='mainTitle'>Welcome to CSS Selectors</h1>\n<p>This paragraph uses an element selector.</p>\n<p class='highlight'>This paragraph uses a class selector for highlighting.</p>\n<input type='text' placeholder='Text input with attribute selector'>"
},
    {
  "title": "CSS Comments",
  "note": "CSS comments are used to **add notes or explanations** within your stylesheet. They are **ignored by the browser**, so they do not affect how your web page is displayed. Comments are helpful for:\n- Documenting the purpose of styles\n- Temporarily disabling code without deleting it\n- Organizing large stylesheets into sections for easier maintenance\nUsing comments makes your CSS more readable and easier to understand for yourself and others.",
  "code": "<style>\n  /* This is a comment describing the body styles */\n  body {\n    background-color: white;\n    font-family: Arial, sans-serif; /* Font for the entire page */\n    color: #333;\n  }\n\n  /* Commenting out a style temporarily\n  p {\n    color: red;\n  }\n  */\n\n  /* Section: Headings */\n  h1 {\n    text-align: center;\n    color: #2980b9;\n  }\n</style>\n\n<h1>CSS Comments Example</h1>\n<p>Comments help explain your CSS code and can temporarily disable styles without deleting them.</p>"
},
    {
  "title": "CSS Colors",
  "note": "CSS allows you to style elements using a variety of color formats. You can specify colors using:\n- **Named colors**: predefined color names like red, blue, green.\n- **Hex codes**: 6-digit or 3-digit codes, e.g., #ff0000 or #f00.\n- **RGB**: define colors using red, green, blue values, e.g., rgb(255,0,0).\n- **RGBA**: RGB with alpha for transparency, e.g., rgba(255,0,0,0.5).\n- **HSL**: hue, saturation, lightness, e.g., hsl(120, 100%, 50%).\n- **HSLA**: HSL with alpha for transparency.\nUsing different color formats gives flexibility for design and allows creating visually appealing web pages.",
  "code": "<style>\n  /* Using hex color */\n  h1 {\n    color: #ff0000; /* Red heading */\n  }\n\n  /* Using RGB color */\n  p {\n    color: rgb(0,128,0); /* Green paragraph */\n    font-size: 18px;\n  }\n\n  /* Using RGBA for transparency */\n  div {\n    background-color: rgba(0,0,255,0.3); /* Semi-transparent blue background */\n    padding: 10px;\n    border: 1px solid #2980b9;\n  }\n\n  /* Using HSL color */\n  span {\n    color: hsl(240, 100%, 50%); /* Pure blue text */\n  }\n</style>\n\n<h1>CSS Colors Example</h1>\n<p>This paragraph uses an RGB color.</p>\n<div>This div uses a semi-transparent RGBA background.</div>\n<span>Text using HSL color format.</span>"
},
    {
  "title": "CSS Box Model",
  "note": "In CSS, every HTML element is considered a rectangular box, which consists of **four parts**:\n- **Content**: The actual content of the element, such as text or images.\n- **Padding**: The space between the content and the border.\n- **Border**: The edge surrounding the padding and content.\n- **Margin**: The outermost space that separates the element from other elements.\nUnderstanding the box model is crucial for **layout design, spacing, and positioning**, as it determines how elements interact and occupy space on a webpage.",
  "code": "<style>\n  .box {\n    width: 200px;           /* Width of the content area */\n    padding: 10px;           /* Space inside the box */\n    border: 2px solid #000;  /* Box border */\n    margin: 20px;            /* Space outside the box */\n    background-color: #f0f8ff;\n  }\n</style>\n\n<div class='box'>\n  This is a box demonstrating the CSS Box Model.\n</div>\n<p>Content + Padding + Border + Margin together make the total space occupied by the box.</p>"
},
    {
  "title": "CSS Text & Fonts",
  "note": "CSS allows you to style text and control typography for better readability and design. You can modify:\n- **font-family**: Set the typeface (e.g., Arial, Times New Roman, sans-serif)\n- **font-size**: Adjust the size of text\n- **font-weight**: Make text bold or light\n- **line-height**: Control spacing between lines\n- **text-align**: Align text (left, right, center, justify)\n- **text-decoration**: Add underline, overline, or strike-through\n- **letter-spacing & word-spacing**: Adjust spacing between letters and words\nUsing these properties helps create visually appealing and readable content on your web pages.",
  "code": "<style>\n  /* Styling the body text */\n  body {\n    font-family: Arial, sans-serif;  /* Typeface */\n    font-size: 16px;                  /* Font size */\n    line-height: 1.5;                 /* Line spacing */\n    color: #333;\n    margin: 20px;\n  }\n\n  /* Styling headings */\n  h1 {\n    text-align: center;               /* Center align */\n    font-weight: bold;                /* Bold text */\n    color: #2980b9;\n  }\n\n  /* Styling paragraphs */\n  p {\n    text-align: justify;               /* Justify text */\n    font-size: 14px;\n    letter-spacing: 0.5px;\n  }\n</style>\n\n<h1>CSS Text & Fonts Example</h1>\n<p>This paragraph demonstrates font styling, alignment, line-height, and letter-spacing using CSS.</p>"
},
    {
  "title": "CSS Position & Z‑index",
  "note": "The CSS **position** property determines how an element is placed on the page. Common values include:\n- **static**: Default positioning, elements follow the normal flow.\n- **relative**: Positioned relative to its normal position.\n- **absolute**: Positioned relative to the nearest positioned ancestor.\n- **fixed**: Positioned relative to the viewport, stays in place when scrolling.\n- **sticky**: Switches between relative and fixed based on scroll position.\n\nThe **z-index** property controls the **stacking order** of overlapping elements. Higher values appear on top. Understanding these properties is key for layouts, overlays, and interactive designs.",
  "code": "<style>\n  /* Relative positioning */\n  .relative {\n    position: relative;\n    top: 10px;\n    left: 0;\n    background-color: #f9c74f;\n    padding: 10px;\n    width: 150px;\n  }\n\n  /* Absolute positioning */\n  .absolute {\n    position: absolute;\n    top: 50px;\n    left: 200px;\n    background-color: #90be6d;\n    padding: 10px;\n    width: 150px;\n  }\n\n  /* Overlay with z-index */\n  .overlay {\n    position: relative;\n    z-index: 10;\n    background-color: #f94144;\n    color: white;\n    padding: 10px;\n    width: 150px;\n    top: -30px;\n    left: 100px;\n  }\n</style>\n\n<div class='relative'>Relative Box</div>\n<div class='absolute'>Absolute Box</div>\n<div class='overlay'>Overlay Box (Higher Z-index)</div>"
},
    {
  "title": "CSS Display & Visibility",
  "note": "The **display** property determines how an element behaves in the layout:\n- **block**: Element takes full width and starts on a new line.\n- **inline**: Element only takes as much width as necessary and stays in line with others.\n- **inline-block**: Behaves like inline but allows setting width/height.\n- **none**: Hides the element completely; it does not occupy space.\n\nThe **visibility** property controls whether an element is visible:\n- **visible**: Element is shown.\n- **hidden**: Element is hidden but still occupies space in the layout.\n\nUnderstanding the difference helps control layout and element appearance effectively.",
  "code": "<style>\n  /* Hides element completely */\n  .hidden {\n    display: none;\n  }\n\n  /* Element is invisible but occupies space */\n  .invisible {\n    visibility: hidden;\n  }\n\n  /* Example visible element */\n  .visible {\n    display: block;\n    background-color: #90be6d;\n    padding: 10px;\n    margin: 10px 0;\n  }\n</style>\n\n<div class='visible'>Visible Box</div>\n<div class='hidden'>This box is hidden using display: none</div>\n<div class='invisible'>This box is hidden using visibility: hidden</div>"
},
    {
  "title": "CSS Flexbox Intro",
  "note": "Flexbox is a modern CSS layout system that makes it easier to design flexible and efficient layouts. It allows you to arrange items **horizontally or vertically** in a container and control alignment, spacing, and distribution. Key Flexbox concepts include:\n- **display: flex**: defines a flex container.\n- **flex-direction**: sets the direction of items (row, column, row-reverse, column-reverse).\n- **justify-content**: controls horizontal alignment (flex-start, flex-end, center, space-between, space-around).\n- **align-items**: controls vertical alignment of items within the container.\n- **flex**: defines how items grow or shrink to fill available space.\nFlexbox simplifies responsive designs and reduces the need for float or positioning hacks.",
  "code": "<style>\n  .container {\n    display: flex;                    /* Defines flex container */\n    justify-content: space-between;    /* Space between items */\n    align-items: center;               /* Align items vertically */\n    background-color: #f0f8ff;\n    padding: 10px;\n  }\n\n  .item {\n    flex: 1;                           /* Items grow to fill space */\n    background-color: #90be6d;\n    margin: 5px;\n    padding: 20px;\n    text-align: center;\n    color: white;\n    font-weight: bold;\n  }\n</style>\n\n<div class='container'>\n  <div class='item'>Item 1</div>\n  <div class='item'>Item 2</div>\n  <div class='item'>Item 3</div>\n</div>"
},
    {
  "title": "CSS Grid Intro",
  "note": "CSS Grid is a powerful two-dimensional layout system that allows you to create complex web layouts using **rows and columns**. It provides precise control over the placement, size, and spacing of elements within a container. Key Grid concepts include:\n- **display: grid**: defines a grid container.\n- **grid-template-columns / grid-template-rows**: sets the number and size of columns and rows.\n- **grid-gap / gap**: defines spacing between grid items.\n- **grid-column / grid-row**: allows an item to span multiple columns or rows.\nCSS Grid is highly flexible, making it easier to create responsive designs without relying on floats or positioning hacks.",
  "code": "<style>\n  .grid {\n    display: grid;                     /* Define grid container */\n    grid-template-columns: repeat(3, 1fr); /* 3 equal columns */\n    grid-gap: 10px;                     /* Gap between items */\n    background-color: #f0f8ff;\n    padding: 10px;\n  }\n\n  .grid-item {\n    background-color: #f94144;\n    color: white;\n    padding: 20px;\n    text-align: center;\n    font-weight: bold;\n  }\n</style>\n\n<div class='grid'>\n  <div class='grid-item'>Item 1</div>\n  <div class='grid-item'>Item 2</div>\n  <div class='grid-item'>Item 3</div>\n  <div class='grid-item'>Item 4</div>\n  <div class='grid-item'>Item 5</div>\n  <div class='grid-item'>Item 6</div>\n</div>"
},
    {
  "title": "CSS Media Queries",
  "note": "CSS **media queries** enable **responsive design** by applying styles conditionally based on the characteristics of the user's device or viewport. They are commonly used to adjust layouts, font sizes, or element visibility for different screen sizes. Key features include:\n- **max-width / min-width**: Apply styles when the viewport is below or above a certain width.\n- **orientation**: Detect portrait or landscape mode.\n- **device type**: Target screens, print, or other media types.\nMedia queries help ensure your website looks good on **mobile phones, tablets, and desktops** without duplicating code.",
  "code": "<style>\n  body {\n    background-color: white;\n    font-family: Arial, sans-serif;\n    padding: 20px;\n  }\n\n  h1 {\n    color: #2980b9;\n  }\n\n  /* Media query for small screens */\n  @media (max-width: 600px) {\n    body {\n      background-color: lightgray;\n      padding: 10px;\n    }\n\n    h1 {\n      font-size: 18px;\n      text-align: center;\n    }\n  }\n</style>\n\n<h1>Responsive Design Example</h1>\n<p>Resize the browser window to see how media queries change the background color and font size on smaller screens.</p>"
},
    {
  "title": "CSS Pseudo‑classes & Pseudo‑elements",
  "note": "CSS **pseudo-classes** and **pseudo-elements** allow you to style elements based on their state or specific parts of the element, without adding extra HTML. Key points include:\n\n**Pseudo-classes**:\n- Applied to elements based on state or position.\n- Examples: `:hover`, `:focus`, `:first-child`, `:nth-child(n)`.\n- Useful for interactive effects like hover highlights or styling selected items.\n\n**Pseudo-elements**:\n- Target specific parts of an element.\n- Examples: `::before`, `::after`, `::first-line`, `::first-letter`.\n- Useful for adding decorative content or styling portions of text.\n\nUsing pseudo-classes and pseudo-elements improves design flexibility without cluttering HTML with extra elements.",
  "code": "<style>\n  /* Pseudo-class: hover */\n  a:hover {\n    color: red;                 /* Link changes color on hover */\n    text-decoration: underline;\n  }\n\n  /* Pseudo-class: first child */\n  li:first-child {\n    font-weight: bold;           /* Make first list item bold */\n  }\n\n  /* Pseudo-element: first line of paragraph */\n  p::first-line {\n    font-variant: small-caps;   /* Style the first line of paragraph */\n    color: #2980b9;\n  }\n\n  /* Pseudo-element: before content */\n  h2::before {\n    content: '🔥 ';               /* Adds fire emoji before heading */\n  }\n</style>\n\n<h2>Pseudo-classes & Pseudo-elements Example</h2>\n<ul>\n  <li>First item</li>\n  <li>Second item</li>\n  <li>Third item</li>\n</ul>\n<p>This is a paragraph demonstrating the ::first-line pseudo-element styling.</p>\n<a href='#'>Hover over this link</a>"
},
    {
  "title": "CSS Transitions & Animations",
  "note": "CSS **transitions** and **animations** allow elements to change properties smoothly, improving interactivity and visual appeal.\n\n**Transitions**:\n- Enable smooth change of CSS property values when they change state (e.g., hover, focus).\n- Key properties: `transition-property`, `transition-duration`, `transition-timing-function`, `transition-delay`.\n\n**Animations**:\n- Define keyframes to animate properties over time.\n- Key properties: `@keyframes`, `animation-name`, `animation-duration`, `animation-iteration-count`, `animation-direction`, `animation-timing-function`.\n- Animations can loop, alternate, and run infinitely.\n\nUsing transitions and animations enhances user experience by adding fluid motion and interactive feedback.",
  "code": "<style>\n  /* Transition example */\n  .button {\n    background-color: #90be6d;\n    color: white;\n    padding: 10px 20px;\n    border: none;\n    cursor: pointer;\n    transition: background-color 0.3s ease-in, transform 0.3s ease;\n  }\n\n  .button:hover {\n    background-color: #f94144;\n    transform: scale(1.1);\n  }\n\n  /* Animation example */\n  @keyframes fadeIn {\n    from { opacity: 0; transform: translateY(-20px); }\n    to { opacity: 1; transform: translateY(0); }\n  }\n\n  .box {\n    width: 150px;\n    height: 150px;\n    background-color: #f9c74f;\n    animation: fadeIn 2s infinite alternate;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: white;\n    font-weight: bold;\n    margin-top: 20px;\n  }\n</style>\n\n<button class='button'>Hover Me</button>\n<div class='box'>Fade In</div>"
},
    {
  "title": "CSS Variables (Custom Properties)",
  "note": "CSS **variables**, also called **custom properties**, allow you to store reusable values and apply them consistently across your stylesheet. They can be dynamically updated and scoped to specific elements or globally. Key points include:\n- **Declaration**: Variables are declared using `--variable-name` inside a selector (commonly `:root` for global scope).\n- **Usage**: Access variables with `var(--variable-name)`.\n- **Scoping**: Variables can be defined globally or locally for specific elements.\n- **Dynamic updates**: Variables can be updated with JavaScript for interactive designs.\nUsing CSS variables reduces repetition and makes theme management easier.",
  "code": "<style>\n  /* Define global CSS variables */\n  :root {\n    --main-color: #3498db;\n    --secondary-color: #f94144;\n    --padding: 15px;\n  }\n\n  /* Apply variables */\n  body {\n    background-color: var(--main-color);\n    color: white;\n    font-family: Arial, sans-serif;\n    padding: var(--padding);\n  }\n\n  h1 {\n    color: var(--secondary-color);\n  }\n\n  /* Local variable scoped to a section */\n  .card {\n    --card-bg: #90be6d;\n    background-color: var(--card-bg);\n    padding: var(--padding);\n    margin-top: 10px;\n    border-radius: 8px;\n    color: white;\n  }\n</style>\n\n<h1>CSS Variables Example</h1>\n<div class='card'>This is a card using a locally scoped CSS variable.</div>"
},
  ],
javascript:[
  {
  "title": "JavaScript Introduction",
  "note": "JavaScript is a **versatile, high-level programming language** primarily used to create **interactive and dynamic web pages**. It can manipulate HTML, CSS, handle events, perform calculations, communicate with servers, and much more. JavaScript runs in the browser as well as on the server (Node.js). Key features include:\n- **Event handling**: Respond to user actions like clicks, keypresses, and mouse movements.\n- **DOM manipulation**: Dynamically change the content and style of web pages.\n- **Data handling**: Work with variables, arrays, objects, and JSON.\n- **Asynchronous programming**: Fetch data from servers using promises, async/await, or callbacks.\n- **Cross-platform**: Works on desktop, mobile, and server environments.\nLearning JavaScript is essential for modern web development and building interactive experiences.",
  "code": "<script>\n  // Print a message to the console\n  console.log('Hello, JavaScript!');\n\n  // Change content of an HTML element\n  document.addEventListener('DOMContentLoaded', () => {\n    const msg = document.getElementById('message');\n    msg.textContent = 'Welcome to JavaScript Learning!';\n  });\n</script>\n\n<h1 id='message'>Original Message</h1>"
},
  {
  "title": "JavaScript Variables",
  "note": "In JavaScript, **variables** are used to store data values that can be used and manipulated throughout your program. Variables can hold different types of data such as numbers, strings, booleans, objects, and arrays. There are three ways to declare variables:\n\n- **let**: Declares a block-scoped variable that can be updated.\n- **const**: Declares a block-scoped constant that cannot be reassigned.\n- **var**: Declares a function-scoped variable (older, less recommended).\n\nUsing variables allows your program to store and reuse information efficiently.",
  "code": "<script>\n  // Using let for a variable that can change\n  let name = \"John\";\n  console.log('Name:', name);\n  name = \"Alice\";\n  console.log('Updated Name:', name);\n\n  // Using const for a constant value\n  const age = 30;\n  console.log('Age:', age);\n\n  // Using var (function-scoped, older syntax)\n  var country = 'Ethiopia';\n  console.log('Country:', country);\n</script>"
}
,
  {
  "title": "JavaScript Let",
  "note": "The **`let`** keyword in JavaScript declares **block-scoped variables**, meaning the variable exists only within the block, statement, or expression where it is defined. Unlike `var`, `let`:\n- Cannot be re-declared in the same scope.\n- Can be updated (its value can change).\n- Helps avoid issues with variable hoisting seen with `var`.\nUsing `let` is recommended for variables whose values will change within a specific scope.",
  "code": "<script>\n  // Declare a block-scoped variable using let\n  let count = 10;\n  console.log('Initial count:', count);\n\n  // Update the variable\n  count = 20;\n  console.log('Updated count:', count);\n\n  // Example of block scope\n  if (true) {\n    let count = 50; // different 'count' inside this block\n    console.log('Block-scoped count:', count);\n  }\n\n  console.log('Global count remains:', count);\n</script>"
},
  {
  "title": "JavaScript Const",
  "note": "The **`const`** keyword in JavaScript declares **block-scoped constants**. Once a value is assigned to a `const` variable, it **cannot be reassigned**. Key points:\n- Block-scoped: Exists only within the block where defined.\n- Cannot be re-declared or reassigned.\n- Useful for values that should remain constant, like configuration settings, mathematical constants, or references.\n- For objects and arrays, the reference cannot change, but the content can be modified.\nUsing `const` helps prevent accidental reassignment and ensures safer code.",
  "code": "<script>\n  // Declare a constant\n  const PI = 3.14;\n  console.log('PI:', PI);\n\n  // Attempting to reassign will cause an error\n  // PI = 3; // Un-commenting this line will throw: Assignment to constant variable.\n\n  // Const with objects\n  const person = { name: 'John', age: 30 };\n  console.log('Person:', person);\n\n  // Modifying object properties is allowed\n  person.age = 31;\n  console.log('Updated Person:', person);\n\n  // Reassigning the object reference is NOT allowed\n  // person = { name: 'Alice' }; // Error\n</script>"
}
,
{
  "title": "JavaScript Operators",
  "note": "In JavaScript, **operators** are symbols or keywords that perform operations on values and variables. They are essential for calculations, comparisons, and controlling program flow. Key categories include:\n\n- **Arithmetic Operators**: `+`, `-`, `*`, `/`, `%`, `**` (exponentiation)\n- **Assignment Operators**: `=`, `+=`, `-=`, `*=`, `/=`\n- **Comparison Operators**: `==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`\n- **Logical Operators**: `&&` (AND), `||` (OR), `!` (NOT)\n- **Unary Operators**: `++`, `--`, `typeof`, `!`\n- **Ternary Operator**: `condition ? expr1 : expr2`\n\nOperators allow you to perform calculations, evaluate conditions, and control the logic of your programs efficiently.",
  "code": "<script>\n  // Arithmetic operators\n  let sum = 5 + 10;\n  let product = 4 * 3;\n  console.log('Sum:', sum, 'Product:', product);\n\n  // Assignment operators\n  let x = 10;\n  x += 5; // x = x + 5\n  console.log('Updated x:', x);\n\n  // Comparison operators\n  let isEqual = (5 === 5); // true\n  let isNotEqual = (5 !== 3); // true\n  console.log('isEqual:', isEqual, 'isNotEqual:', isNotEqual);\n\n  // Logical operators\n  let a = true;\n  let b = false;\n  console.log('a && b:', a && b);\n  console.log('a || b:', a || b);\n  console.log('!a:', !a);\n\n  // Ternary operator\n  let age = 18;\n  let status = age >= 18 ? 'Adult' : 'Minor';\n  console.log('Status:', status);\n</script>"
},
  {
  "title": "JavaScript Functions",
  "note": "In JavaScript, **functions** are reusable blocks of code designed to perform a specific task or calculate a value. Functions allow you to avoid repetition, organize code logically, and enhance maintainability. Key points:\n\n- **Function Declaration**: Named functions that can be called anywhere after declaration.\n- **Function Expression**: Functions stored in variables.\n- **Arrow Functions**: Concise syntax introduced in ES6.\n- **Parameters and Arguments**: Functions can take inputs (parameters) and return outputs (values).\n- **Scope**: Variables inside a function are local, outside variables are global unless explicitly passed.",
  "code": "<script>\n  // Function declaration\n  function greet(name) {\n    return 'Hello ' + name + '!';\n  }\n  console.log(greet('Alice'));\n\n  // Function expression\n  const add = function(a, b) {\n    return a + b;\n  };\n  console.log('Sum:', add(5, 10));\n\n  // Arrow function (ES6)\n  const multiply = (x, y) => x * y;\n  console.log('Product:', multiply(4, 3));\n\n  // Function with default parameters\n  function welcome(name = 'Guest') {\n    console.log('Welcome, ' + name);\n  }\n  welcome();\n  welcome('Bob');\n</script>"
},
  {
  "title": "JavaScript Objects",
  "note": "In JavaScript, **objects** are used to store collections of **key-value pairs**, representing real-world entities or complex data structures. Objects allow grouping of related data and functions (methods) for better organization. Key points:\n\n- **Properties**: Key-value pairs representing object data.\n- **Methods**: Functions defined within objects.\n- **Accessing values**: Dot notation (`obj.key`) or bracket notation (`obj['key']`).\n- **Dynamic properties**: You can add, modify, or delete properties at runtime.\n- **Nested objects**: Objects can contain other objects or arrays.\nUsing objects makes data modeling more intuitive and structured.",
  "code": "<script>\n  // Creating an object\n  const person = {\n    name: 'Bob',\n    age: 25,\n    job: 'Developer',\n    greet: function() {\n      return 'Hello, I am ' + this.name;\n    }\n  };\n\n  // Accessing properties\n  console.log(person.name); // Bob\n  console.log(person['age']); // 25\n\n  // Calling a method\n  console.log(person.greet()); // Hello, I am Bob\n\n  // Adding a new property\n  person.country = 'Ethiopia';\n  console.log(person.country); // Ethiopia\n\n  // Nested object example\n  person.address = { city: 'Addis Ababa', zip: 1000 };\n  console.log(person.address.city); // Addis Ababa\n</script>"
},
  {
  "title": "JavaScript Arrays",
  "note": "In JavaScript, **arrays** are used to store **ordered collections of values**. Arrays can hold multiple data types, including numbers, strings, objects, and even other arrays (nested arrays). Arrays come with a variety of built-in methods to manipulate, search, and iterate over data. Key points:\n\n- **Accessing elements**: Use zero-based indexing (`array[0]`).\n- **Modifying arrays**: You can add, remove, or update elements.\n- **Array methods**: `push()`, `pop()`, `shift()`, `unshift()`, `splice()`, `slice()`, `forEach()`, `map()`, `filter()`, and more.\n- **Length property**: Get the number of elements in an array.\n- **Iteration**: Use loops or higher-order functions to traverse arrays.",
  "code": "<script>\n  // Creating an array\n  const fruits = ['apple', 'banana', 'cherry'];\n  console.log(fruits[0]); // apple\n\n  // Adding elements\n  fruits.push('orange');\n  console.log(fruits); // ['apple','banana','cherry','orange']\n\n  // Removing elements\n  fruits.pop();\n  console.log(fruits); // ['apple','banana','cherry']\n\n  // Iterating through an array\n  fruits.forEach(fruit => console.log('Fruit:', fruit));\n\n  // Mapping array to new array\n  const upperFruits = fruits.map(fruit => fruit.toUpperCase());\n  console.log('Uppercase Fruits:', upperFruits);\n\n  // Array length\n  console.log('Number of fruits:', fruits.length);\n</script>"
},
  {
  "title": "JavaScript Strings",
  "note": "In JavaScript, strings are sequences of characters used to represent text. Strings can be enclosed in single quotes, double quotes, or backticks (for template literals). JavaScript provides many methods to manipulate strings, including concatenation, searching, slicing, and transforming case.\n\n- Access characters using index: `str[0]`\n- String length: `str.length`\n- Common methods: `toUpperCase()`, `toLowerCase()`, `concat()`, `slice()`, `substring()`, `includes()`, `replace()`\n- Template literals: Embed expressions with backticks: `` `Hello ${name}` ``\nStrings are fundamental for displaying text, handling user input, and processing data.",
  "code": "<script>\n  let greeting = \"Hello\";\n  console.log(greeting.toUpperCase()); // HELLO\n\n  // Concatenation\n  let name = 'Alice';\n  console.log(greeting + ', ' + name + '!'); // Hello, Alice!\n\n  // Template literals\n  console.log(`${greeting}, ${name}! Welcome.`); // Hello, Alice! Welcome.\n\n  // String methods\n  console.log(greeting.length); // 5\n  console.log(greeting.includes('ell')); // true\n  console.log(greeting.replace('Hello', 'Hi')); // Hi\n</script>"
},
  {
  "title": "JavaScript String Templates",
  "note": "Template literals in JavaScript allow embedding expressions and variables directly into strings using **backticks (`)** and **${}** syntax. They make string concatenation easier and support multi-line strings. Key points:\n\n- Use backticks (`) instead of single or double quotes.\n- Embed variables or expressions inside `${}`.\n- Support multi-line strings without escape characters.\n- Useful for generating dynamic messages, HTML snippets, or combining variables into readable text.",
  "code": "<script>\n  let name = \"Jane\";\n  let age = 25;\n\n  // Basic template literal\n  console.log(`Hello, ${name}!`); // Hello, Jane!\n\n  // Embedding expressions\n  console.log(`${name} will be ${age + 1} next year.`); // Jane will be 26 next year.\n\n  // Multi-line string\n  let message = `Dear ${name},\nWelcome to the JavaScript tutorial.\nEnjoy learning!`;\n  console.log(message);\n</script>"
},
  {
  "title": "JavaScript Numbers",
  "note": "In JavaScript, numbers are represented as **floating-point values**, which means all numbers, including integers and decimals, are treated the same. JavaScript also provides special numeric values such as `NaN` (Not-a-Number) and `Infinity`.\n\n- **Type**: All numbers are of type `number`.\n- **Operations**: Addition, subtraction, multiplication, division, modulus, and exponentiation.\n- **Special values**: `NaN` for invalid calculations, `Infinity` for values exceeding the maximum number.\n- **Number methods**: `toFixed()`, `toPrecision()`, `parseInt()`, `parseFloat()`, `isNaN()`, `isFinite()`.",
  "code": "<script>\n  let num = 123.45;\n  console.log('Type:', typeof num); // number\n\n  // Basic arithmetic\n  let sum = num + 10;\n  let product = num * 2;\n  console.log('Sum:', sum, 'Product:', product);\n\n  // Special values\n  let invalid = 'abc' / 2;\n  console.log('Invalid:', invalid); // NaN\n  console.log('Infinity example:', 1 / 0); // Infinity\n\n  // Number methods\n  console.log('Fixed:', num.toFixed(1)); // 123.5\n  console.log('Precision:', num.toPrecision(4)); // 123.5\n  console.log('Parsed integer:', parseInt('456')); // 456\n</script>"
},
  {
  "title": "JavaScript BigInt",
  "note": "BigInt is a special numeric type in JavaScript that allows you to work with integers larger than the safe limit for the Number type. It is useful when dealing with very large integers, such as in cryptography, high-precision calculations, or handling large IDs.\n\n- Declare BigInt by appending `n` to the end of an integer or using `BigInt()`.\n- Supports arithmetic operations: addition, subtraction, multiplication, division, and exponentiation.\n- Cannot be mixed directly with regular Number types; you need explicit conversion.",
  "code": "<script>\n  // Declaring BigInt\n  const bigNumber = 9007199254740991n;\n  console.log(bigNumber + 1n); // 9007199254740992n\n\n  // Using BigInt constructor\n  const anotherBig = BigInt('123456789012345678901234567890');\n  console.log(anotherBig);\n\n  // Arithmetic with BigInt\n  const sum = bigNumber + 10n;\n  const product = bigNumber * 2n;\n  console.log('Sum:', sum, 'Product:', product);\n\n  // Mixing Number and BigInt (requires conversion)\n  const num = 5;\n  console.log(bigNumber + BigInt(num)); // Works\n</script>"
},
  {
  "title": "JavaScript Dates",
  "note": "The Date object in JavaScript allows you to work with dates and times. You can create a date, access individual components (year, month, day, hour, minute, second), format it, and perform calculations such as adding or subtracting days.",
  "code": "<script>\n  // Current date and time\n  const now = new Date();\n  console.log('Current Date and Time:', now.toLocaleString());\n\n  // Accessing date components\n  console.log('Year:', now.getFullYear());\n  console.log('Month:', now.getMonth() + 1); // Months are zero-based\n  console.log('Day:', now.getDate());\n  console.log('Hours:', now.getHours());\n  console.log('Minutes:', now.getMinutes());\n  console.log('Seconds:', now.getSeconds());\n\n  // Creating a specific date\n  const birthday = new Date('2000-01-15');\n  console.log('Birthday:', birthday.toDateString());\n</script>"
},
  {
  "title": "JavaScript Math",
  "note": "The Math object in JavaScript provides built-in constants and functions to perform mathematical operations. You can use it for arithmetic, rounding, powers, square roots, trigonometry, logarithms, and generating random numbers.",
  "code": "<script>\n  // Constants\n  console.log('PI:', Math.PI);\n  console.log('Euler\'s number (e):', Math.E);\n\n  // Basic operations\n  console.log('Square root of 16:', Math.sqrt(16));\n  console.log('2 to the power of 3:', Math.pow(2, 3));\n  console.log('Absolute value of -5:', Math.abs(-5));\n\n  // Rounding\n  console.log('Ceiling of 4.2:', Math.ceil(4.2));\n  console.log('Floor of 4.8:', Math.floor(4.8));\n  console.log('Round 4.5:', Math.round(4.5));\n</script>"
},
  {
  "title": "JavaScript Random",
  "note": "The Math.random() function generates a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive). You can scale and manipulate this value to create random numbers within a specific range, including integers.",
  "code": "<script>\n  // Random number between 0 and 1\n  const rand = Math.random();\n  console.log('Random number between 0 and 1:', rand);\n\n  // Random number between 0 and 10\n  const rand10 = Math.random() * 10;\n  console.log('Random number between 0 and 10:', rand10);\n\n  // Random integer between 1 and 10\n  const randInt = Math.floor(Math.random() * 10) + 1;\n  console.log('Random integer between 1 and 10:', randInt);\n</script>"
},
  {
  "title": "JavaScript Booleans",
  "note": "Booleans in JavaScript represent one of two values: true or false. They are commonly used in conditional statements, loops, and logical operations to control the flow of code. Any expression that evaluates to true or false can be used as a Boolean.",
  "code": "<script>\n  // Boolean variables\n  let isLoggedIn = true;\n  let hasPermission = false;\n\n  console.log('Is logged in?', isLoggedIn); // true\n  console.log('Has permission?', hasPermission); // false\n\n  // Boolean expressions\n  let age = 20;\n  let canVote = age >= 18;\n  console.log('Can vote?', canVote); // true\n\n  // Using Booleans in conditions\n  if (isLoggedIn) {\n    console.log('Welcome back!');\n  } else {\n    console.log('Please log in.');\n  }\n</script>"
},
  {
  "title": "JavaScript If Else",
  "note": "If-else statements in JavaScript are used to execute different blocks of code based on whether a condition evaluates to true or false. They allow your program to make decisions dynamically.\n\n- The `if` block runs when the condition is true.\n- The `else` block runs when the condition is false.\n- `else if` can be used to check multiple conditions.\n- Conditions can use comparison operators (`==`, `===`, `>`, `<`, `>=`, `<=`) and logical operators (`&&`, `||`, `!`).",
  "code": "<script>\n  let age = 20;\n\n  if (age >= 18) {\n    console.log('Adult');\n  } else {\n    console.log('Minor');\n  }\n\n  // Using else if for multiple conditions\n  let score = 85;\n  if (score >= 90) {\n    console.log('Grade: A');\n  } else if (score >= 75) {\n    console.log('Grade: B');\n  } else if (score >= 50) {\n    console.log('Grade: C');\n  } else {\n    console.log('Grade: F');\n  }\n</script>"
},
  {
  "title": "JavaScript Switch",
  "note": "Switch statements in JavaScript allow you to execute one block of code among many based on the value of an expression. They are especially useful when checking a single variable against multiple possible values.\n\n- Each `case` specifies a value to match.\n- The `break` statement prevents fall-through to the next case.\n- `default` runs if no case matches.\n- Useful for replacing multiple `if-else` statements for readability.",
  "code": "<script>\n  let day = 'Monday';\n\n  switch(day) {\n    case 'Monday':\n      console.log('Start of the week');\n      break;\n    case 'Wednesday':\n      console.log('Midweek');\n      break;\n    case 'Friday':\n      console.log('Weekend is near');\n      break;\n    default:\n      console.log('Another day');\n  }\n\n  // Example with numbers\n  let grade = 'B';\n  switch(grade) {\n    case 'A':\n      console.log('Excellent');\n      break;\n    case 'B':\n      console.log('Good');\n      break;\n    case 'C':\n      console.log('Average');\n      break;\n    default:\n      console.log('Needs Improvement');\n  }\n</script>"
},
  {
  "title": "JavaScript Loop - For",
  "note": "The `for` loop in JavaScript executes a block of code a specified number of times. It consists of three parts: initialization, condition, and increment/decrement. `for` loops are commonly used when you know beforehand how many times you want to iterate.",
  "code": "<script>\n  // Simple for loop\n  for (let i = 0; i < 5; i++) {\n    console.log('Iteration:', i);\n  }\n\n  // Loop through an array\n  const fruits = ['Apple', 'Banana', 'Cherry'];\n  for (let i = 0; i < fruits.length; i++) {\n    console.log('Fruit:', fruits[i]);\n  }\n\n  // Nested for loop example\n  for (let i = 1; i <= 3; i++) {\n    for (let j = 1; j <= 2; j++) {\n      console.log(`i = ${i}, j = ${j}`);\n    }\n  }\n</script>"
},
  {
  "title": "JavaScript Loop - For...in",
  "note": "The `for...in` loop in JavaScript iterates over the enumerable properties (keys) of an object. It's useful when you need to access both property names and their values in an object.",
  "code": "<script>\n  const obj = { a: 1, b: 2, c: 3 };\n\n  // Iterate over object properties\n  for (let key in obj) {\n    console.log('Property:', key, 'Value:', obj[key]);\n  }\n\n  // Example with a dynamic object\n  const student = {\n    name: 'Alice',\n    age: 20,\n    grade: 'A'\n  };\n\n  for (let prop in student) {\n    console.log(`${prop}: ${student[prop]}`);\n  }\n</script>"
},
  {
  "title": "JavaScript Loop - For...of",
  "note": "The `for...of` loop in JavaScript iterates over iterable objects such as arrays, strings, maps, sets, and more. It provides direct access to the values of the iterable without needing the index, making code cleaner and easier to read.",
  "code": "<script>\n  const arr = [10, 20, 30];\n\n  // Iterate through array values\n  for (let value of arr) {\n    console.log('Value:', value);\n  }\n\n  // Iterate through string characters\n  const name = 'Alice';\n  for (let char of name) {\n    console.log('Character:', char);\n  }\n\n  // Iterate through a Set\n  const numbers = new Set([1, 2, 3]);\n  for (let num of numbers) {\n    console.log('Set number:', num);\n  }\n</script>"
},
  {
  "title": "JavaScript Async/Await",
  "note": "Async/await in JavaScript provides a way to write asynchronous code in a more readable, synchronous-like manner. \n\n- `async` functions always return a promise.\n- `await` pauses the execution of an async function until the promise resolves.\n- It simplifies handling asynchronous operations such as API calls or timers.",
  "code": "<script>\n  // Example: Fetch data from an API\n  async function fetchData() {\n    try {\n      const response = await fetch('https://api.example.com/data');\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      const data = await response.json();\n      console.log('Fetched data:', data);\n    } catch (error) {\n      console.error('Error fetching data:', error);\n    }\n  }\n\n  fetchData();\n\n  // Example: Async function with a delay\n  function delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async function greetAfterDelay() {\n    console.log('Waiting 2 seconds...');\n    await delay(2000);\n    console.log('Hello after 2 seconds!');\n  }\n\n  greetAfterDelay();\n</script>"
}
,
  {
  "title": "JavaScript Errors",
  "note": "Errors in JavaScript indicate that something went wrong during code execution. Handling errors properly ensures that your program can recover or provide meaningful feedback.\n\n- `try` block: Wraps code that may throw an error.\n- `catch` block: Handles the error when it occurs.\n- `finally` block (optional): Executes code regardless of error occurrence.\n- Common error types: `ReferenceError`, `TypeError`, `SyntaxError`, `RangeError`.",
  "code": "<script>\n  // Basic try-catch example\n  try {\n    throw new Error('Something went wrong!');\n  } catch (e) {\n    console.log('Caught error:', e.message);\n  } finally {\n    console.log('This always runs.');\n  }\n\n  // Example: Handling different error types\n  try {\n    let x = y + 5; // ReferenceError because y is not defined\n  } catch (error) {\n    if (error instanceof ReferenceError) {\n      console.log('Reference error occurred:', error.message);\n    } else {\n      console.log('Other error:', error.message);\n    }\n  }\n</script>"
},
  {
  "title": "JavaScript Scope",
  "note": "Scope in JavaScript defines where variables and functions are accessible within your code. Understanding scope helps prevent naming conflicts and unexpected behavior.\n\n- **Global Scope:** Variables declared outside any function or block are accessible everywhere.\n- **Local/Function Scope:** Variables declared inside a function are only accessible within that function.\n- **Block Scope:** Variables declared with `let` or `const` inside `{}` are only accessible within that block.\n- **Lexical Scope:** Inner functions have access to variables from outer functions.",
  "code": "<script>\n  // Global scope\n  let globalVar = 'I am global';\n  console.log(globalVar); // Accessible everywhere\n\n  function testFunction() {\n    // Function (local) scope\n    let localVar = 10;\n    console.log('Inside function:', localVar);\n\n    if(true) {\n      // Block scope\n      let blockVar = 'Inside block';\n      console.log(blockVar);\n    }\n    // console.log(blockVar); // Error: blockVar is not accessible here\n  }\n\n  testFunction();\n  // console.log(localVar); // Error: localVar is not accessible here\n</script>"
},
  {
  "title": "JavaScript Hoisting",
  "note": "Hoisting in JavaScript is the behavior where variable and function declarations are moved to the top of their containing scope during compilation. This allows functions to be called before they are defined and variables to be referenced before declaration (with `var`, they are initialized as `undefined`).\n\n- **Variables:** `var` declarations are hoisted and initialized as `undefined`. `let` and `const` are hoisted but not initialized (Temporal Dead Zone).\n- **Functions:** Function declarations are fully hoisted, meaning you can call them before they appear in the code.\n- **Helps understand why some code works unexpectedly if not careful with scope and initialization.",
  "code": "<script>\n  // Example with var\n  console.log(a); // undefined\n  var a = 5;\n\n  // Example with let/const\n  // console.log(b); // ReferenceError\n  let b = 10;\n\n  // Function hoisting\n  greet(); // Works because function is hoisted\n  function greet() {\n    console.log('Hello!');\n  }\n</script>"
},
 {
  "title": "JavaScript Modules",
  "note": "Modules in JavaScript allow you to organize code into separate files, promoting reusability and maintainability. Modules use `export` to expose functions, objects, or variables, and `import` to bring them into other files.\n\n- **Named Exports:** Export multiple items from a module.\n- **Default Export:** Export a single item as default.\n- **Helps avoid global scope pollution** and keeps code modular.",
  "code": "<script type=\"module\">\n  // module.js\n  export function greet(name) {\n    return `Hello, ${name}!`;\n  }\n  export const PI = 3.14;\n\n  // main.js\n  import { greet, PI } from './module.js';\n  console.log(greet('Alice'));\n  console.log('Value of PI:', PI);\n\n  // Default export example\n  // export default function sayHi() { return 'Hi!'; }\n  // import sayHi from './module.js';\n  // console.log(sayHi());\n</script>"
},
  {
  "title": "JavaScript Classes",
  "note": "Classes in JavaScript are blueprints for creating objects. They support object-oriented principles like encapsulation, inheritance, and methods. Classes provide a clearer syntax over traditional constructor functions.\n\n- **Constructor:** Initializes object properties.\n- **Methods:** Functions defined inside classes.\n- **Inheritance:** Use `extends` to create a subclass and `super()` to call the parent constructor.",
  "code": "<script>\n  // Define a class\n  class Person {\n    constructor(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n\n    greet() {\n      console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);\n    }\n  }\n\n  // Create an instance\n  const alice = new Person('Alice', 25);\n  alice.greet();\n\n  // Inheritance example\n  class Student extends Person {\n    constructor(name, age, grade) {\n      super(name, age);\n      this.grade = grade;\n    }\n    study() {\n      console.log(`${this.name} is studying in grade ${this.grade}.`);\n    }\n  }\n\n  const bob = new Student('Bob', 20, 'A');\n  bob.greet();\n  bob.study();\n</script>"
},
  {
  "title": "JavaScript Sets",
  "note": "Sets are collections of unique values in JavaScript. They automatically remove duplicates and provide useful methods for adding, deleting, and checking values.\n\n- **Unique values:** No duplicates allowed.\n- **Methods:** `add()`, `delete()`, `has()`, `clear()`.\n- **Iteration:** Sets are iterable using `for...of` loops or `forEach`.\n- **Useful for:** Removing duplicates from arrays, storing distinct elements.",
  "code": "<script>\n  // Create a Set\n  const mySet = new Set([1, 2, 3, 3, 4]);\n  console.log(mySet); // Set {1, 2, 3, 4}\n\n  // Add and delete elements\n  mySet.add(5);\n  mySet.delete(2);\n  console.log(mySet.has(3)); // true\n\n  // Iterate over a Set\n  for (let value of mySet) {\n    console.log(value);\n  }\n\n  // Convert Set to Array\n  const uniqueArray = [...mySet];\n  console.log(uniqueArray);\n</script>"
},
  {
  "title": "JavaScript Maps",
  "note": "Maps are collections of key-value pairs in JavaScript. Unlike plain objects, Map keys can be of any type, and the insertion order is preserved.\n\n- **Methods:** `set(key, value)`, `get(key)`, `has(key)`, `delete(key)`, `clear()`.\n- **Iteration:** Maps can be iterated using `for...of` loops or `forEach`.\n- **Useful for:** Storing associations where key types are not restricted to strings or symbols.",
  "code": "<script>\n  // Create a Map\n  const myMap = new Map();\n  myMap.set('name', 'Alice');\n  myMap.set(42, 'The answer');\n  myMap.set(true, 'Yes');\n\n  // Access values\n  console.log(myMap.get('name')); // Alice\n  console.log(myMap.get(42)); // The answer\n\n  // Check key existence\n  console.log(myMap.has(true)); // true\n\n  // Iterate over Map\n  for (let [key, value] of myMap) {\n    console.log(key, value);\n  }\n\n  // Map size\n  console.log(myMap.size);\n</script>"
}
,
  {
  "title": "JavaScript RegExp",
  "note": "Regular expressions (RegExp) in JavaScript are patterns used to match character sequences in strings. They are useful for validation, searching, and text manipulation.\n\n- **Syntax:** `/pattern/flags` or `new RegExp('pattern', 'flags')`\n- **Common flags:** `i` (ignore case), `g` (global), `m` (multiline)\n- **Methods:** `test()`, `exec()`, `match()`, `replace()`, `search()`",
  "code": "<script>\n  // Create a RegExp\n  const regex = /hello/i;\n  const str1 = 'Hello world';\n  const str2 = 'Hi there';\n\n  // Test for a match\n  console.log(regex.test(str1)); // true\n  console.log(regex.test(str2)); // false\n\n  // Using exec\n  const result = regex.exec(str1);\n  console.log(result[0]); // Hello\n\n  // Replace text using RegExp\n  const newStr = str1.replace(regex, 'Hi');\n  console.log(newStr); // Hi world\n</script>"
},
  {
  "title": "JavaScript Typed Arrays",
  "note": "Typed Arrays in JavaScript provide a way to work with binary data efficiently. They offer array-like views over an ArrayBuffer, allowing manipulation of raw binary data in different numeric types.\n\n- **ArrayBuffer:** Represents a generic, fixed-length raw binary data buffer.\n- **Views:** Typed arrays like `Int8Array`, `Uint8Array`, `Int16Array`, `Float32Array` interpret the buffer.\n- **Use cases:** WebGL, file processing, and performance-critical operations.",
  "code": "<script>\n  // Create a buffer of 16 bytes\n  const buffer = new ArrayBuffer(16);\n\n  // Create a typed array view (4 integers of 32-bit)\n  const int32View = new Int32Array(buffer);\n\n  // Assign values\n  int32View[0] = 42;\n  int32View[1] = 100;\n\n  console.log(int32View); // Int32Array [42, 100, 0, 0]\n  console.log(buffer.byteLength); // 16\n</script>"
},
  {
  "title": "JavaScript Callbacks",
  "note": "Callbacks are functions passed as arguments to other functions to be executed later. They are commonly used for handling asynchronous operations, like API calls or event handling.\n\n- **Synchronous callbacks:** Executed immediately within the calling function.\n- **Asynchronous callbacks:** Executed after an operation completes, such as reading a file or fetching data.\n- **Use cases:** Event listeners, timers, AJAX requests.",
  "code": "<script>\n  // Synchronous callback example\n  function greet(name, callback) {\n    callback('Hello ' + name);\n  }\n  greet('John', console.log); // Hello John\n\n  // Asynchronous callback example\n  function fetchData(callback) {\n    setTimeout(() => {\n      callback('Data received');\n    }, 1000);\n  }\n  fetchData(console.log); // Data received (after 1 second)\n</script>"
},
  {
  "title": "JavaScript Promises",
  "note": "Promises in JavaScript are objects representing the eventual completion or failure of asynchronous operations. They help manage asynchronous code more cleanly than nested callbacks.\n\n- **States:** `pending`, `fulfilled`, `rejected`.\n- **Methods:** `then()` for success, `catch()` for errors, `finally()` for cleanup.\n- **Use cases:** API calls, timers, or any async operations.",
  "code": "<script>\n  // Create a Promise\n  const promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const success = true;\n      if(success) {\n        resolve('Operation completed successfully');\n      } else {\n        reject('Operation failed');\n      }\n    }, 1000);\n  });\n\n  // Handling the Promise\n  promise\n    .then(result => console.log(result)) // Success handler\n    .catch(error => console.error(error)) // Error handler\n    .finally(() => console.log('Promise settled')); // Cleanup\n</script>"
},
  {
  "title": "JavaScript Fetch API",
  "note": "The Fetch API provides a modern interface for making HTTP requests in JavaScript. It returns Promises, allowing asynchronous handling of network responses.\n\n- **Basic usage:** Use `fetch()` with a URL and handle the response using `.then()` or `async/await`.\n- **Methods:** GET, POST, PUT, DELETE, etc.\n- **Use cases:** Retrieving JSON data from APIs, sending form data, or interacting with servers.",
  "code": "<script>\n  // Using fetch with Promises\n  fetch('https://api.example.com/data')\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.json();\n    })\n    .then(data => console.log(data))\n    .catch(error => console.error('Fetch error:', error));\n\n  // Using fetch with async/await\n  async function getData() {\n    try {\n      const response = await fetch('https://api.example.com/data');\n      const data = await response.json();\n      console.log(data);\n    } catch (error) {\n      console.error('Fetch error:', error);\n    }\n  }\n  getData();\n</script>"
},
  {
  "title": "JavaScript JSON",
  "note": "JSON (JavaScript Object Notation) is a lightweight data-interchange format used to represent objects and arrays as strings. It enables easy exchange of data between client and server.\n\n- **Converting objects to JSON:** `JSON.stringify()`\n- **Parsing JSON strings to objects:** `JSON.parse()`\n- **Use cases:** API communication, configuration files, storing structured data.",
  "code": "<script>\n  // JavaScript object\n  const obj = { name: 'John', age: 30, hobbies: ['reading', 'coding'] };\n\n  // Convert object to JSON string\n  const jsonString = JSON.stringify(obj);\n  console.log(jsonString); // '{\"name\":\"John\",\"age\":30,\"hobbies\":[\"reading\",\"coding\"]}'\n\n  // Convert JSON string back to object\n  const parsedObj = JSON.parse(jsonString);\n  console.log(parsedObj.name); // John\n</script>"
},
  {
  "title": "JavaScript DOM Manipulation",
  "note": "The Document Object Model (DOM) represents HTML elements as objects. JavaScript can access, modify, or remove elements, attributes, and styles dynamically to create interactive web pages.\n\n- **Selecting elements:** `getElementById`, `querySelector`, `getElementsByClassName`.\n- **Modifying content:** `innerText`, `innerHTML`, `textContent`.\n- **Changing styles:** `element.style.property`\n- **Adding/removing elements:** `appendChild`, `removeChild`.\n- **Use cases:** Dynamic content updates, interactive UI, form validation.",
  "code": "<script>\n  // Change text of an element\n  document.getElementById('demo').innerText = 'Hello World!';\n\n  // Change style of an element\n  document.getElementById('demo').style.color = 'blue';\n\n  // Create a new element and append it\n  const newDiv = document.createElement('div');\n  newDiv.innerText = 'I am a new div';\n  document.body.appendChild(newDiv);\n</script>"
},
  {
  "title": "JavaScript Event Listeners",
  "note": "Event listeners allow JavaScript to respond to user interactions like clicks, inputs, or key presses. They attach functions to elements that execute when specified events occur.\n\n- **Common events:** `click`, `mouseover`, `keydown`, `submit`.\n- **Methods:** `addEventListener(event, function)` to attach, `removeEventListener` to detach.\n- **Use cases:** Buttons, forms, interactive UI components.",
  "code": "<script>\n  // Select the button element\n  const button = document.getElementById('btn');\n\n  // Attach a click event listener\n  button.addEventListener('click', () => {\n    alert('Button clicked!');\n    button.style.backgroundColor = 'lightgreen';\n  });\n\n  // Attach mouseover event listener\n  button.addEventListener('mouseover', () => {\n    button.style.cursor = 'pointer';\n  });\n</script>"
},
  {
  "title": "JavaScript Local Storage",
  "note": "Local Storage provides a way to store key-value pairs in the browser persistently. Data stored remains even after page reloads or browser restarts, unlike session storage which lasts only for the session.\n\n- **Storing data:** `localStorage.setItem(key, value)`\n- **Retrieving data:** `localStorage.getItem(key)`\n- **Removing data:** `localStorage.removeItem(key)`\n- **Clearing all data:** `localStorage.clear()`\n- **Use cases:** Saving user preferences, caching data locally, simple offline storage.",
  "code": "<script>\n  // Store data\n  localStorage.setItem('name', 'Alice');\n  localStorage.setItem('theme', 'dark');\n\n  // Retrieve data\n  console.log(localStorage.getItem('name')); // Alice\n  console.log(localStorage.getItem('theme')); // dark\n\n  // Remove a specific item\n  localStorage.removeItem('theme');\n\n  // Clear all local storage\n  // localStorage.clear();\n</script>"
}
],
  react : [
  {
  "title": "React Tutorial",
  "note": "React is a popular JavaScript library for building dynamic and interactive user interfaces. It uses components, JSX syntax, and a virtual DOM to efficiently update UI based on data changes.\n\n- **Components:** Reusable UI building blocks.\n- **JSX:** JavaScript syntax extension to write HTML-like code in JS.\n- **Props:** Pass data to components.\n- **State:** Manage component-specific data.\n- **Use cases:** Single-page applications, interactive forms, dynamic dashboards.",
  "code": "// Example React component using JSX\nimport React from 'react';\n\nfunction Greeting(props) {\n  return <h1>Hello, {props.name}!</h1>;\n}\n\nexport default Greeting;\n\n// Usage in App.js\n// <Greeting name=\"Alice\" />"
}
,
  {
  "title": "React Home",
  "note": "React Home serves as the central hub for React documentation, tutorials, and resources. It's the official starting point to learn React concepts, best practices, and explore examples provided by the React team.\n\n- **Official website:** https://reactjs.org\n- **Resources available:** Documentation, tutorial projects, blog posts, community links.\n- **Use cases:** Reference for learning React, checking updates, exploring API details.",
  "code": "// Visit the official React website for guides and examples\n// https://reactjs.org"
},
  {
  "title": "React Intro",
  "note": "React is a declarative JavaScript library used to build interactive and reusable UI components. It helps developers efficiently update and render elements when data changes using a virtual DOM.\n\n- **Components:** Core building blocks of UI.\n- **JSX:** Syntax for writing HTML in JavaScript.\n- **Props:** Pass data from parent to child components.\n- **State:** Manage dynamic data within components.\n- **Use cases:** Single-page applications, dynamic dashboards, interactive forms.",
  "code": "import React from 'react';\n\nconst App = () => {\n  return <h1>Hello, React!</h1>;\n};\n\nexport default App;"
},
  {
  "title": "React Get Started",
  "note": "Get started with React by setting up a development environment. You can use tools like Create React App to bootstrap projects quickly, or configure custom setups with Webpack, Babel, or Vite.\n\n- **Steps to start:**\n  1. Install Node.js and npm.\n  2. Create a new React app using `npx create-react-app my-app`.\n  3. Navigate to your project directory with `cd my-app`.\n  4. Start the development server using `npm start`.\n- **Use cases:** Quickly launch projects, experiment with components, and build React applications efficiently.",
  "code": "// Create a new React project\nnpx create-react-app my-app\ncd my-app\nnpm start"
}
,
  {
  "title": "React Upgrade",
  "note": "Upgrading React ensures your project uses the latest features, improvements, and security patches. It’s important to also update related dependencies like `react-dom` and test your application after upgrading.\n\n- **Upgrade steps:**\n  1. Check your current React version.\n  2. Update React and React DOM to the latest version using npm.\n  3. Verify compatibility with other packages.\n  4. Test your app thoroughly.\n- **Command:** `npm install react@latest react-dom@latest`",
  "code": "npm install react@latest react-dom@latest"
}
,
 {
  "title": "React ES6",
  "note": "React leverages modern ES6 (ECMAScript 2015) features to simplify code and improve readability.\n\n- **Classes:** Define components with `class` syntax.\n- **Arrow functions:** Concise function syntax and lexical `this` binding.\n- **Modules:** Organize code with `import` and `export`.\n- **Benefits:** Cleaner code, better structure, easier maintenance.",
  "code": "class MyComponent extends React.Component {\n  render() {\n    return <div>Hello ES6!</div>;\n  }\n}"
}
,
  {
  "title": "React Render HTML",
  "note": "Rendering HTML in React is done through JSX, which allows writing HTML-like syntax in JavaScript.\n\n- **Steps:**\n  1. Create a JSX element.\n  2. Render it to the DOM using `ReactDOM.render()`.\n- **Benefits:** Dynamically update content and easily integrate JS logic within HTML structure.",
  "code": "const element = <h1>Hello, world!</h1>;\nReactDOM.render(element, document.getElementById('root'));"
}
,
  {
  "title": "React JSX",
  "note": "JSX (JavaScript XML) allows writing HTML-like code directly within JavaScript, making React code more readable and expressive.\n\n- **Features:**\n  - Supports embedding expressions with `{}`.\n  - Can include JavaScript logic and function calls.\n  - Supports attributes like `className` instead of `class`.\n- **Use case:** Build interactive UIs with declarative syntax.",
  "code": "const jsx = <div className=\"container\">Welcome to JSX!</div>;"
}
,
  {
  "title": "React Components",
  "note": "React components are the fundamental building blocks of any React application. They allow you to break the UI into independent, reusable pieces, which can manage their own state and logic. There are two main types of components: \n\n1. **Functional Components**: These are simple JavaScript functions that accept `props` as input and return JSX to render UI. They are lightweight and can use React Hooks to manage state and side effects.\n\n2. **Class Components**: These are ES6 classes that extend `React.Component`. They can hold local state, utilize lifecycle methods (like componentDidMount and componentWillUnmount), and provide more advanced functionality.\n\nComponents help in building modular, maintainable, and reusable code. They can communicate with each other via props and state, enabling dynamic and interactive UIs. Using components efficiently leads to better separation of concerns and easier testing.",
  "code": "function Greeting(props) {\n  return (\n    <div>\n      <h2>Hello from Component!</h2>\n      <p>Welcome, {props.name}!</p>\n    </div>\n  );\n}\n\n// Usage example:\n<Greeting name=\"Alice\" />"
}
,
  {
  "title": "React Class",
  "note": "Class components in React are ES6 classes that extend from `React.Component`. They allow developers to manage local state, handle events, and use lifecycle methods to perform actions at different points in a component's life. Class components are particularly useful when you need more control over state and need to respond to component mounting, updating, or unmounting.\n\nKey features of class components:\n1. **State Management**: Use `this.state` to store local data that can change over time.\n2. **Lifecycle Methods**: Methods like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` allow you to run code at specific points.\n3. **Event Handling**: Methods inside the class can handle user events like clicks or form submissions.\n4. **Props Access**: Props are accessible using `this.props` and allow passing data from parent to child components.\n\nAlthough functional components with hooks are now preferred for most new React projects, understanding class components is important for maintaining legacy code and for deeper understanding of React's core concepts.",
  "code": "class Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { time: new Date() };\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(() => this.tick(), 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({ time: new Date() });\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Current Time:</h2>\n        <p>{this.state.time.toLocaleTimeString()}</p>\n      </div>\n    );\n  }\n}\n\n// Usage example:\n<Clock />"
},
{
  "title": "React Props",
  "note": "Props (short for properties) are a way to pass data from a parent component to a child component in React. They are read-only and cannot be modified by the child component. Props allow components to be reusable and configurable, enabling dynamic rendering of content based on the input data.\n\nKey points about props:\n1. **Data Flow**: Props follow a unidirectional flow from parent to child.\n2. **Immutability**: Props are read-only inside the child component.\n3. **Reusability**: By passing different props, the same component can render different outputs.\n4. **Default Props**: You can provide default values for props using `defaultProps`.\n5. **Prop Types**: Use `PropTypes` to validate the types of props for better error handling.\n\nExample use cases include passing user names, configuration settings, or callback functions to child components.",
  "code": "function Welcome(props) {\n  return <h1>Hello, {props.name}!</h1>;\n}\n\n// Using the component\n<Welcome name=\"Alice\" />\n<Welcome name=\"Bob\" />\n\n// Default props example\nWelcome.defaultProps = { name: 'Guest' };"
},
  {
  "title": "React Events",
  "note": "React provides a synthetic event system that wraps native browser events to ensure consistent behavior across different browsers. Event handlers in React use camelCase naming (e.g., `onClick`, `onChange`) and are passed as functions rather than strings. Events can be used to handle user interactions like clicks, form submissions, keyboard input, and more.\n\nKey points about React events:\n1. **CamelCase Syntax**: Use `onClick` instead of `onclick`.\n2. **Event Handler Functions**: Pass a function reference or arrow function.\n3. **Synthetic Events**: React wraps native events for cross-browser compatibility.\n4. **Prevent Default Behavior**: Use `event.preventDefault()` inside handlers.\n5. **Passing Arguments**: You can pass additional arguments to event handlers using arrow functions.\n\nExample use cases include handling button clicks, form input changes, or mouse movements.",
  "code": "<button onClick={() => alert('Clicked!')}>Click Me</button>\n\n// Example with arguments\nfunction handleClick(name) {\n  alert('Hello, ' + name);\n}\n<button onClick={() => handleClick('Alice')}>Greet Alice</button>"
},
  {
  "title": "React Conditionals",
  "note": "In React, you can render different UI elements or components based on certain conditions. Conditional rendering allows your application to display dynamic content depending on the state or props. You can use JavaScript `if/else` statements, ternary operators, logical && operators, or switch cases inside JSX to achieve this.\n\nKey approaches:\n1. **Ternary Operator**: `{condition ? <ComponentA /> : <ComponentB />}`\n2. **Logical AND**: `{condition && <Component />}` (renders only if condition is true)\n3. **If/Else Outside JSX**: Define variables with conditional content before returning JSX.\n4. **Switch Statements**: For multiple conditions, you can use switch logic outside JSX.\n\nThis approach helps create responsive and interactive UIs that adapt to the application's state or user actions.",
  "code": "{isLoggedIn ? <Dashboard /> : <Login />}\n\n// Using logical AND\n{hasNotifications && <NotificationList />}\n\n// If/Else outside JSX\nlet content;\nif (isLoggedIn) {\n  content = <Dashboard />;\n} else {\n  content = <Login />;\n}\nreturn <div>{content}</div>;"
},
  {
  "title": "React Lists",
  "note": "In React, lists are used to render multiple elements dynamically from arrays or data sets. The `map()` function is commonly used to iterate over an array and return JSX elements. Each list item should have a unique `key` prop to help React identify which items have changed, added, or removed, improving rendering performance and avoiding UI bugs.\n\nTips for working with lists:\n1. **Unique Keys**: Always provide unique keys, ideally from stable identifiers like IDs.\n2. **Dynamic Rendering**: Use `map()` to render arrays of objects.\n3. **Conditional Rendering**: Combine with conditional logic to display items selectively.\n4. **Fragments**: Use `React.Fragment` or `<>...</>` when returning multiple elements from a list without extra wrapper nodes.\n\nExample: Rendering a list of user names dynamically helps create interactive and scalable components in React.",
  "code": "{items.map(item => <li key={item.id}>{item.name}</li>)}\n\n// Example with fragment\n<ul>\n  {users.map(user => (\n    <React.Fragment key={user.id}>\n      <li>{user.name}</li>\n    </React.Fragment>\n  ))}\n</ul>"
},

  {
  "title": "React Forms",
  "note": "In React, forms can be handled using controlled components, where form input values are synced with component state. This allows React to fully control the form data, making it easier to validate, modify, or submit values. Controlled components are created by setting the `value` prop of input elements to a state variable and updating the state via `onChange` handlers.\n\nKey points:\n1. **State Management**: Each input is tied to state with `useState`.\n2. **onChange Handling**: Updates state whenever the user types.\n3. **Validation**: You can validate input values before submission.\n4. **Form Submission**: State can be submitted to APIs or used to trigger actions.\n5. **Reusable Components**: Encapsulate inputs in reusable components for better maintainability.\n\nExample: Creating a controlled text input that updates its value dynamically as the user types.",
  "code": "const [value, setValue] = React.useState('');\n\nfunction handleChange(event) {\n  setValue(event.target.value);\n}\n\nreturn (\n  <form onSubmit={e => { e.preventDefault(); console.log(value); }}>\n    <input type=\"text\" value={value} onChange={handleChange} placeholder=\"Enter text\" />\n    <button type=\"submit\">Submit</button>\n  </form>\n);"
},

  {
  "title": "React Router",
  "note": "React Router is a powerful library for handling navigation and routing in React applications. It allows you to create single-page applications (SPAs) where different components are rendered based on the URL without refreshing the page.\n\nKey points:\n1. **BrowserRouter**: Wraps the app and enables routing functionality.\n2. **Route**: Defines a path and the component to render when the path matches.\n3. **Switch**: Renders only the first matching route among its children.\n4. **Link & NavLink**: Used to navigate between routes without reloading the page.\n5. **Dynamic Routing**: Supports URL parameters, nested routes, and conditional rendering based on routes.\n\nExample: A basic setup with two routes for Home and About pages.",
  "code": "import { BrowserRouter as Router, Route, Routes, Link } from 'react-router-dom';\n\nfunction Home() {\n  return <h2>Home Page</h2>;\n}\n\nfunction About() {\n  return <h2>About Page</h2>;\n}\n\nfunction App() {\n  return (\n    <Router>\n      <nav>\n        <Link to=\"/\">Home</Link> | <Link to=\"/about\">About</Link>\n      </nav>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n      </Routes>\n    </Router>\n  );\n}\n\nexport default App;"
},

  {
  "title": "React Memo",
  "note": "React.memo is a higher-order component (HOC) used to optimize functional components by memoizing their rendered output. It prevents a component from re-rendering if its props have not changed. This is useful for improving performance in large applications with frequent re-renders.\n\nKey points:\n1. **Pure Components**: React.memo works like React.PureComponent but for functional components.\n2. **Props Comparison**: By default, it does a shallow comparison of props.\n3. **Custom Comparison**: You can pass a custom comparison function to control when re-renders occur.\n\nExample: A counter component that only re-renders when its props change, even if the parent re-renders frequently.",
  "code": "import React, { useState } from 'react';\n\nconst MyComponent = React.memo(function MyComponent({ value }) {\n  console.log('Rendering MyComponent');\n  return <div>{value}</div>;\n});\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [other, setOther] = useState(0);\n\n  return (\n    <div>\n      <MyComponent value={count} />\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <button onClick={() => setOther(other + 1)}>Change Other</button>\n    </div>\n  );\n}\n\nexport default App;"
},
  {
  "title": "React CSS Styling",
  "note": "In React, components can be styled using **CSS classes**, **inline styles**, or **CSS modules**.\n\n1. **CSS Classes**: Use `className` instead of `class` to apply standard CSS styles.\n2. **Inline Styles**: Pass a JavaScript object to the `style` prop, using camelCase property names.\n3. **CSS Modules**: Import CSS as a module to scope styles locally to components, preventing global conflicts.\n\nExample usage:\n- Using CSS classes for global styling.\n- Using inline styles for dynamic styling based on state.\n- Using CSS modules for component-scoped styles.",
  "code": "// Using CSS class\n<div className=\"container\">Styled Text</div>\n\n// Inline styling with JavaScript object\n<div style={{ color: 'blue', fontSize: '18px' }}>Inline Styled Text</div>\n\n// Using CSS Modules (MyComponent.module.css)\n// .container { color: red; }\nimport styles from './MyComponent.module.css';\n<div className={styles.container}>Module Styled Text</div>"
},
  {
  "title": "React Sass Styling",
  "note": "Sass (Syntactically Awesome Stylesheets) is a CSS preprocessor that adds features like **variables, nested rules, mixins, and functions**. In React, Sass can make styling more maintainable and organized.\n\n1. **Variables**: Store reusable values for colors, fonts, etc.\n2. **Nesting**: Write nested CSS rules to mirror HTML structure.\n3. **Mixins**: Create reusable chunks of CSS.\n4. **Partials & Imports**: Split styles into multiple files and import them.\n\nUsing Sass in React helps you manage complex styles efficiently, especially in larger projects.",
  "code": "// Install Sass in your React project\nnpm install sass\n\n// Import your Sass file in a React component\nimport './styles.scss';\n\n// Example styles.scss\n$primary-color: #3498db;\n.container {\n  background-color: $primary-color;\n  padding: 20px;\n  .title {\n    font-size: 24px;\n    color: white;\n  }\n}\n\n// Usage in React\nfunction App() {\n  return (\n    <div className=\"container\">\n      <h1 className=\"title\">Hello Sass!</h1>\n    </div>\n  );\n}"
},
  {
  "title": "React Hooks",
  "note": "Hooks are functions that let you 'hook into' React state and lifecycle features in functional components without using classes.\n\n**Key Points:**\n1. **useState**: Add state to functional components.\n2. **useEffect**: Perform side effects like data fetching, subscriptions, or DOM updates.\n3. **useContext**: Access context values without prop drilling.\n4. **useRef**: Reference DOM elements or store mutable values.\n5. **useReducer**: Manage complex state logic, similar to Redux reducers.\n6. **Custom Hooks**: Reuse logic across multiple components.\n\nHooks simplify React code, improve readability, and allow functional components to be more powerful and flexible.",
  "code": "// Example: Using useState in a functional component\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => setCount(count + 1);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;"
},
  {
  "title": "What is a Hook?",
  "note": "Hooks are special functions introduced in React 16.8 that allow functional components to use React features such as state management, lifecycle methods, context, and more without converting them into class components.\n\n**Key Hooks:**\n1. **useState** – Adds state to functional components.\n2. **useEffect** – Handles side effects like data fetching, subscriptions, or DOM manipulation.\n3. **useContext** – Accesses context data without prop drilling.\n4. **useReducer** – Manages complex state logic.\n5. **useRef** – References DOM elements or stores mutable values.\n\nHooks promote cleaner, more reusable, and readable React code, enabling functional components to do what only class components could do before.",
  "code": "// Example: Using useState hook in a functional component\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => setCount(count + 1);\n\n  return (\n    <div>\n      <p>Current count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;"
},
{
  "title": "useState",
  "note": "The `useState` hook is used to add and manage state in functional React components. It returns a state variable and a function to update that state. Each call to `useState` creates a separate piece of state.\n\n**Key Points:**\n1. `useState` accepts an initial value.\n2. The setter function updates the state and triggers a re-render.\n3. Multiple `useState` hooks can be used for different state variables.\n\n**Example Use Cases:**\n- Tracking input field values.\n- Counting clicks or user interactions.\n- Toggling visibility of UI elements.",
  "code": "// Example: Using useState hook in a functional component\nimport React, { useState } from 'react';\n\nfunction NameInput() {\n  const [name, setName] = useState('');\n\n  const handleChange = (e) => setName(e.target.value);\n\n  return (\n    <div>\n      <input type=\"text\" value={name} onChange={handleChange} placeholder=\"Enter your name\" />\n      <p>Hello, {name}!</p>\n    </div>\n  );\n}\n\nexport default NameInput;"
},
  {
  "title": "useEffect",
  "note": "The `useEffect` hook lets you perform side effects in functional React components. Side effects include tasks like fetching data, manually updating the DOM, setting up subscriptions, or timers.\n\n**Key Points:**\n1. Runs after the component renders.\n2. Dependencies array controls when the effect runs:\n   - Empty array `[]` → runs once after initial render.\n   - No array → runs after every render.\n   - Specific variables `[var1, var2]` → runs when those variables change.\n3. Can return a cleanup function to cancel subscriptions or timers.\n\n**Example Use Cases:**\n- Updating the document title.\n- Fetching API data on mount.\n- Setting up event listeners or intervals.",
  "code": "// Example: Using useEffect hook in a functional component\nimport React, { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `Count: ${count}`;\n    // Optional cleanup function\n    return () => console.log('Cleanup if needed');\n  }, [count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;"
},
{
  "title": "useContext",
  "note": "The `useContext` hook allows functional components to access values from a React Context without having to pass props manually at every level (avoiding 'prop drilling').\n\n**Key Points:**\n1. Requires a Context object created via `React.createContext()`.\n2. Provides the current context value directly.\n3. Updates automatically when the provider's value changes.\n\n**Example Use Cases:**\n- Accessing global theme settings.\n- Sharing authentication state across components.\n- Passing configuration or language settings.",
  "code": "// Example: Using useContext in a functional component\nimport React, { useContext } from 'react';\n\nconst ThemeContext = React.createContext('light');\n\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return <button style={{ background: theme === 'dark' ? '#333' : '#fff', color: theme === 'dark' ? '#fff' : '#000' }}>Click Me</button>;\n}\n\nexport default ThemedButton;"
},
  {
  "title": "useRef",
  "note": "The `useRef` hook provides a way to persist values across renders without causing re-renders. It can also hold references to DOM elements for direct manipulation.\n\n**Key Points:**\n1. Returns a mutable ref object with a `current` property.\n2. Updating `.current` does not trigger a re-render.\n3. Commonly used for accessing DOM nodes, storing timers, or keeping previous state values.\n\n**Example Use Cases:**\n- Focusing input fields programmatically.\n- Storing intervals or timeouts.\n- Keeping track of previous prop or state values.",
  "code": "// Example: Using useRef to access a DOM element\nimport React, { useRef } from 'react';\n\nfunction FocusInput() {\n  const inputRef = useRef(null);\n\n  const handleFocus = () => {\n    inputRef.current.focus(); // Focuses the input field\n  };\n\n  return (\n    <div>\n      <input ref={inputRef} placeholder=\"Type here...\" />\n      <button onClick={handleFocus}>Focus Input</button>\n    </div>\n  );\n}\n\nexport default FocusInput;"
},
{
  "title": "useReducer",
  "note": "The `useReducer` hook is an alternative to `useState` for managing complex state logic in functional components. It is particularly useful when state updates depend on previous state or when multiple state variables are interconnected.\n\n**Key Points:**\n1. Takes a `reducer` function and an `initialState`.\n2. Returns the current `state` and a `dispatch` function to send actions.\n3. Encourages predictable state transitions similar to Redux.\n\n**Example Use Cases:**\n- Managing form state with multiple fields.\n- Handling complex UI state transitions.\n- Implementing counters, toggles, or lists with structured actions.",
  "code": "// Example: Using useReducer for a counter\nimport React, { useReducer } from 'react';\n\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch(action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      return state;\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>\n    </div>\n  );\n}\n\nexport default Counter;"
},
  {
  "title": "useCallback",
  "note": "The `useCallback` hook memoizes a callback function, returning the same function instance between renders unless its dependencies change. This helps prevent unnecessary re-creations of functions, which is useful when passing callbacks to child components that rely on reference equality (like `React.memo`).\n\n**Key Points:**\n1. Accepts a function and a dependency array.\n2. Returns a memoized version of the function.\n3. Helps optimize performance for expensive or frequently re-rendered components.\n\n**Example Use Cases:**\n- Passing stable callbacks to memoized child components.\n- Avoiding unnecessary effects when a callback is used as a dependency.\n- Optimizing event handlers in large lists or components.",
  "code": "// Example: Memoizing a callback to avoid unnecessary renders\nimport React, { useState, useCallback } from 'react';\n\nfunction Child({ onClick }) {\n  console.log('Child rendered');\n  return <button onClick={onClick}>Click Me</button>;\n}\n\nconst MemoizedChild = React.memo(Child);\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  const memoizedCallback = useCallback(() => {\n    console.log('Button clicked');\n  }, []); // Function stays the same unless dependencies change\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <MemoizedChild onClick={memoizedCallback} />\n    </div>\n  );\n}\n\nexport default Parent;"
},
  {
  "title": "useMemo",
  "note": "The `useMemo` hook memoizes the result of an expensive calculation, recomputing it only when its dependencies change. This improves performance by avoiding unnecessary recalculations on every render.\n\n**Key Points:**\n1. Accepts a function and a dependency array.\n2. Returns a memoized value.\n3. Useful for expensive computations or derived data.\n4. Helps prevent unnecessary recalculations when component re-renders.\n\n**Example Use Cases:**\n- Calculating filtered or sorted lists from large datasets.\n- Computing derived values that depend on multiple state variables.\n- Avoiding re-rendering of expensive child components by passing memoized values.",
  "code": "// Example: Memoizing an expensive computation\nimport React, { useState, useMemo } from 'react';\n\nfunction computeExpensiveValue(a, b) {\n  console.log('Computing...');\n  return a + b; // Simulate expensive calculation\n}\n\nfunction App() {\n  const [a, setA] = useState(1);\n  const [b, setB] = useState(2);\n\n  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n\n  return (\n    <div>\n      <p>Result: {memoizedValue}</p>\n      <button onClick={() => setA(a + 1)}>Increment A</button>\n      <button onClick={() => setB(b + 1)}>Increment B</button>\n    </div>\n  );\n}\n\nexport default App;"
},
  {
  "title": "Custom Hooks",
  "note": "Custom hooks are reusable functions that allow you to extract and share logic across multiple components in React. They follow the `use` naming convention and can use built-in hooks like `useState`, `useEffect`, `useContext`, etc.\n\n**Key Points:**\n1. Start with `use` to follow React conventions.\n2. Can encapsulate stateful logic, side effects, or any reusable behavior.\n3. Promote code reusability and cleaner components.\n4. Can return any value: objects, arrays, functions, or primitives.\n\n**Example Use Cases:**\n- Fetching data from APIs.\n- Managing form input state.\n- Sharing timer or interval logic between components.",
  "code": "// Example: Custom hook for fetching data\nimport { useState, useEffect } from 'react';\n\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    fetch(url)\n      .then(response => response.json())\n      .then(json => {\n        setData(json);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return { data, loading };\n}\n\n// Usage in a component\nfunction App() {\n  const { data, loading } = useFetch('https://api.example.com/items');\n\n  if (loading) return <p>Loading...</p>;\n  return (\n    <ul>\n      {data.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  );\n}\n\nexport default App;"
},
  {
  "title": "React Exercises",
  "note": "Practicing React through exercises helps you solidify your understanding of components, hooks, state management, routing, and other React concepts.\n\n**Suggested Exercises:**\n1. Create a `Counter` component using `useState` to increment/decrement values.\n2. Build a `Todo List` with add, remove, and complete functionality.\n3. Implement a `Theme Switcher` using `useContext` to manage light/dark mode.\n4. Create a `Fetch Data` component using `useEffect` to load API data.\n5. Build a `Form` component with controlled inputs using `useState`.\n6. Practice conditional rendering, lists, and event handling in small components.\n7. Try combining multiple hooks (`useState`, `useEffect`, `useReducer`) in one component.\n\n**Benefits:**\n- Strengthens understanding of React fundamentals.\n- Encourages building real-world components.\n- Improves problem-solving and debugging skills.",
  "code": "// Example Exercise: Counter Component\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <h2>Count: {count}</h2>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={() => setCount(count - 1)}>Decrement</button>\n    </div>\n  );\n}\n\nexport default Counter;"
},
{
  "title": "React Compiler",
  "note": "React applications use a compilation step to convert JSX and modern JavaScript into browser-compatible code.\n\n**Key Tools:**\n1. **Babel**: Transpiles JSX and ES6+ syntax into plain JavaScript that browsers can understand.\n2. **Webpack**: Bundles JavaScript modules, CSS, images, and other assets into a single or multiple files for efficient loading.\n\n**How It Works:**\n- JSX code written in components is not valid JavaScript for browsers.\n- Babel converts JSX to `React.createElement` calls.\n- Webpack bundles the transpiled code, optimizing for performance, code splitting, and caching.\n\n**Benefits:**\n- Ensures cross-browser compatibility.\n- Enables modern JavaScript features.\n- Supports modular code and asset management.",
  "code": "// Example: Using Babel and Webpack\n// Babel transpiles JSX\nconst element = <h1>Hello, React!</h1>;\n// becomes\nconst element = React.createElement('h1', null, 'Hello, React!');\n\n// Webpack bundles modules\nimport App from './App';\nimport './styles.css';\n\n// The bundled output can be included in index.html for the browser"
}
,
 {
  "title": "React Quiz",
  "note": "React quizzes are interactive exercises designed to test and reinforce your knowledge of React concepts, components, hooks, state management, routing, and best practices.\n\n**Benefits of React Quizzes:**\n- Identify gaps in your understanding.\n- Reinforce learning through practical examples.\n- Prepare for interviews and real-world projects.\n- Learn to debug and reason about React code.\n\n**Tips for Taking Quizzes:**\n1. Attempt multiple-choice questions to quickly recall concepts.\n2. Solve coding challenges to practice hands-on skills.\n3. Review explanations for any incorrect answers to deepen understanding.\n4. Gradually increase difficulty to cover advanced topics like hooks, context, and performance optimization.",
  "code": "// Example: Online React quizzes\n// Websites like freeCodeCamp, Codecademy, and React Quiz apps\n// provide interactive React questions and coding exercises."
},
  {
  "title": "React Syllabus",
  "note": "A React syllabus is a structured plan that outlines all essential topics and concepts to learn React efficiently. It helps learners progress logically from basic to advanced concepts, ensuring comprehensive coverage.\n\n**Key Sections in a React Syllabus:**\n1. **Introduction & Setup**: React basics, JSX, creating a React project.\n2. **Components**: Functional and class components, props, and state.\n3. **Events & Forms**: Handling events, controlled and uncontrolled components.\n4. **Conditional Rendering & Lists**: If/else, ternary operators, mapping lists.\n5. **Routing**: Using React Router for navigation.\n6. **Hooks**: useState, useEffect, useContext, useReducer, useRef, useMemo, useCallback.\n7. **Context API**: Managing global state without prop drilling.\n8. **Performance Optimization**: React.memo, lazy loading, code splitting.\n9. **Styling**: CSS, Sass, styled-components.\n10. **Testing & Best Practices**: Unit testing components, coding standards.\n11. **Projects**: Build small to complex applications to apply knowledge.\n\nFollowing a syllabus helps track progress and ensures no important topic is missed.",
  "code": "// Example: Create your own React syllabus in a document or Markdown\n// Outline topics, goals, and exercises for each week."
}
,
  {
  "title": "React Study Plan",
  "note": "A React study plan is a structured schedule designed to help learners master React progressively. It breaks down the syllabus into manageable daily or weekly goals, balancing theory and practice for steady improvement.\n\n**Example Study Plan:**\n1. **Week 1**: Introduction to React, JSX, creating your first component.\n2. **Week 2**: Functional components, props, and state.\n3. **Week 3**: Handling events, forms, and conditional rendering.\n4. **Week 4**: Lists, keys, and mapping data.\n5. **Week 5**: React Router for navigation.\n6. **Week 6**: Hooks: useState, useEffect, useContext.\n7. **Week 7**: Advanced hooks: useReducer, useRef, useMemo, useCallback.\n8. **Week 8**: Context API, state management, performance optimization.\n9. **Week 9**: Styling with CSS and Sass.\n10. **Week 10**: Build a small project to apply concepts.\n\nConsistency and hands-on practice are key to mastering React efficiently.",
  "code": "// Create a schedule with daily or weekly milestones\n// Include exercises, mini-projects, and review sessions"
},
  {
  "title": "React Server",
  "note": "Server-side rendering (SSR) is a technique where React components are rendered on the server instead of the client. This approach improves SEO, reduces initial load time, and enhances performance for users. Frameworks like Next.js simplify SSR by providing built-in routing, data fetching, and rendering optimizations.\n\n**Benefits of SSR:**\n1. Faster initial page load.\n2. Better SEO since content is pre-rendered.\n3. Improved user experience on slow networks.\n\n**How to implement:**\n- Use Next.js to create pages that render on the server.\n- Use `getServerSideProps` or `getStaticProps` to fetch data during SSR.\n- Combine with client-side hydration for interactivity.",
  "code": "// Example with Next.js\nimport React from 'react';\n\nexport async function getServerSideProps() {\n  // fetch data from API\n  return { props: { data } };\n}\n\nexport default function Page({ data }) {\n  return <div>{data}</div>;\n}"
},
  {
  "title": "React Interview Prep",
  "note": "Preparing for React interviews involves understanding core concepts, practicing coding challenges, and building projects to demonstrate your skills.\n\n**Key Areas to Focus On:**\n1. **React Fundamentals:** Components, JSX, props, state, and lifecycle methods.\n2. **Hooks:** useState, useEffect, useContext, useReducer, useMemo, useCallback.\n3. **Routing & Navigation:** React Router, nested routes, dynamic routing.\n4. **State Management:** Context API, Redux basics, or other state management tools.\n5. **Performance Optimization:** Memoization, lazy loading, code splitting.\n6. **Testing:** Unit testing with Jest and React Testing Library.\n7. **Project Experience:** Be ready to explain your projects, the problems you solved, and your design choices.\n\n**Tips:**\n- Practice coding problems on platforms like LeetCode or CodeSandbox.\n- Review React documentation regularly.\n- Prepare for behavioral questions alongside technical questions.",
  "code": "// Example coding prep\n// Build a small to-do app using React hooks\nfunction TodoApp() {\n  const [todos, setTodos] = React.useState([]);\n  return <div>{todos.map(todo => <div key={todo.id}>{todo.text}</div>)}</div>;\n}"
 },
  {
  "title": "React Certificate",
  "note": "A React certificate validates your knowledge and skills in React development. Completing structured courses, hands-on projects, and assessments can earn you a certificate.\n\n**Benefits of Certification:**\n1. **Career Advancement:** Stand out to employers as a verified React developer.\n2. **Skill Validation:** Demonstrates proficiency in React concepts, hooks, state management, and component design.\n3. **Portfolio Boost:** Certificates can complement your projects and showcase your expertise.\n4. **Confidence:** Builds confidence in applying React in real-world projects.\n\n**How to Earn:**\n- Complete online React courses on platforms like Coursera, Udemy, or freeCodeCamp.\n- Work on practical projects and submit assignments.\n- Pass final assessments or exams as required by the program.\n\n**Tips:**\n- Choose a reputable certification provider.\n- Focus on understanding concepts deeply, not just passing exams.\n- Display your certificate on LinkedIn, resume, and portfolio.",
  "code": "// Example: After completing a React course\n// Display certificate URL or PDF link to employers\nconst certificateLink = 'https://www.example.com/react-certificate.pdf';\nconsole.log('View my React Certificate:', certificateLink);"
},
  {
  "title": "React Context API",
  "note": "The React Context API allows you to share data across multiple components without having to pass props manually at every level (prop drilling).\n\n**Key Concepts:**\n1. **Context Creation:** Use `React.createContext()` to create a context object.\n2. **Provider:** `<MyContext.Provider>` wraps components that need access to the shared data. The `value` prop holds the data to be shared.\n3. **Consumer / useContext:** Components can access the context using `<MyContext.Consumer>` or the `useContext` hook.\n4. **Use Cases:** Themes, authentication status, user settings, or any global state.\n\n**Example:**\n```javascript\nconst ThemeContext = React.createContext('light');\n\nfunction App() {\n  return (\n    <ThemeContext.Provider value=\"dark\">\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\nfunction Toolbar() {\n  return <ThemeButton />;\n}\n\nfunction ThemeButton() {\n  const theme = React.useContext(ThemeContext);\n  return <button style={{ background: theme === 'dark' ? '#333' : '#fff' }}>Click Me</button>;\n}\n```\n**Benefits:**\n- Eliminates prop drilling.\n- Centralizes state management for specific contexts.\n- Simplifies passing global data across components.",
  "code": "const MyContext = React.createContext();\n<MyContext.Provider value={value}>...</MyContext.Provider>"
},
  {
  "title": "React Suspense & Lazy Loading",
  "note": "React Suspense and Lazy Loading let you load components only when they are needed, reducing the initial bundle size and improving performance.\n\n**Key Concepts:**\n1. **React.lazy():** Dynamically imports a component.\n2. **Suspense:** Wraps lazy-loaded components and shows a fallback UI (like a loader) while the component is being loaded.\n3. **Benefits:** Improves app performance by splitting code into smaller chunks.\n\n**Example:**\n```javascript\nimport React, { Suspense } from 'react';\n\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <LazyComponent />\n    </Suspense>\n  );\n}\n```\n**Notes:**\n- You can wrap multiple lazy components with a single Suspense.\n- Useful for routes, modals, or large components that aren’t immediately needed."
  ,
  "code": "const LazyComponent = React.lazy(() => import('./LazyComponent'));\n<Suspense fallback={<div>Loading...</div>}><LazyComponent /></Suspense>"
},
  {
  "title": "React Error Boundaries",
  "note": "Error Boundaries are React components that catch JavaScript errors in their child component tree, log them, and display a fallback UI instead of crashing the whole app.\n\n**Key Points:**\n1. **componentDidCatch(error, info):** Lifecycle method used to log errors.\n2. **render():** Typically renders children or a fallback UI when an error occurs.\n3. **Use Cases:** Prevents the entire React app from crashing due to a single component error.\n4. **Limitations:** Only catches errors in class components; does not catch errors in event handlers, async code, or server-side rendering.\n\n**Example:**\n```javascript\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    console.error('Error caught by ErrorBoundary:', error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children;\n  }\n}\n```\n**Usage:** Wrap potentially error-prone components:\n```javascript\n<ErrorBoundary>\n  <MyComponent />\n</ErrorBoundary>\n```"
  ,
  "code": "class ErrorBoundary extends React.Component {\n  componentDidCatch(error, info) { /* handle error */ }\n  render() { return this.props.children; }\n}"
},
  {
  "title": "React Portals",
  "note": "React Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.\n\n**Key Points:**\n1. **Use Cases:** Modals, tooltips, dropdowns, and overlays where the element should visually appear outside the parent container.\n2. **Syntax:** `ReactDOM.createPortal(child, container)` where `child` is the React element and `container` is a DOM node.\n3. **Event Bubbling:** Events from portal children propagate to ancestors in the React tree, even if they are outside the DOM hierarchy.\n\n**Example:**\n```javascript\nfunction Modal({ children }) {\n  return ReactDOM.createPortal(\n    <div className=\"modal\">\n      {children}\n    </div>,\n    document.getElementById('modal-root')\n  );\n}\n\n// Usage in a component\nfunction App() {\n  return (\n    <div>\n      <h1>Main App</h1>\n      <Modal>\n        <p>This is rendered via portal!</p>\n      </Modal>\n    </div>\n  );\n}\n```"
  ,
  "code": "ReactDOM.createPortal(<Modal />, document.getElementById('modal-root'))"
},
  {
  "title": "React Fragments",
  "note": "React Fragments let you group multiple elements without adding extra nodes to the DOM. This is useful when a component must return multiple elements but you don't want to introduce unnecessary wrapper elements.\n\n**Key Points:**\n1. **Syntax:**\n   - Short syntax: `<> ... </>`\n   - Full syntax: `<React.Fragment> ... </React.Fragment>`\n2. **Use Cases:** Returning multiple elements from a component, rendering lists, or grouping elements without affecting CSS or layout.\n3. **Advantages:** Avoids adding extra `<div>` wrappers which can interfere with styling and DOM structure.\n\n**Example:**\n```javascript\nfunction List() {\n  return (\n    <>\n      <li>Item 1</li>\n      <li>Item 2</li>\n      <li>Item 3</li>\n    </>\n  );\n}\n```",
  "code": "<> <Child1 /> <Child2 /> </>"
}
],
nodejs: [
{
  "title": "Node HOME",
  "note": "Node.js is a powerful, open-source JavaScript runtime built on Chrome's V8 engine. It allows developers to execute JavaScript code on the server side, enabling full-stack JavaScript development.\n\n**Key Features:**\n1. **Event-Driven & Non-Blocking:** Uses an event-driven, asynchronous model, making it efficient and suitable for I/O-heavy applications.\n2. **Single-Threaded:** Despite being single-threaded, it handles concurrent connections efficiently using the event loop.\n3. **Package Ecosystem:** npm provides access to thousands of libraries and tools.\n4. **Use Cases:** Building web servers, APIs, real-time applications (chat, games), and microservices.\n\n**Example:**\n```javascript\nconsole.log('Welcome to Node.js!');\n```",
  "code": "console.log('Welcome to Node.js!');"
},
  {
  "title": "Node Intro",
  "note": "Node.js is a runtime environment that executes JavaScript outside the browser. It uses an event-driven, non-blocking I/O model, which makes it lightweight, efficient, and suitable for building scalable network applications such as web servers, APIs, and real-time applications.\n\n**Key Points:**\n1. **Event-Driven:** Node.js responds to events, making it ideal for asynchronous tasks.\n2. **Non-Blocking I/O:** Input/output operations do not block execution, improving performance.\n3. **Single-Threaded:** Uses a single-threaded event loop to handle multiple connections.\n4. **Modules:** Built-in modules like `http`, `fs`, and `path` simplify server-side development.\n\n**Example:**\n```javascript\nconst http = require('http');\nhttp.createServer((req, res) => res.end('Hello Node')).listen(3000);\nconsole.log('Server running at http://localhost:3000/');\n```",
  "code": "const http = require('http');\nhttp.createServer((req, res) => res.end('Hello Node')).listen(3000);\nconsole.log('Server running at http://localhost:3000/');"
},
  {
    "title": "Node Get Started",
    "note": "Install Node.js, write JavaScript files, and run them via command line using `node filename.js`.",
    "code": "console.log('Node.js is running!');"
  },
  {
    "title": "Node JS Requirements",
    "note": "Node.js requires an OS, V8 engine, and the Node runtime installed for development.",
    "code": "// Check Node version\nconsole.log(process.version);"
  },
  {
    "title": "Node.js vs Browser",
    "note": "Node.js runs JavaScript on the server, browsers run JS on the client with DOM access.",
    "code": "// Node has no window or document object\nconsole.log(typeof window); // undefined"
  },
  {
    "title": "Node Cmd Line",
    "note": "Use the Node REPL or run scripts from the command line for interactive coding or execution.",
    "code": "// Run in terminal:\n// node\n// then type JS commands interactively"
  },
{
  "title": "React Fragments",
  "note": "React Fragments let you group multiple elements without adding extra nodes to the DOM. This is useful when a component must return multiple elements but you don't want to introduce unnecessary wrapper elements.\n\n**Key Points:**\n1. **Syntax:**\n   - Short syntax: `<> ... </>`\n   - Full syntax: `<React.Fragment> ... </React.Fragment>`\n2. **Use Cases:** Returning multiple elements from a component, rendering lists, or grouping elements without affecting CSS or layout.\n3. **Advantages:** Avoids adding extra `<div>` wrappers which can interfere with styling and DOM structure.\n\n**Example:**\n```javascript\nfunction List() {\n  return (\n    <>\n      <li>Item 1</li>\n      <li>Item 2</li>\n      <li>Item 3</li>\n    </>\n  );\n}\n```",
  "code": "<> <Child1 /> <Child2 /> </>"
},
  {
  "title": "Node Architecture",
  "note": "Node.js follows a **single-threaded, event-driven architecture** designed for building highly scalable applications. Instead of creating multiple threads for each request, Node.js uses an **event loop** that handles asynchronous, non-blocking I/O operations.\n\n**Key Components:**\n1. **Single Thread:** Executes JavaScript code on a single thread using the V8 engine.\n2. **Event Loop:** The core mechanism that listens for events and executes callbacks.\n3. **Libuv Library:** Provides the event loop, thread pool, and cross-platform abstractions for I/O operations (like file system and networking).\n4. **Non-blocking I/O:** Allows handling thousands of requests without blocking execution.\n5. **Callback & Promises:** Asynchronous programming models used with the event loop.\n\n**Advantages:**\n- Efficient for I/O-heavy tasks like APIs, chat apps, and streaming services.\n- Lightweight and highly scalable.\n\n**Limitations:**\n- Not ideal for CPU-intensive tasks since heavy computation can block the single thread.\n\nThis architecture makes Node.js particularly powerful for real-time and high-concurrency applications.",
  "code": "// Example: Event loop in action\nconsole.log('Start');\nsetTimeout(() => console.log('Delayed by 1s'), 1000);\nconsole.log('End');"
},
  {
  "title": "Node Event Loop",
  "note": "The **event loop** is the heart of Node.js’s asynchronous architecture. It allows Node.js to perform **non-blocking I/O operations** despite running on a **single thread**. Instead of waiting for operations (like file access, HTTP requests, or database queries) to complete, Node delegates them to the system or background threads (via libuv) and continues executing other code. Once the operation finishes, the callback is queued and executed by the event loop.\n\n**Phases of the Event Loop:**\n1. **Timers Phase:** Executes callbacks scheduled by `setTimeout` and `setInterval`.\n2. **Pending Callbacks Phase:** Executes I/O callbacks deferred to the next loop iteration.\n3. **Idle, Prepare Phase:** Used internally by Node.js.\n4. **Poll Phase:** Retrieves new I/O events, executes I/O callbacks.\n5. **Check Phase:** Executes callbacks from `setImmediate()`.\n6. **Close Callbacks Phase:** Executes close event callbacks like `socket.on('close')`.\n\n**Key Idea:** While the event loop runs indefinitely, it checks the queue and executes pending tasks, making Node.js highly efficient for concurrent operations.\n\nThis mechanism is why Node.js is great for **real-time applications** (chat, streaming, APIs) but less suited for CPU-intensive workloads.",
  "code": "console.log('Start');\nsetTimeout(() => console.log('Timer callback (event loop)'), 0);\nconsole.log('End');"
},
  {
  "title": "Asynchronous",
  "note": "In Node.js, **asynchronous programming** is a core concept. Instead of waiting for an operation (like file reading, database queries, or network requests) to finish, Node.js continues executing other code. When the operation is done, a **callback, promise, or async/await function** handles the result.\n\nThis non-blocking approach ensures the **main thread remains free** to handle more requests, making Node.js highly scalable for I/O-heavy applications. However, it introduces challenges like **callback hell**, which can be managed using **Promises** and **async/await**.\n\n**Use Cases:**\n- Reading/writing files\n- Handling multiple HTTP requests simultaneously\n- Database queries\n\n**Benefits:**\n- High performance under heavy I/O load\n- Efficient resource utilization\n- Supports real-time applications",
  "code": "const fs = require('fs');\n\nconsole.log('Start reading file...');\n\nfs.readFile('file.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log('File content:', data);\n});\n\nconsole.log('Other tasks can run without waiting!');"
},
  {
  "title": "Node Async",
  "note": "Asynchronous programming in Node.js allows tasks to run without blocking the main thread, improving performance and responsiveness. Node achieves this through callbacks, promises, and async/await. Callbacks are the traditional way, promises provide better error handling and chaining, while async/await makes asynchronous code look synchronous, enhancing readability.",
  "code": "function fetchDataFromDB() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('📦 Data successfully loaded from database');\n    }, 2000);\n  });\n}\n\nasync function getData() {\n  console.log('Fetching data...');\n  const data = await fetchDataFromDB();\n  console.log(data);\n  console.log('Done ✅');\n}\n\ngetData();"
},
  {
  "title": "Node Promises",
  "note": "Promises in Node.js are objects that represent the eventual completion (or failure) of an asynchronous operation. They help avoid callback hell by allowing you to chain multiple async operations in a cleaner and more manageable way using .then() for success and .catch() for errors.",
  "code": "const fetchUser = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve({ id: 1, name: 'Alice' });\n  }, 1000);\n});\n\nfetchUser\n  .then(user => {\n    console.log('User fetched:', user);\n    return new Promise(resolve => {\n      setTimeout(() => resolve({ ...user, role: 'admin' }), 1000);\n    });\n  })\n  .then(updatedUser => {\n    console.log('Updated User:', updatedUser);\n  })\n  .catch(err => console.error('Error:', err));"
},
  {
  "title": "Node Async/Await",
  "note": "The async/await syntax in Node.js makes asynchronous code look synchronous, improving readability and maintainability. Behind the scenes, async functions return promises, and `await` pauses execution until the promise resolves or rejects. This approach reduces callback nesting and simplifies error handling with try/catch.",
  "code": "function fetchUserFromDB() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({ id: 1, name: 'Alice' });\n    }, 1000);\n  });\n}\n\nasync function getUserData() {\n  try {\n    console.log('Fetching user...');\n    const user = await fetchUserFromDB();\n    console.log('User fetched:', user);\n\n    console.log('Fetching user role...');\n    const userRole = await new Promise(resolve => {\n      setTimeout(() => resolve({ ...user, role: 'admin' }), 1000);\n    });\n    console.log('User with role:', userRole);\n\n    console.log('All operations done ✅');\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n}\n\ngetUserData();"
},
  {
  "title": "Node Error Handling",
  "note": "Error handling in Node.js is essential for robust applications. Errors can be managed using:\n1. Callbacks: traditionally, the first parameter is an error.\n2. Promises: use .catch() to handle rejected promises.\n3. Async/Await: use try/catch blocks around awaited operations.\nProper error handling prevents crashes and ensures predictable behavior.",
  "code": "// 1. Callback style\nfunction readFileCallback(err, data) {\n  if (err) {\n    console.error('Callback error:', err);\n  } else {\n    console.log('Callback data:', data);\n  }\n}\n\n// 2. Promise style\nconst promiseExample = new Promise((resolve, reject) => {\n  reject(new Error('Promise failed'));\n});\npromiseExample.catch(err => console.error('Promise error:', err.message));\n\n// 3. Async/Await style\nasync function asyncExample() {\n  try {\n    await Promise.reject(new Error('Async/Await failed'));\n  } catch (err) {\n    console.error('Async/Await error:', err.message);\n  }\n}\nasyncExample();"
},
  {
  "title": "Node Module Basics",
  "note": "Modules in Node.js allow you to encapsulate code into separate files for better organization and reusability. You can export functions, objects, or values using `module.exports` and import them using `require()`. This helps keep your code modular, maintainable, and easier to test.",
  "code": "// math.js\nmodule.exports = {\n  sum: (a, b) => a + b,\n  multiply: (a, b) => a * b\n};\n\n// app.js\nconst math = require('./math');\nconsole.log('Sum:', math.sum(5, 3));\nconsole.log('Multiply:', math.multiply(5, 3));"
},
  {
  "title": "Node Modules",
  "note": "Node.js modules are reusable blocks of code that help organize functionality. There are three main types:\n1. **Built-in modules**: Provided by Node.js, e.g., `fs`, `http`, `path`.\n2. **User-defined modules**: Your own code exported from separate files.\n3. **Third-party modules**: Installed via npm, e.g., `express`, `lodash`.\nModules keep code organized, maintainable, and shareable.",
  "code": "// Built-in module example\nconst fs = require('fs');\n\n// Check the type of a function\nconsole.log('Type of fs.readFile:', typeof fs.readFile);\n\n// Example: read a file asynchronously\nfs.readFile('example.txt', 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading file:', err);\n  } else {\n    console.log('File content:', data);\n  }\n});"
},
  {
  "title": "Node ES Modules",
  "note": "ES Modules (ESM) in Node.js use the modern `import` and `export` syntax, similar to frontend JavaScript. They are supported natively in recent Node versions (>=12 with `.mjs` or by setting `\"type\": \"module\"` in package.json). ESM provides better static analysis, cleaner syntax, and compatibility with modern JavaScript standards.",
  "code": "// math.mjs\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function multiply(a, b) {\n  return a * b;\n}\n\n// app.mjs\nimport { add, multiply } from './math.mjs';\n\nconsole.log('Sum:', add(5, 3));\nconsole.log('Multiply:', multiply(5, 3));"
},
  {
  "title": "Node NPM",
  "note": "NPM (Node Package Manager) is the default package manager for Node.js. It allows you to install, manage, and update third-party packages and libraries. NPM also helps manage project dependencies via `package.json` and provides scripts to automate tasks.",
  "code": "// Install a package via terminal\nnpm install express\n\n// Initialize a new project with package.json\nnpm init -y\n\n// Install a package as a development dependency\nnpm install nodemon --save-dev\n\n// Run a script defined in package.json\nnpm run start"
},
  {
  "title": "Node package.json",
  "note": "The `package.json` file is the heart of any Node.js project. It stores project metadata such as name, version, description, and author. It also defines dependencies, devDependencies, and scripts that automate tasks like starting the app or running tests. Proper configuration ensures reproducible builds and easier collaboration.",
  "code": "{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A simple Node.js project\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"nodemon app.js\",\n    \"test\": \"echo \\\"No tests yet\\\" && exit 0\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.22\"\n  },\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\"\n}"
},
  {
  "title": "Node NPM Scripts",
  "note": "NPM scripts allow you to automate commands and tasks in your Node.js project. Scripts are defined under the `scripts` section in `package.json` and can be run using `npm run <script-name>`. Common use cases include starting the server, running tests, building the project, or automating repetitive tasks.",
  "code": "{\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"nodemon app.js\",\n    \"test\": \"echo \\\"Running tests...\\\" && exit 0\",\n    \"build\": \"echo \\\"Building project...\\\"\"\n  }\n}\n\n// Example commands in terminal:\n// npm run start\n// npm run dev\n// npm run test\n// npm run build"
},
  {
  "title": "Node Dependency Management",
  "note": "In Node.js, dependencies are libraries or packages your project relies on. Use `npm install <package>` to add a dependency, which updates both `package.json` and `package-lock.json`. Use `npm uninstall <package>` to remove a dependency. Managing dependencies properly ensures your project works consistently across environments.",
  "code": "// Install a dependency\nnpm install lodash\n\n// Install a dependency as a devDependency\nnpm install jest --save-dev\n\n// Remove a dependency\nnpm uninstall lodash\n\n// View installed dependencies\nnpm list\n\n// Update dependencies\nnpm update"
},
 {
  "title": "Node Publish Packages",
  "note": "You can share your Node.js packages with the world using the npm registry. Before publishing, make sure your package has a unique name, a valid version in `package.json`, and any necessary files included/excluded via `.npmignore`. Use `npm login` to authenticate and `npm publish` to upload your package. Proper versioning ensures users get updates safely.",
  "code": "// Authenticate with npm\nnpm login\n\n// Publish your package to the npm registry\nnpm publish\n\n// Update package version before republishing\nnpm version patch  // or minor/major\nnpm publish"
},
  {
  "title": "Node Core Modules",
  "note": "Node.js provides built-in core modules that offer essential functionality without needing external packages. Examples include `fs` for file system operations, `http` for creating servers, `path` for handling file paths, `crypto` for encryption, and `os` for operating system info. These modules help build robust applications efficiently.",
  "code": "// Using the 'os' core module\nconst os = require('os');\n\nconsole.log('Operating System Platform:', os.platform());\nconsole.log('CPU Architecture:', os.arch());\nconsole.log('Free Memory:', os.freemem());\nconsole.log('Total Memory:', os.totalmem());"
},
  
  {
  "title": "Node HTTP Module",
  "note": "The `http` core module in Node.js allows you to create HTTP servers and clients. It's fundamental for building web servers and APIs without additional frameworks. You can handle requests, send responses, and work with headers and status codes directly.",
  "code": "// Create a simple HTTP server\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('Hello HTTP Server! 🌐');\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});"
}
,
  {
  "title": "Node File System (fs) Module",
  "note": "The `fs` module in Node.js allows you to interact with the file system. You can read and write files either asynchronously (non-blocking) or synchronously (blocking). It also supports other operations like renaming, deleting, and watching files, making it essential for many Node applications.",
  "code": "// Asynchronous file read\nconst fs = require('fs');\n\nfs.readFile('file.txt', 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading file:', err);\n  } else {\n    console.log('File content:', data);\n  }\n});\n\n// Synchronous file write\nfs.writeFileSync('output.txt', 'Hello from Node.js!');\nconsole.log('File written successfully!');"
}
,
  {
  "title": "Node Path Module",
  "note": "The `path` module in Node.js provides utilities for working with file and directory paths. It helps you construct, normalize, and resolve paths in a cross-platform way, ensuring your code works consistently on Windows, Linux, and macOS.",
  "code": "// Using the 'path' module\nconst path = require('path');\n\nconst filePath = path.join(__dirname, 'file.txt');\nconsole.log('Joined Path:', filePath);\n\nconst baseName = path.basename(filePath);\nconsole.log('Base Name:', baseName);\n\nconst dirName = path.dirname(filePath);\nconsole.log('Directory Name:', dirName);\n\nconst extName = path.extname(filePath);\nconsole.log('File Extension:', extName);"
},
  {
  "title": "Node OS Module",
  "note": "The `os` module in Node.js provides operating system-related utility methods and properties. You can retrieve information like CPU architecture, memory usage, platform, uptime, and network interfaces. It's useful for building system-aware applications and monitoring server resources.",
  "code": "// Using the 'os' module\nconst os = require('os');\n\nconsole.log('Platform:', os.platform());\nconsole.log('Architecture:', os.arch());\nconsole.log('Number of CPUs:', os.cpus().length);\nconsole.log('Free Memory:', os.freemem());\nconsole.log('Total Memory:', os.totalmem());\nconsole.log('System Uptime (seconds):', os.uptime());"
},
  {
  "title": "Node URL Module",
  "note": "The `url` module in Node.js provides utilities to parse, construct, and format URLs. It allows you to extract components like protocol, hostname, pathname, search parameters, and hash. This is useful when working with HTTP requests, routing, or web scraping.",
  "code": "// Using the 'url' module\nconst { URL } = require('url');\n\nconst myURL = new URL('https://example.com/path?name=node&lang=en');\n\nconsole.log('Href:', myURL.href);\nconsole.log('Origin:', myURL.origin);\nconsole.log('Protocol:', myURL.protocol);\nconsole.log('Hostname:', myURL.hostname);\nconsole.log('Pathname:', myURL.pathname);\nconsole.log('Search Params:', myURL.searchParams.toString());\nconsole.log('Specific Param (name):', myURL.searchParams.get('name'));"
},
  {
  "title": "Node Events Module",
  "note": "The `events` module in Node.js provides the `EventEmitter` class, which allows you to create and handle custom events asynchronously. It is fundamental for building event-driven architectures, enabling decoupled communication between different parts of an application.",
  "code": "// Using the 'events' module\nconst EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\n// Register an event listener\nemitter.on('greet', (name) => {\n  console.log(`Hello, ${name}! 👋`);\n});\n\n// Emit the event\nemitter.emit('greet', 'Alice');\n\n// Example of multiple listeners\nemitter.on('greet', () => console.log('Another listener triggered!'));\nemitter.emit('greet', 'Bob');"
},
  {
  "title": "Node Stream Module",
  "note": "The `stream` module in Node.js allows you to work with streaming data efficiently, processing it in small chunks rather than loading entire files into memory. Streams are useful for reading/writing large files, handling HTTP requests/responses, and piping data between sources.",
  "code": "// Using streams to read a file\nconst fs = require('fs');\n\nconst readStream = fs.createReadStream('file.txt', 'utf8');\n\nreadStream.on('data', (chunk) => {\n  console.log('Received chunk:', chunk);\n});\n\nreadStream.on('end', () => {\n  console.log('Finished reading file ✅');\n});\n\nreadStream.on('error', (err) => {\n  console.error('Error reading file:', err);\n});\n\n// Writing to a file using a write stream\nconst writeStream = fs.createWriteStream('output.txt');\nwriteStream.write('Streaming data to output file...');\nwriteStream.end();"
},
{
  "title": "Node Buffer Module",
  "note": "The `Buffer` module in Node.js allows you to work with raw binary data directly. Buffers are useful when dealing with streams, TCP sockets, file I/O, or any situation where you need to manipulate bytes efficiently. They provide methods to create, read, write, and convert data between strings and binary formats.",
  "code": "// Creating a buffer from a string\nconst buf = Buffer.from('Hello Node.js');\nconsole.log('Buffer content as string:', buf.toString());\n\n// Creating an empty buffer of 10 bytes\nconst emptyBuf = Buffer.alloc(10);\nconsole.log('Empty buffer:', emptyBuf);\n\n// Writing to a buffer\nbuf.write('Hi');\nconsole.log('Modified buffer:', buf.toString());\n\n// Converting buffer to JSON\nconsole.log('Buffer as JSON:', buf.toJSON());"
},
  {
  "title": "Node Crypto Module",
  "note": "The `crypto` module in Node.js provides cryptographic functionality including hashing, encryption, decryption, HMAC, and digital signatures. It is commonly used for securing data, passwords, and communication in Node.js applications.",
  "code": "// Using the crypto module for hashing\nconst crypto = require('crypto');\n\nconst data = 'Hello Node.js';\nconst hash = crypto.createHash('sha256').update(data).digest('hex');\nconsole.log('SHA-256 Hash:', hash);\n\n// Creating HMAC\nconst hmac = crypto.createHmac('sha256', 'secret-key').update(data).digest('hex');\nconsole.log('HMAC:', hmac);\n\n// Generating random bytes\nconst randomBytes = crypto.randomBytes(16).toString('hex');\nconsole.log('Random bytes:', randomBytes);"
},
  {
  "title": "Node Timers Module",
  "note": "The `timers` module in Node.js allows you to schedule code execution using functions like `setTimeout`, `setInterval`, and `setImmediate`. Timers are useful for delaying tasks, running repeated actions, or scheduling asynchronous operations.",
  "code": "// Using setTimeout\nsetTimeout(() => {\n  console.log('Executed after 1 second ⏱️');\n}, 1000);\n\n// Using setInterval\nlet count = 0;\nconst interval = setInterval(() => {\n  count++;\n  console.log('Interval tick:', count);\n  if (count === 5) clearInterval(interval);\n}, 1000);\n\n// Using setImmediate\nsetImmediate(() => console.log('Executed immediately after I/O events'));"
},
  {
  "title": "Node DNS Module",
  "note": "The `dns` module in Node.js provides functions to perform DNS lookups and resolve hostnames to IP addresses. It's useful for networking applications, verifying domains, or retrieving server addresses programmatically.",
  "code": "// Using the dns module\nconst dns = require('dns');\n\n// Lookup a hostname\ndns.lookup('example.com', (err, address, family) => {\n  if (err) {\n    console.error('DNS lookup error:', err);\n  } else {\n    console.log('Address:', address);\n    console.log('Address family:', family);\n  }\n});\n\n// Resolve all A records\ndns.resolve4('example.com', (err, addresses) => {\n  if (err) console.error(err);\n  else console.log('IPv4 Addresses:', addresses);\n});"
},
  {
  "title": "Node Assert Module",
  "note": "The `assert` module in Node.js provides a simple set of assertion functions for verifying invariants in your code. It is commonly used for writing unit tests to ensure that functions behave as expected, throwing errors when assertions fail.",
  "code": "// Using the assert module\nconst assert = require('assert');\n\n// Basic assertion\nassert.strictEqual(1 + 1, 2, '1 + 1 should equal 2');\n\n// Deep equality check\nconst obj1 = { a: 1 };\nconst obj2 = { a: 1 };\nassert.deepStrictEqual(obj1, obj2, 'Objects should be deeply equal');\n\n// Throws error if condition is false\nassert.ok(true, 'This should pass');\nassert.throws(\n  () => { throw new Error('Fail'); },\n  /Fail/,\n  'Expected error was not thrown'\n);"
},
  {
  "title": "Node Util Module",
  "note": "The `util` module in Node.js provides utility functions for debugging, inspecting objects, deprecating functions, and converting callback-based functions to promises. It's useful for making development easier and writing cleaner, more maintainable code.",
  "code": "// Using the util module\nconst util = require('util');\n\n// Type check\nconsole.log('Is array:', util.isArray([]));\nconsole.log('Is array:', util.isArray({}));\n\n// Inspect object\nconst obj = { a: 1, b: { c: 2 } };\nconsole.log(util.inspect(obj, { depth: null, colors: true }));\n\n// Convert callback to promise\nconst fs = require('fs');\nconst readFileAsync = util.promisify(fs.readFile);\nreadFileAsync('file.txt', 'utf8').then(console.log).catch(console.error);"
},
  {
  "title": "Node Readline Module",
  "note": "The `readline` module in Node.js allows you to create interactive command-line interfaces. You can read input from the user, process it, and display output. It is commonly used for CLI applications, prompts, and scripts that require user interaction.",
  "code": "// Using the readline module\nconst readline = require('readline').createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// Ask user for input\nreadline.question('What is your name? ', (name) => {\n  console.log(`Hello, ${name}! 👋`);\n\n  // Ask another question\n  readline.question('How old are you? ', (age) => {\n    console.log(`You are ${age} years old.`);\n    readline.close();\n  });\n});"
},
{
  "title": "JavaScript & TypeScript in Node",
  "note": "Node.js supports modern JavaScript (ES6+) features like arrow functions, template literals, destructuring, classes, and modules. It also supports TypeScript, enabling type safety, interfaces, and better developer tooling when compiled to JavaScript. This allows building more robust and maintainable applications.",
  "code": "// ES6 JavaScript example\nconst greet = (name) => `Hello, ${name}!`;\nconsole.log(greet('Node.js'));\n\n// TypeScript example (requires ts-node or compilation)\n// function greetTS(name: string): string {\n//   return `Hello, ${name}!`;\n// }\n// console.log(greetTS('TypeScript'));"
},
  {
  "title": "Node ES6+ Features",
  "note": "Node.js supports modern ES6+ JavaScript features such as arrow functions, destructuring, classes, template literals, default parameters, rest/spread operators, and modules. Using these features makes code cleaner, more readable, and maintainable.",
  "code": "// Using classes, template literals, and arrow functions\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet = () => `Hi, I am ${this.name}, and I am ${this.age} years old.`;\n}\n\nconst nodeUser = new Person('Node', 5);\nconsole.log(nodeUser.greet());\n\n// Destructuring example\nconst { name, age } = nodeUser;\nconsole.log(`Destructured: ${name}, ${age}`);"
},
  {
  "title": "Node Process Module",
  "note": "The `process` object in Node.js provides information and control over the current Node process. You can access environment variables, process ID, memory usage, command-line arguments, and handle exit events. It is essential for managing the runtime environment and interacting with the system.",
  "code": "// Accessing process info\nconsole.log('Process ID:', process.pid);\nconsole.log('Node Version:', process.version);\nconsole.log('Platform:', process.platform);\nconsole.log('Memory Usage:', process.memoryUsage());\n\n// Accessing command-line arguments\nconsole.log('Arguments:', process.argv);\n\n// Handling exit event\nprocess.on('exit', (code) => {\n  console.log(`About to exit with code: ${code}`);\n});\n\n// Exiting process\nprocess.exit(0);"
},
{
  "title": "Node TypeScript",
  "note": "TypeScript is a superset of JavaScript that adds static typing and modern language features to Node.js applications. Using TypeScript improves developer experience, provides better code quality, and helps catch errors at compile time. It can be compiled to plain JavaScript to run in Node.js.",
  "code": "// example.ts\nconst greet = (name: string): string => `Hello, ${name}`;\nconsole.log(greet('TypeScript'));\n\n// Example with interface\ntype User = {\n  name: string;\n  age: number;\n};\n\nconst user: User = { name: 'Alice', age: 25 };\nconsole.log(`User: ${user.name}, Age: ${user.age}`);"
},
  {
  "title": "Node Advanced TypeScript",
  "note": "Advanced TypeScript features in Node.js include interfaces, optional properties, generics, decorators, type inference, union types, and more. These features help build robust, scalable, and maintainable applications by enforcing stricter type safety and reducing runtime errors.",
  "code": "// Interface with optional property\ninterface User {\n  name: string;\n  age?: number;\n}\n\nconst user: User = { name: 'Alice' };\nconsole.log('User object:', user);\n\n// Generic function example\nfunction identity<T>(arg: T): T {\n  return arg;\n}\nconsole.log('Generic function:', identity<string>('Hello'));\n\n// Union type example\nlet value: string | number;\nvalue = 'Hello';\nconsole.log('Union type:', value);\nvalue = 42;\nconsole.log('Union type:', value);"
},
  {
  "title": "Node Linting & Formatting",
  "note": "To maintain high code quality and consistent style in Node.js projects, use tools like ESLint for linting and Prettier for code formatting. ESLint checks your code for errors, potential bugs, and enforces coding standards, while Prettier automatically formats your code for readability.",
  "code": "// Install ESLint and Prettier\n// npm install --save-dev eslint prettier\n\n// Initialize ESLint\n// npx eslint --init\n\n// Example npm scripts in package.json\n\"scripts\": {\n  \"lint\": \"eslint .\",\n  \"format\": \"prettier --write .\"\n}\n\n// Run linting and formatting\n// npm run lint\n// npm run format"
},
  {
  "title": "Node Frameworks",
  "note": "Node.js frameworks like Express, Koa, and Fastify simplify building web applications and APIs. They provide features such as routing, middleware, request handling, and template rendering, allowing developers to build scalable server-side applications quickly and efficiently.",
  "code": "// Using Express framework\nconst express = require('express');\nconst app = express();\n\n// Middleware example\napp.use((req, res, next) => {\n  console.log(`${req.method} ${req.url}`);\n  next();\n});\n\n// Route example\napp.get('/', (req, res) => res.send('Hello from Express!'));\n\n// Start server\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
  {
  "title": "Express.js Framework",
  "note": "Express.js is a fast, minimal, and flexible web framework for Node.js. It provides robust features for building web applications and APIs, including routing, middleware support, template engines, and error handling, making it one of the most popular Node.js frameworks.",
  "code": "// Using Express.js\nconst express = require('express');\nconst app = express();\n\n// Middleware example\napp.use((req, res, next) => {\n  console.log(`${req.method} ${req.url}`);\n  next();\n});\n\n// Route example\napp.get('/', (req, res) => res.send('Hello Express.js!'));\n\n// Route with parameter\napp.get('/user/:name', (req, res) => res.send(`Hello, ${req.params.name}`));\n\n// Start server\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
  {
  "title": "Express.js Middleware",
  "note": "Middleware in Express.js are functions that have access to the request (`req`) and response (`res`) objects, as well as the `next` function. They can execute code, modify requests/responses, end the request-response cycle, or call the next middleware. Middleware enables modular, reusable, and organized code in web applications.",
  "code": "// Example of middleware in Express.js\nconst express = require('express');\nconst app = express();\n\n// Simple logging middleware\napp.use((req, res, next) => {\n  console.log(`Request Method: ${req.method}, URL: ${req.url}`);\n  next(); // Pass control to the next middleware\n});\n\n// Route handler\napp.get('/', (req, res) => res.send('Hello with Middleware!'));\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "title": "REST API Design in Node.js",
  "note": "REST (Representational State Transfer) APIs in Node.js allow client-server communication using HTTP methods like GET, POST, PUT, DELETE to operate on resources. Designing RESTful APIs involves defining clear endpoints, using appropriate HTTP verbs, and returning structured responses (usually JSON).",
  "code": "// Example REST API with Express.js\nconst express = require('express');\nconst app = express();\napp.use(express.json()); // Middleware to parse JSON\n\n// GET all users\napp.get('/users', (req, res) => {\n  res.json([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);\n});\n\n// GET user by ID\napp.get('/users/:id', (req, res) => {\n  const userId = parseInt(req.params.id);\n  res.json({ id: userId, name: 'Alice' });\n});\n\n// POST new user\napp.post('/users', (req, res) => {\n  const newUser = req.body;\n  res.status(201).json(newUser);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
  {
  "title": "API Authentication in Node.js",
  "note": "API authentication ensures that only authorized users can access your endpoints. Common methods include token-based authentication (JWT), session-based authentication, and OAuth. Authentication verifies the user's identity, while authorization determines what resources they can access.",
  "code": "// Example middleware to check auth token\nconst express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  const token = req.headers.authorization;\n  if (!token) {\n    return res.status(401).json({ message: 'Unauthorized: No token provided' });\n  }\n  // Token validation logic would go here\n  console.log('Token received:', token);\n  next();\n});\n\napp.get('/protected', (req, res) => res.send('You have access to protected route'));\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
 {
  "title": "Node.js with Frontend Frameworks",
  "note": "Node.js is commonly used as a backend server that provides APIs for frontend frameworks such as React, Angular, or Vue. It handles data, authentication, and business logic, while the frontend consumes these APIs to render dynamic content and interact with users.",
  "code": "// Example Node.js backend API with Express\nconst express = require('express');\nconst app = express();\n\n// JSON API endpoint\napp.get('/data', (req, res) => {\n  res.json({ message: 'Hello from Node.js backend!' });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));\n\n/*\nFrontend (React) example:\nfetch('http://localhost:3000/data')\n  .then(res => res.json())\n  .then(data => console.log(data));\n*/"
},
  {
  "title": "Node.js MySQL Basics",
  "note": "Node.js can connect to MySQL databases using modules like `mysql` or `mysql2`. This allows performing queries, retrieving data, and managing database operations directly from your Node.js applications.",
  "code": "// Using mysql module\nconst mysql = require('mysql');\n\n// Create connection\nconst con = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'testdb' // optional database\n});\n\n// Connect to MySQL server\ncon.connect(err => {\n  if (err) throw err;\n  console.log('Connected to MySQL database!');\n\n  // Example query\n  con.query('SELECT 1 + 1 AS solution', (err, results) => {\n    if (err) throw err;\n    console.log('Query result:', results[0].solution);\n  });\n});"
},
  {
  "title": "Node.js MySQL CRUD Operations",
  "note": "Using Node.js with MySQL, you can perform CRUD (Create, Read, Update, Delete) operations by executing SQL queries through modules like `mysql` or `mysql2`. This allows your Node.js applications to manage database records dynamically.",
  "code": "// Using mysql module\nconst mysql = require('mysql');\nconst con = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'testdb'\n});\n\ncon.connect(err => {\n  if (err) throw err;\n  console.log('Connected to MySQL database!');\n\n  // INSERT example\n  con.query('INSERT INTO users(name) VALUES(?)', ['John'], (err) => {\n    if (err) throw err;\n    console.log('Inserted user John');\n  });\n\n  // UPDATE example\n  con.query('UPDATE users SET name = ? WHERE name = ?', ['Johnny', 'John'], (err) => {\n    if (err) throw err;\n    console.log('Updated user John to Johnny');\n  });\n\n  // DELETE example\n  con.query('DELETE FROM users WHERE name = ?', ['Johnny'], (err) => {\n    if (err) throw err;\n    console.log('Deleted user Johnny');\n  });\n});"
},
  {
  "title": "Node.js MongoDB Basics",
  "note": "Node.js can interact with MongoDB using the official `mongodb` driver or ORMs like `Mongoose`. This allows you to perform database operations such as creating, reading, updating, and deleting documents in a flexible, schema-less database environment.",
  "code": "// Using MongoDB Node.js driver\nconst { MongoClient } = require('mongodb');\nconst uri = 'mongodb://localhost:27017';\n\nMongoClient.connect(uri, { useUnifiedTopology: true }, (err, client) => {\n  if (err) throw err;\n  console.log('Connected to MongoDB');\n\n  const db = client.db('testdb');\n  const collection = db.collection('users');\n\n  // Insert a document example\n  collection.insertOne({ name: 'Alice', age: 25 }, (err, result) => {\n    if (err) throw err;\n    console.log('Inserted document:', result.insertedId);\n    client.close();\n  });\n});"
},
  {
  "title": "Node.js MongoDB CRUD Operations",
  "note": "Using Node.js with MongoDB, you can perform CRUD (Create, Read, Update, Delete) operations on collections. This allows your applications to manage documents dynamically in a schema-less, flexible database environment.",
  "code": "// Using MongoDB Node.js driver\nconst { MongoClient } = require('mongodb');\nconst uri = 'mongodb://localhost:27017';\n\nMongoClient.connect(uri, { useUnifiedTopology: true }, (err, client) => {\n  if (err) throw err;\n  console.log('Connected to MongoDB');\n\n  const db = client.db('testdb');\n  const collection = db.collection('users');\n\n  // CREATE\n  collection.insertOne({ name: 'John', age: 30 }, (err, result) => {\n    if (err) throw err;\n    console.log('Inserted document:', result.insertedId);\n\n    // READ\n    collection.find({}).toArray((err, docs) => {\n      if (err) throw err;\n      console.log('All documents:', docs);\n\n      // UPDATE\n      collection.updateOne({ name: 'John' }, { $set: { age: 31 } }, (err, res) => {\n        if (err) throw err;\n        console.log('Updated document');\n\n        // DELETE\n        collection.deleteOne({ name: 'John' }, (err, res) => {\n          if (err) throw err;\n          console.log('Deleted document');\n          client.close();\n        });\n      });\n    });\n  });\n});"
},
  {
  "title": "Node.js Crypto Module",
  "note": "The Crypto module in Node.js provides cryptographic functionality including hashing, encryption, decryption, and signing. It is useful for securing data, generating hashes, and implementing authentication mechanisms.",
  "code": "// Using Crypto module\nconst crypto = require('crypto');\n\n// Hashing example\nconst hash = crypto.createHash('sha256').update('Hello Node.js').digest('hex');\nconsole.log('SHA-256 Hash:', hash);\n\n// HMAC example\nconst hmac = crypto.createHmac('sha256', 'secret-key').update('Hello').digest('hex');\nconsole.log('HMAC:', hmac);\n\n// Random bytes example\nconst random = crypto.randomBytes(16).toString('hex');\nconsole.log('Random Bytes:', random);"
},
  {
  "title": "Node.js File Operations",
  "note": "The `fs` module in Node.js allows reading, writing, and manipulating files asynchronously or synchronously. It is essential for tasks like storing data, logging, and handling file-based configurations.",
  "code": "// Using fs module\nconst fs = require('fs');\n\n// Write to a file\nfs.writeFile('file.txt', 'Hello Node.js', err => {\n  if (err) throw err;\n  console.log('File saved!');\n});\n\n// Read from a file\nfs.readFile('file.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log('File contents:', data);\n});\n\n// Append to a file\nfs.appendFile('file.txt', '\\nAppended text', err => {\n  if (err) throw err;\n  console.log('Text appended!');\n});\n\n// Delete a file\nfs.unlink('file.txt', err => {\n  if (err) throw err;\n  console.log('File deleted!');\n});"
},
 {
  "title": "Node.js Event Loop",
  "note": "The Node.js Event Loop allows non-blocking, asynchronous operations by handling callbacks, promises, and timers in phases. It enables Node.js to perform I/O operations efficiently without blocking the main thread.",
  "code": "// Event loop demonstration\nconsole.log('Start');\n\nsetTimeout(() => console.log('Timeout callback'), 0); // macrotask\n\nPromise.resolve().then(() => console.log('Promise callback')); // microtask\n\nconsole.log('End');\n\n/*\nExpected output order:\nStart\nEnd\nPromise callback\nTimeout callback\n*/"
},
  {
  "title": "Node.js Child Process",
  "note": "The `child_process` module allows Node.js to spawn subprocesses, execute system commands, or run other scripts asynchronously. This is useful for tasks like automating scripts, running shell commands, or parallel processing.",
  "code": "// Using child_process module\nconst { exec, spawn } = require('child_process');\n\n// Exec example - run a shell command\nexec('ls', (err, stdout, stderr) => {\n  if (err) throw err;\n  console.log('Exec output:', stdout);\n});\n\n// Spawn example - more control over input/output streams\nconst child = spawn('ls', ['-l']);\nchild.stdout.on('data', data => console.log('Spawn output:', data.toString()));\nchild.stderr.on('data', data => console.error('Spawn error:', data.toString()));\nchild.on('close', code => console.log('Child process exited with code', code));"
},
  {
  "title": "Node.js Debugging",
  "note": "Debugging Node.js applications can be done using the built-in debugger, `console` statements, or external tools like VS Code and Chrome DevTools. Debugging helps identify logic errors, performance issues, and runtime exceptions efficiently.",
  "code": "// Simple debugging example\nconst a = 5;\nconst b = 0;\n\n// Use debugger keyword to pause execution\ndebugger;\nconst result = a / b;\nconsole.log('Result:', result);\n\n/*\nRun with Node's built-in debugger:\nnode inspect app.js\n\nOr use Chrome DevTools / VS Code Debugger for breakpoints and step execution.\n*/"
},
  {
  "title": "Node.js Clustering",
  "note": "Clustering in Node.js allows creating multiple worker processes to utilize multi-core CPUs. Each worker runs a separate instance of the event loop, improving performance for CPU-intensive tasks and handling more concurrent connections.",
  "code": "// Using cluster module\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  // Fork workers\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n  });\n} else {\n  // Workers share the HTTP server\n  http.createServer((req, res) => res.end('Hello from worker ' + process.pid))\n      .listen(3000, () => console.log(`Worker ${process.pid} listening on port 3000`));\n}"
},
  {
  "title": "Socket.io in Node.js",
  "note": "Socket.io allows real-time, bi-directional communication between clients and servers. It is commonly used for chat applications, live notifications, and real-time dashboards.",
  "code": "// Setting up Socket.io server\nconst { Server } = require('socket.io');\nconst io = new Server(3000);\n\nio.on('connection', socket => {\n  console.log('New client connected:', socket.id);\n\n  // Listen for messages from client\n  socket.on('message', msg => {\n    console.log('Received message:', msg);\n    // Broadcast to all connected clients\n    io.emit('message', msg);\n  });\n\n  socket.on('disconnect', () => {\n    console.log('Client disconnected:', socket.id);\n  });\n});\n\n/*\nClient-side example (in browser):\nconst socket = io('http://localhost:3000');\nsocket.emit('message', 'Hello Server');\nsocket.on('message', msg => console.log(msg));\n*/"
},
  {
  "title": "Socket.io Custom Events",
  "note": "Socket.io allows handling custom events for real-time communication. You can define and listen for events on both client and server, enabling features like chat messages, notifications, and live updates.",
  "code": "// Server-side\nconst { Server } = require('socket.io');\nconst io = new Server(3000);\n\nio.on('connection', socket => {\n  console.log('Client connected:', socket.id);\n\n  // Listen for custom event 'chat message'\n  socket.on('chat message', msg => {\n    console.log('Received chat message:', msg);\n    // Broadcast to all clients\n    io.emit('chat message', msg);\n  });\n});\n\n/*\nClient-side example (browser):\nconst socket = io('http://localhost:3000');\nsocket.emit('chat message', 'Hello everyone!');\nsocket.on('chat message', msg => console.log(msg));\n*/"
},
  {
  "title": "Node.js Debug Console",
  "note": "Node.js provides the `console` object with methods like `log`, `info`, `warn`, `error`, and `debug` for debugging and monitoring application output. Combined with the Node inspector or VS Code debugger, it helps track program flow and identify issues.",
  "code": "// Using console methods\nconsole.log('Log message');\nconsole.info('Info message');\nconsole.warn('Warning message');\nconsole.error('Error message');\nconsole.debug('Debug message');\n\n// Run Node.js with inspect flag for breakpoints\n// node --inspect app.js"
},
  {
  "title": "Node.js CLI Applications",
  "note": "Node.js can be used to create command-line applications that accept user input, process data, and output results. Modules like `process`, `readline`, and third-party libraries such as `commander` or `inquirer` simplify building interactive CLI tools.",
  "code": "// Simple CLI example using process.argv\nconst args = process.argv.slice(2);\nconsole.log('Hello CLI! Arguments:', args);\n\n// Using readline for interactive input\nconst readline = require('readline').createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\nreadline.question('Enter your name: ', name => {\n  console.log(`Hello, ${name}!`);\n  readline.close();\n});\n\n/*\nThird-party libraries example (commander or inquirer) can be used for more advanced CLI tools.\n*/"
},
  {
  "title": "Node.js REPL",
  "note": "The Node.js REPL (Read-Eval-Print Loop) allows you to interactively execute JavaScript code in the terminal. It's useful for testing snippets, debugging, and exploring Node.js APIs in real-time.",
  "code": "// Start Node.js REPL\n// Run `node` in terminal without arguments\n\n// Example usage inside REPL:\n// > const a = 5;\n// > const b = 10;\n// > a + b\n// 15\n// > console.log('Hello REPL')"
}
],
SQL : 
  [
  {
  "title": "SQL Home",
  "note": "SQL (Structured Query Language) is the standard language for managing and manipulating relational databases. It allows you to create, read, update, and delete data, as well as define database schemas, enforce constraints, and perform queries to extract meaningful information.",
  "code": "-- Example: Creating a table and inserting data\nCREATE TABLE users (\n  id INT PRIMARY KEY,\n  name VARCHAR(50),\n  email VARCHAR(100)\n);\n\n-- Insert a record\nINSERT INTO users (id, name, email) VALUES (1, 'Alice', 'alice@example.com');\n\n-- Query the table\nSELECT * FROM users;\n\n-- Update a record\nUPDATE users SET name = 'Alice Smith' WHERE id = 1;\n\n-- Delete a record\nDELETE FROM users WHERE id = 1;"
},
  {
  "title": "SQL Introduction",
  "note": "SQL (Structured Query Language) is used to communicate with relational databases. It allows you to create databases and tables, insert and query data, update records, delete records, and manage database structures. SQL is essential for data management, reporting, and analysis in relational database systems.",
  "code": "-- Basic SQL query example\nSELECT 'Welcome to SQL!' AS greeting;\n\n-- Example creating a table\nCREATE TABLE employees (\n  id INT PRIMARY KEY,\n  name VARCHAR(50),\n  department VARCHAR(50)\n);\n\n-- Insert sample data\nINSERT INTO employees (id, name, department) VALUES (1, 'John Doe', 'HR');\n\n-- Query the table\nSELECT * FROM employees;"
},
  {
  "title": "SQL Syntax",
  "note": "SQL statements follow a structured syntax that begins with SQL keywords (like SELECT, INSERT, UPDATE, DELETE) and typically ends with a semicolon. Proper syntax ensures correct execution of queries and readability of your code.",
  "code": "-- Basic SELECT statement\nSELECT column1, column2 FROM table_name;\n\n-- INSERT statement\nINSERT INTO table_name (column1, column2) VALUES ('Value1', 'Value2');\n\n-- UPDATE statement\nUPDATE table_name SET column1 = 'NewValue' WHERE column2 = 'Value2';\n\n-- DELETE statement\nDELETE FROM table_name WHERE column1 = 'Value1';"
},
  {
  "title": "SQL SELECT Statement",
  "note": "The SELECT statement is used to retrieve specific columns or all columns from a table. You can filter, sort, and limit results using clauses like WHERE, ORDER BY, and LIMIT to get the desired dataset.",
  "code": "-- Select specific columns\nSELECT first_name, last_name FROM employees;\n\n-- Select all columns\nSELECT * FROM employees;\n\n-- Select with a condition\nSELECT first_name, last_name FROM employees WHERE department = 'HR';\n\n-- Select with ordering\nSELECT first_name, last_name FROM employees ORDER BY last_name ASC;\n\n-- Select with limit\nSELECT first_name, last_name FROM employees LIMIT 5;"
},
  {
  "title": "SQL SELECT DISTINCT",
  "note": "The SELECT DISTINCT statement retrieves unique values from one or more columns, removing duplicate entries. It's useful for finding all different values in a column, such as unique departments, categories, or user roles.",
  "code": "-- Select distinct values from a single column\nSELECT DISTINCT department FROM employees;\n\n-- Select distinct combinations of multiple columns\nSELECT DISTINCT department, job_title FROM employees;\n\n-- Use DISTINCT with a WHERE clause\nSELECT DISTINCT department FROM employees WHERE location = 'New York';"
},
  {
  "title": "SQL WHERE Clause",
  "note": "The WHERE clause is used to filter records in a table based on specified conditions. You can use comparison operators, logical operators, and pattern matching to refine your queries and retrieve only the desired rows.",
  "code": "-- Filter using equality\nSELECT * FROM employees WHERE department = 'Sales';\n\n-- Filter using inequality\nSELECT * FROM employees WHERE salary > 50000;\n\n-- Filter using multiple conditions with AND / OR\nSELECT * FROM employees WHERE department = 'Sales' AND salary > 50000;\n\n-- Filter using pattern matching\nSELECT * FROM employees WHERE name LIKE 'A%';\n\n-- Filter using IN / NOT IN\nSELECT * FROM employees WHERE department IN ('Sales', 'HR');"
},
{
  "title": "SQL ORDER BY",
  "note": "The ORDER BY clause is used to sort the result set by one or more columns in ascending (ASC) or descending (DESC) order. It helps organize query results for readability and reporting.",
  "code": "-- Sort by a single column ascending\nSELECT * FROM employees ORDER BY last_name ASC;\n\n-- Sort by a single column descending\nSELECT * FROM employees ORDER BY salary DESC;\n\n-- Sort by multiple columns\nSELECT * FROM employees ORDER BY department ASC, salary DESC;\n\n-- Combine ORDER BY with WHERE clause\nSELECT * FROM employees WHERE department = 'Sales' ORDER BY salary DESC;"
},
  {
  "title": "SQL AND Operator",
  "note": "The AND operator combines multiple conditions in a WHERE clause. All conditions must be true for a record to be included in the result set, allowing precise filtering of data.",
  "code": "-- Using AND to filter by department and city\nSELECT * FROM employees WHERE department = 'Sales' AND city = 'London';\n\n-- Combining multiple AND conditions\nSELECT * FROM employees WHERE department = 'Sales' AND city = 'London' AND salary > 50000;\n\n-- Using AND with other operators\nSELECT * FROM employees WHERE department = 'Sales' AND salary BETWEEN 40000 AND 60000;"
},
  {
  "title": "SQL OR Operator",
  "note": "The OR operator allows you to filter records based on multiple conditions, where at least one of the conditions must be true. It's useful for broadening query results when multiple possibilities are acceptable.",
  "code": "-- Using OR to filter by department\nSELECT * FROM employees WHERE department = 'Sales' OR department = 'HR';\n\n-- Combining OR with other conditions\nSELECT * FROM employees WHERE department = 'Sales' OR salary > 60000;\n\n-- Using OR with AND for complex conditions\nSELECT * FROM employees WHERE (department = 'Sales' OR department = 'HR') AND city = 'London';"
},
  {
  "title": "SQL NOT Operator",
  "note": "The NOT operator negates a condition in a WHERE clause, returning records that do not match the specified criteria. It's useful for excluding certain values from query results.",
  "code": "-- Using NOT to exclude a department\nSELECT * FROM employees WHERE NOT department = 'HR';\n\n-- Using NOT with other conditions\nSELECT * FROM employees WHERE NOT (department = 'HR' OR city = 'London');\n\n-- Combining NOT with comparison operators\nSELECT * FROM employees WHERE NOT salary < 50000;"
},
{
  "title": "SQL INSERT INTO",
  "note": "The INSERT INTO statement is used to add new rows of data into a table. You can specify the columns and corresponding values to ensure data is correctly inserted.",
  "code": "-- Insert a single record\nINSERT INTO employees (first_name, last_name, department) VALUES ('John', 'Doe', 'IT');\n\n-- Insert multiple records at once\nINSERT INTO employees (first_name, last_name, department) VALUES \n('Alice', 'Smith', 'HR'),\n('Bob', 'Brown', 'Sales');\n\n-- Insert using a SELECT statement from another table\nINSERT INTO employees_backup (first_name, last_name, department) \nSELECT first_name, last_name, department FROM employees;"
},
{
  "title": "SQL NULL Values",
  "note": "NULL represents missing or unknown data in a database. Use IS NULL to find records with missing values and IS NOT NULL to find records with existing values.",
  "code": "-- Select records where manager_id is NULL\nSELECT * FROM employees WHERE manager_id IS NULL;\n\n-- Select records where manager_id is NOT NULL\nSELECT * FROM employees WHERE manager_id IS NOT NULL;\n\n-- Using NULL in combination with other conditions\nSELECT * FROM employees WHERE department = 'IT' AND manager_id IS NULL;"
},
  {
  "title": "SQL UPDATE Statement",
  "note": "The UPDATE statement modifies existing records in a table. You can change one or more columns for specific rows by using the WHERE clause to target the correct records.",
  "code": "-- Update a single column for a specific employee\nUPDATE employees SET department = 'Marketing' WHERE employee_id = 3;\n\n-- Update multiple columns for a specific employee\nUPDATE employees SET department = 'Marketing', salary = 60000 WHERE employee_id = 3;\n\n-- Update all records (use with caution)\nUPDATE employees SET department = 'General';\n\n-- Combine UPDATE with conditions\nUPDATE employees SET salary = salary * 1.1 WHERE department = 'Sales';"
},
  {
    "title": "SQL Delete Statement: Permanently Removing Data",
    "note": "The DELETE command is a fundamental Data Manipulation Language (DML) operation used to permanently remove existing records from a database table. This is a destructive operation that modifies the database's state. Extreme caution must be exercised when using this command. The WHERE clause is absolutely critical—it specifies which records to remove. Omitting the WHERE clause will result in every single record in the table being deleted, which is often a catastrophic error. Always verify the target records with a SELECT statement using the same WHERE conditions before executing the delete. Be mindful of foreign key constraints and referential integrity, as attempting to delete a record referenced by another table will cause an error unless ON DELETE CASCADE is set. For safety, perform deletions within a transaction to allow for a rollback if necessary.",
    "code": "DELETE FROM employees WHERE employee_id = 5;"
  },
  {
    "title": "SQL Select Top",
    "note": "The SELECT TOP clause is used to specify the number of records to return from the top of a result set. This is particularly useful for large tables when you only need to sample data or retrieve a limited subset of records for performance reasons. The clause is specific to Microsoft SQL Server and Sybase databases. Other database systems use different syntax for similar functionality, such as LIMIT in MySQL and PostgreSQL, or ROWNUM in Oracle.",
    "code": "SELECT TOP 5 * FROM employees;"
},
  {
    "title": "SQL Aggregate Functions",
    "note": "Aggregate functions perform a calculation on a set of values, typically across multiple rows grouped by a common attribute, and return a single summarized value. They are essential for data analysis and reporting, allowing you to compute metrics like averages, totals, counts, and extremes. Common aggregate functions include COUNT(), SUM(), AVG(), MIN(), and MAX(). These functions ignore NULL values in their calculations, except for COUNT(*). They are most powerful when used with the GROUP BY clause to calculate values for different groups within the data, and the HAVING clause can filter the results of these aggregations.",
    "code": "SELECT AVG(salary) AS avg_salary FROM employees;"
},
  {
    "title": "SQL Min and Max Functions",
    "note": "The MIN() and MAX() functions are essential aggregate functions used to find the smallest (minimum) and largest (maximum) values in a specified column, respectively. These functions are invaluable for data analysis, providing quick insights into the range and boundaries of numerical, date, or even string data. They operate by scanning all values in the column, ignoring NULL entries, and returning a single summary value. They are commonly used for financial analysis (e.g., highest/lowest sale), performance monitoring (e.g., fastest/slowest response time), and data quality checks to understand the distribution of values in a dataset.",
    "code": "SELECT MIN(salary) AS min_salary, MAX(salary) AS max_salary FROM employees;"
},
  {
    "title": "SQL Count Function",
    "note": "The COUNT() function is a fundamental aggregate function that returns the number of rows that match a specified condition. It is primarily used to determine the volume of data, such as the total number of records in a table, the number of records that meet certain criteria, or the number of distinct values in a column. The function has several forms: COUNT(*) counts all rows in the result set, including those with NULL values; COUNT(column_name) counts the number of non-NULL values in a specific column; and COUNT(DISTINCT column_name) counts the number of unique, non-NULL values. It is an indispensable tool for data analysis, reporting, and validating data integrity.",
    "code": "SELECT COUNT(*) AS total_employees FROM employees;"
},
  {
    "title": "SQL Sum Function",
    "note": "The SUM() function is an aggregate function that calculates the total sum of all values in a specified numeric column. It is a fundamental tool for financial analysis, reporting, and data summarization, allowing you to quickly determine cumulative values such as total revenue, total expenses, or overall inventory quantity. The function operates by adding together all non-NULL values in the column; NULL values are treated as zero and do not contribute to the result. It is most powerful when combined with the GROUP BY clause to calculate subtotals for different categories or groups within the data, providing a hierarchical view of summarized information.",
    "code": "SELECT SUM(salary) AS total_salary FROM employees;"
},
  {
    "title": "SQL Average (AVG) Function",
    "note": "The AVG() function is an aggregate function that calculates the arithmetic mean, or average, of a set of values in a specified numeric column. It provides a central value that represents the typical value in a dataset by summing all non-NULL values and dividing by the count of those values. This function is essential for statistical analysis, performance benchmarking, and data reporting, offering insights into trends and distributions. It is important to note that AVG() ignores NULL values entirely; they are not counted in the numerator or denominator. The function is commonly used with GROUP BY to compare averages across different categories or segments, and can be combined with WHERE to average a filtered subset of data.",
    "code": "SELECT AVG(salary) AS avg_salary FROM employees;"
},
  {
    "title": "SQL Like Operator",
    "note": "The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. It is essential for performing partial string matches and wildcard searches when exact matches are not known or required. Two wildcards are commonly used with LIKE: the percent sign (%) represents zero, one, or multiple characters, while the underscore (_) represents exactly one character. This allows for flexible pattern matching, such as finding all names starting with a specific letter, containing a certain substring, or following a particular character structure. The operator is case-insensitive in many database systems (like MySQL), but case-sensitive in others (like PostgreSQL), so understanding your database's collation is important. For more complex patterns, LIKE can be combined with other operators using AND/OR.",
    "code": "SELECT * FROM employees WHERE first_name LIKE 'J%';"
},
  {
    "title": "SQL Wildcards",
    "note": "Wildcards are special characters used with the SQL LIKE operator to perform flexible and powerful pattern matching on text data. They allow you to search for values that match a specific pattern rather than an exact string, which is invaluable for filtering, searching, and data cleaning operations. The percent sign (%) wildcard matches any sequence of zero or more characters, effectively serving as a multi-character placeholder. The underscore (_) wildcard matches exactly one arbitrary character, acting as a single-character placeholder. These wildcards can be used at the beginning, middle, or end of a search pattern. For instance, searching for patterns containing literal wildcard characters requires escaping them with a specified escape character to treat them as regular characters instead of metacharacters.",
    "code": "SELECT * FROM employees WHERE first_name LIKE '_a%';"
},
 {
    "title": "SQL IN Operator",
    "note": "The IN operator is a logical operator used in a WHERE clause to specify multiple possible values for a column, providing a concise and efficient alternative to multiple OR conditions. It checks if a value matches any value in a provided list of values, which can be a set of literal values (as shown in the code) or the result of a subquery (a SELECT statement nested within the IN clause). This operator significantly improves query readability and maintainability, especially when filtering against a long list of values. It is functionally equivalent to multiple OR conditions but is generally more performant and easier to write. The list can contain numbers, strings, or dates, and using NOT IN allows you to exclude records matching any value in the list.",
    "code": "SELECT * FROM employees WHERE department IN ('Sales', 'Marketing');"
},
  {
    "title": "SQL BETWEEN Operator",
    "note": "The BETWEEN operator is a logical operator used in a WHERE clause to filter results within a specified range, inclusive of the boundary values. It is a concise and readable alternative to using two conditions joined by AND (e.g., `value >= low_range AND value <= high_range`). The operator works with numerical values, dates, and text, making it versatile for various data types. For numbers, it defines a numerical interval; for dates, a date range; and for text, an alphabetic range. It is important to remember that the range is inclusive, meaning the boundary values themselves are included in the result set. The NOT BETWEEN operator can be used to exclude values within a specific range. This operator enhances query clarity and is particularly useful for financial data, date filters, and any scenario requiring range-based selection.",
    "code": "SELECT * FROM employees WHERE salary BETWEEN 3000 AND 5000;"
},
  {
    "title": "SQL Aliases",
    "note": "SQL aliases are temporary names assigned to a table or a column within a query to improve readability and presentation of the result set. Column aliases, created using the AS keyword (which is often optional), provide more descriptive or concise headers for output, especially when using functions or expressions. Table aliases, typically shorter abbreviations, are used to simplify queries when working with multiple tables, particularly in JOIN operations, making the SQL statement more concise and easier to read and maintain. Aliases exist only for the duration of the query and do not permanently rename database objects. They are essential for organizing complex queries, handling ambiguous column names, and formatting output for reports or application interfaces.",
    "code": "SELECT first_name AS fname, last_name AS lname FROM employees;"
},
  {
    "title": "SQL Joins",
    "note": "SQL Joins are fundamental operations used to combine rows from two or more tables based on a related column between them, enabling the querying of data that is spread across multiple tables in a relational database. The primary types include INNER JOIN, which returns records that have matching values in both tables; LEFT (OUTER) JOIN, which returns all records from the left table and matched records from the right table (with NULLs for non-matches); RIGHT (OUTER) JOIN, which returns all records from the right table and matched records from the left; and FULL (OUTER) JOIN, which returns all records when there is a match in either left or right table. Joins are essential for normalised databases, allowing for complex queries that relate data, reduce redundancy, and maintain data integrity. The ON clause specifies the condition for the join, typically matching foreign keys to primary keys.",
    "code": "SELECT employees.name, departments.department_name FROM employees INNER JOIN departments ON employees.dept_id = departments.id;"
},
 {
    "title": "SQL Inner Join",
    "note": "An INNER JOIN is the most common type of join operation in SQL, used to return only the rows from both tables where there is a match based on the specified join condition. It effectively creates a new result set by combining columns from two tables, including only the records that satisfy the condition, typically the equivalence of a foreign key in one table to a primary key in another. Rows from either table that do not have a corresponding match in the other table are excluded from the result set. This join is fundamental for querying related data across normalized tables, ensuring that only relevant, connected information is retrieved. It is the default type of JOIN in many SQL dialects, so using just the keyword JOIN typically implies an INNER JOIN.",
    "code": "SELECT * FROM orders INNER JOIN customers ON orders.customer_id = customers.customer_id;"
},
  {
    "title": "SQL Left Join",
    "note": "A LEFT JOIN (or LEFT OUTER JOIN) is a type of join operation that returns all records from the left table (the first table specified), and the matched records from the right table (the second table). If there is no match found in the right table for a given row in the left table, the result set will still include the left table's row, but with NULL values in every column from the right table. This is particularly useful for identifying records in one table that lack corresponding entries in another, such as finding customers who have never placed an order or products that have never been sold. It preserves the complete dataset from the primary (left) table while appending related information where it exists, making it essential for comprehensive reports and analyses that require inclusive data from a primary source.",
    "code": "SELECT * FROM customers LEFT JOIN orders ON customers.customer_id = orders.customer_id;"
},
  {
    "title": "SQL Right Join",
    "note": "A RIGHT JOIN (or RIGHT OUTER JOIN) is a type of join operation that returns all records from the right table (the second table specified), and the matched records from the left table (the first table). If there is no match found in the left table for a given row in the right table, the result set will still include the right table's row, but with NULL values in every column from the left table. This join is functionally equivalent to a LEFT JOIN with the table order reversed, but it is less commonly used in practice as most queries can be written more intuitively using LEFT JOIN by switching the table order. It can be useful for emphasizing the completeness of the right table's data, such as finding all orders regardless of whether their customer record still exists, or identifying orphaned records in a foreign key relationship from the referencing table's perspective.",
    "code": "SELECT * FROM customers RIGHT JOIN orders ON customers.customer_id = orders.customer_id;"
},
  {
    "title": "SQL Full Join",
    "note": "A FULL JOIN (or FULL OUTER JOIN) is a type of join operation that returns all records when there is a match in either the left table or the right table. It combines the results of both LEFT and RIGHT joins, creating a result set that includes all rows from both tables. Where rows match based on the join condition, they are combined into a single row. For rows that do not have a match in the other table, the result set will include the row with NULL values in the columns from the table that lacks a matching record. This join is particularly useful for comprehensive data analysis where you need to see all possible records from both tables, identify matching pairs, and also highlight which records exist in one table but not the other. It's commonly used for data reconciliation, finding unmatched records on both sides, and merging datasets while preserving all information.",
    "code": "SELECT * FROM customers FULL OUTER JOIN orders ON customers.customer_id = orders.customer_id;"
},
  {
    "title": "SQL Self Join",
    "note": "A self join is a regular join operation where a table is joined with itself. This technique is used to query hierarchical data or compare rows within the same table. It requires using table aliases to treat the same table as two distinct entities in the query, allowing you to establish a relationship between different rows. Common use cases include finding relationships within a table such as employee-manager hierarchies (where both employee and manager records exist in the same employees table), identifying duplicate records, or finding pairs of rows that meet certain conditions. The join can be implemented as an INNER JOIN to find only matching pairs or as a LEFT JOIN to include rows that might not have a corresponding match (e.g., top-level managers with no superior).",
    "code": "SELECT a.employee_name AS employee, b.employee_name AS manager FROM employees a INNER JOIN employees b ON a.manager_id = b.employee_id;"
},
  {
    "title": "SQL Union",
    "note": "The UNION operator is used to combine the result sets of two or more SELECT statements into a single result set. It automatically removes duplicate rows between the various SELECT statements, ensuring that only distinct rows are returned. Each SELECT statement within the UNION must have the same number of columns, and the corresponding columns must have compatible data types. The column names in the final result set are taken from the first SELECT statement. UNION is particularly useful for aggregating data from different tables or queries that have similar structures, such as combining customer and supplier lists, merging historical data from multiple sources, or creating comprehensive reports from segmented datasets. For scenarios where duplicate rows should be retained, the UNION ALL operator is used instead, which offers better performance as it does not require duplicate elimination.",
    "code": "SELECT city FROM customers UNION SELECT city FROM suppliers;"
},
  {
    "title": "SQL Union All",
    "note": "The UNION ALL operator is used to combine the result sets of two or more SELECT statements into a single result set, including all duplicate rows. Unlike the standard UNION operator, which performs a distinct operation to eliminate duplicates, UNION ALL preserves every row from each participating query, making it faster and more efficient when duplicate retention is desired or when duplicates are not possible. Each SELECT statement within the UNION ALL must have the same number of columns, and the corresponding columns must have compatible data types. This operator is particularly valuable for performance-critical operations, aggregating non-overlapping datasets where duplicates are not a concern, or when you need to preserve all records from multiple sources for complete data assembly, such as combining log entries, merging transaction histories, or appending datasets from different time periods without loss of information.",
    "code": "SELECT city FROM customers UNION ALL SELECT city FROM suppliers;"
},
{
    "title": "SQL Group By",
    "note": "The GROUP BY clause is a powerful SQL statement used to group rows that have identical values in specified columns into summary rows, enabling the application of aggregate functions (such as COUNT(), SUM(), AVG(), MAX(), MIN()) to each group individually. It transforms detailed data into meaningful summarized information by collapsing multiple rows into single rows per distinct group. The clause is essential for generating reports, performing statistical analysis, and understanding data distributions across different categories. It is often used in conjunction with the HAVING clause, which filters groups based on aggregate conditions (unlike WHERE, which filters individual rows). All selected non-aggregated columns must be included in the GROUP BY clause, ensuring each row in the result set represents a unique combination of the grouped columns.",
    "code": "SELECT department, COUNT(*) AS total FROM employees GROUP BY department;"
},
 {
    "title": "SQL Having Clause",
    "note": "The HAVING clause is used in SQL to filter groups of rows created by the GROUP BY clause based on the result of aggregate functions. Unlike the WHERE clause, which filters rows before any aggregation takes place, the HAVING clause applies conditions after the aggregation has occurred. This makes it essential for including or excluding entire groups from the final result set based on computed values such as counts, sums, averages, minimums, or maximums. It is particularly useful for identifying groups that meet specific statistical criteria, such as departments with more than a certain number of employees, customers with total purchases above a threshold, or categories with average values within a desired range. The HAVING clause can reference aggregate functions and aliases defined in the SELECT statement, providing powerful post-aggregation filtering capabilities.",
    "code": "SELECT department, COUNT(*) AS total FROM employees GROUP BY department HAVING COUNT(*) > 5;"
},
  {
    "title": "SQL Exists Operator",
    "note": "The EXISTS operator is a logical operator used in a WHERE clause to test for the existence of any rows in a subquery. It returns TRUE if the subquery returns one or more records, and FALSE if the subquery returns no records. This operator is commonly used to filter rows from a main query based on whether a related record exists in another table, making it particularly useful for correlated subqueries where the subquery references columns from the outer query. Unlike IN or JOIN operations which can return large result sets, EXISTS is often more efficient because it stops processing as soon as it finds the first matching row. It is ideal for checking relationships between tables, such as finding customers who have placed at least one order, or products that have been purchased. The actual columns selected in the subquery are irrelevant, as EXISTS only cares about whether any row is returned.",
    "code": "SELECT * FROM customers WHERE EXISTS (SELECT 1 FROM orders WHERE customers.customer_id = orders.customer_id);"
},
  {
    "title": "SQL Any and All Operators",
    "note": "The ANY and ALL operators are used in SQL to compare a scalar value to a set of values returned by a subquery. The ANY operator returns true if the comparison is true for at least one of the values in the subquery result set, effectively behaving like an existential quantifier. The ALL operator returns true only if the comparison is true for every single value in the subquery result set, acting as a universal quantifier. These operators are particularly useful when you need to compare a value against a dynamic list of values that isn't known until runtime. They are commonly used with comparison operators (=, <>, >, >=, <, <=) to perform complex conditional checks that would otherwise require multiple OR conditions (for ANY) or multiple AND conditions (for ALL). The operators are essential for scenarios involving hierarchical comparisons, outlier detection, and set-based logic that depends on complete subquery results.",
    "code": "SELECT * FROM products WHERE price > ALL (SELECT price FROM products WHERE category = 'Electronics');"
},
  {
    "title": "SQL Select Into",
    "note": "The SELECT INTO statement is used to copy data from one table and insert it into a new table. This operation creates the new table automatically based on the column definitions and data types of the source table, and then populates it with the result set of the SELECT query. It is commonly used for creating backups of tables, archiving specific data subsets, or creating temporary working copies of data for testing and development purposes without affecting the original dataset. The new table will not inherit constraints like primary keys, foreign keys, or indexes from the original table unless explicitly defined afterwards. The statement can also be used with a WHERE clause to copy only a subset of rows, or with specific column selections to create a table with a modified schema. It is important to note that the syntax and support for SELECT INTO may vary between different SQL database systems, with some (like MySQL) requiring alternative approaches such as CREATE TABLE AS.",
    "code": "SELECT * INTO new_table FROM old_table;"
},
 {
    "title": "SQL Insert Into Select",
    "note": "The INSERT INTO SELECT statement is used to copy data from one table and insert it into an existing table. This operation requires that the target table already exists and that the data types of the source and target columns are compatible. It is commonly used for archiving specific data subsets, migrating data between tables, aggregating data from multiple sources into a summary table, or populating tables with filtered or transformed data. The statement can include a WHERE clause to copy only a subset of rows that meet certain conditions, and the column order in the SELECT statement must match the column order of the target table unless columns are explicitly specified in both the INSERT and SELECT parts. Unlike SELECT INTO, this statement does not create a new table but instead adds data to an existing table structure, making it essential for data maintenance, ETL processes, and database population operations.",
    "code": "INSERT INTO archive_table SELECT * FROM main_table WHERE year = 2024;"
  },
  {
    "title": "SQL Case Expression",
    "note": "The CASE expression is SQL's primary mechanism for implementing conditional logic within queries, allowing for if-then-else style operations directly in SELECT, WHERE, ORDER BY, and other clauses. It evaluates conditions sequentially and returns a value when the first condition is met. If no conditions are met, it returns the value in the ELSE clause (or NULL if no ELSE is specified). There are two forms: the simple CASE form which compares an expression to a set of simple values, and the searched CASE form which evaluates Boolean expressions. This expression is invaluable for data categorization, value transformation, conditional aggregation, and dynamic formatting of result sets without needing application-level processing. It enables complex business logic implementation directly in the database layer for calculated columns, conditional ordering, and sophisticated filtering scenarios.",
    "code": "SELECT order_id, CASE WHEN quantity > 10 THEN 'Bulk' ELSE 'Small' END AS order_type FROM orders;"
  },
  {
    "title": "SQL Null Functions",
    "note": "NULL functions are specialized SQL functions designed to handle NULL values effectively in database operations. The COALESCE function returns the first non-NULL value from a list of arguments, making it ideal for providing default values when data might be missing. The ISNULL function (specific to SQL Server) replaces NULL with a specified replacement value. The NULLIF function returns NULL if two expressions are equal, otherwise returns the first expression. The NVL function (in Oracle) serves a similar purpose as ISNULL. These functions are essential for data cleansing, preventing arithmetic errors with NULL values, ensuring meaningful display outputs, and maintaining data integrity in calculations and comparisons. They help transform incomplete data into usable information by providing sensible defaults and handling missing values gracefully in queries, reports, and application interfaces.",
    "code": "SELECT COALESCE(phone, 'No Phone') AS contact_number FROM customers;"
  },
  {
    "title": "SQL Stored Procedures",
    "note": "A stored procedure is a precompiled collection of SQL statements and optional control-of-flow statements stored under a name and processed as a unit within the database management system. They are stored in the database data dictionary and provide numerous advantages including improved performance due to precompilation and execution plan caching, reduced network traffic as multiple operations can be executed with a single call, enhanced security through granular permission control, and better code maintainability and reusability. Stored procedures can accept input parameters, return output parameters, contain programming constructs like variables and conditional logic, and return result sets. They are essential for implementing complex business logic at the database level, data validation, and ensuring consistent application of database operations across different applications and interfaces.",
    "code": "CREATE PROCEDURE GetAllEmployees AS BEGIN SELECT * FROM employees; END;"
  },
  {
    "title": "SQL Comments",
    "note": "Comments in SQL are non-executable annotations used to document and explain SQL code, making it more readable and maintainable for developers and database administrators. Single-line comments start with two hyphens (--) and continue to the end of the line, while multi-line comments are enclosed between /* and */ and can span multiple lines. Comments are essential for describing the purpose of complex queries, explaining business logic, documenting assumptions, providing usage examples, and temporarily disabling code during testing and debugging without deleting it. Proper commenting improves code collaboration, facilitates knowledge transfer, and helps future maintainers understand the intent and functionality of the SQL statements, especially in large database systems with complex stored procedures, functions, and triggers.",
    "code": "-- This is a single-line comment retrieving all employees\n/* This is a multi-line comment\n   explaining a complex query */\nSELECT * FROM employees;"
  },
  {
    "title": "SQL Operators",
    "note": "SQL operators are symbols or keywords used to perform operations on data values and are fundamental components of SQL expressions, particularly in WHERE clauses, JOIN conditions, and calculated columns. Comparison operators (=, <>, !=, >, <, >=, <=) evaluate relationships between expressions. Arithmetic operators (+, -, *, /, %) perform mathematical calculations. Logical operators (AND, OR, NOT, IN, BETWEEN, LIKE, EXISTS) combine or negate Boolean conditions. Concatenation operators (|| or + depending on DBMS) join strings. Set operators (UNION, INTERSECT, EXCEPT) combine result sets. These operators enable filtering, comparison, calculation, and data manipulation directly within SQL queries, forming the foundation of conditional logic, data retrieval criteria, and expression evaluation in database operations.",
    "code": "SELECT * FROM employees WHERE salary >= 5000 AND department = 'Sales';"
  },
  {
    "title": "SQL Create Database",
    "note": "The CREATE DATABASE statement is a Data Definition Language (DDL) command used to create a new, empty database within the database management system. This command establishes a new container for database objects such as tables, views, stored procedures, and other schema elements. The statement can include optional parameters to specify database properties such as file locations, initial size, maximum size, growth increments, and collation settings, though the exact syntax and available options vary between database systems like MySQL, SQL Server, PostgreSQL, and Oracle. Creating a database is typically a privileged operation requiring appropriate permissions and is fundamental to database administration, application deployment, and data architecture planning. The new database remains empty until tables and other objects are created within it.",
    "code": "CREATE DATABASE my_database;"
  },
  {
    "title": "SQL Drop Database",
    "note": "The DROP DATABASE statement is a Data Definition Language (DDL) command used to permanently delete an existing database and all its associated files from the database management system. This operation removes the entire database schema, including all tables, views, stored procedures, functions, and other objects, along with all contained data. It is an irreversible operation that typically requires high-level administrative privileges. Most database systems prevent the dropping of a database while users are connected to it, and some may require the database to be in a single-user mode first. The DROP DATABASE command is used during database cleanup, environment resets, testing scenarios, and when decommissioning obsolete systems. Extreme caution must be exercised as this operation results in complete and permanent data loss for the specified database.",
    "code": "DROP DATABASE my_database;"
  },
  {
    "title": "SQL Backup Database",
    "note": "The BACKUP DATABASE command is a critical administrative operation that creates a complete copy of a database's data and schema, preserving it in a separate file for recovery purposes. This process captures the entire database state at a specific point in time, including all tables, views, stored procedures, and data. Database backups are essential for disaster recovery, data protection, and migration scenarios. They can be full backups (complete copy), differential backups (changes since last full backup), or transaction log backups (sequential transaction records). The backup file can be stored on disk, tape, or cloud storage. Regular backups are a fundamental part of database maintenance, ensuring business continuity and data integrity in case of system failures, corruption, or accidental data loss. Restoration from backup allows the database to be recovered to its state at the time the backup was created.",
    "code": "BACKUP DATABASE my_database TO DISK = 'C:/backup/my_database.bak';"
  },
  {
    "title": "SQL Create Table",
    "note": "The CREATE TABLE statement is a fundamental Data Definition Language (DDL) command used to define a new table structure within a database. It specifies the table name, column definitions (including column names, data types, and constraints), and optional table properties. Each column definition includes a data type (such as INT, VARCHAR, DATE, DECIMAL) that determines the kind of data it can store, and may include constraints to enforce data integrity rules. The statement may also define primary keys, foreign keys, indexes, and other table-level constraints. Creating a table establishes the blueprint for data storage, organizing information into rows and columns. Proper table design is crucial for database performance, data integrity, and efficient data retrieval through SQL queries.",
    "code": "CREATE TABLE employees (id INT, name VARCHAR(50), department VARCHAR(50));"
  },
  {
    "title": "SQL Drop Table",
    "note": "The DROP TABLE statement is a Data Definition Language (DDL) command that permanently deletes an existing table and all its data from the database. This operation removes the table structure, all rows, indexes, triggers, constraints, and permissions associated with the table. It is an irreversible action that cannot be undone without a database backup. The command typically requires appropriate permissions and may fail if the table is referenced by foreign key constraints in other tables or if there are active dependencies. Some database systems offer optional clauses like CASCADE to automatically drop dependent objects. This command is used during database schema changes, cleanup operations, testing environments, and when decommissioning obsolete data structures, but should be used with extreme caution in production environments.",
    "code": "DROP TABLE employees;"
  },
  {
    "title": "SQL Alter Table",
    "note": "The ALTER TABLE statement is a Data Definition Language (DDL) command used to modify the structure of an existing table without requiring the table to be dropped and recreated. This powerful command allows database administrators and developers to evolve the database schema over time to meet changing requirements. Common operations include adding new columns, dropping existing columns, modifying column data types or constraints, adding or removing constraints (primary keys, foreign keys, unique constraints), and renaming columns or tables. Unlike DROP and CREATE approaches, ALTER TABLE preserves existing data in the table while making structural changes. This makes it essential for database maintenance, application updates, and schema migrations in production environments where data preservation is critical.",
    "code": "ALTER TABLE employees ADD email VARCHAR(100);"
  },
  {
    "title": "SQL Constraints",
    "note": "SQL constraints are rules enforced on data columns in database tables to maintain data integrity, accuracy, and reliability. They ensure that data meets specific criteria before being inserted or updated in the database. Primary key constraints uniquely identify each record and prevent duplicate values. Foreign key constraints maintain referential integrity by linking columns between tables. Unique constraints ensure all values in a column are distinct. Check constraints validate that values meet specified conditions. Not null constraints prevent null values in a column. Default constraints provide a default value when none is specified. These constraints are essential for enforcing business rules at the database level, preventing invalid data entry, and maintaining consistent relationships between tables, thereby ensuring the overall quality and reliability of the database content.",
    "code": "CREATE TABLE employees (id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, department_id INT FOREIGN KEY REFERENCES departments(id));"
  },
  {
    "title": "SQL Not Null Constraint",
    "note": "The NOT NULL constraint is a fundamental column-level constraint that ensures a column cannot contain NULL values, meaning every row must have a value for that column. This constraint is crucial for enforcing data completeness and integrity by preventing missing or unknown values in critical fields. It is commonly applied to columns that serve as identifiers, mandatory attributes, or key business data points. When inserting or updating records, the database system will reject any operation that attempts to set a NOT NULL column to NULL. This constraint helps maintain data quality, prevents errors in applications that assume certain fields will always have values, and ensures that essential information is always captured. It is often used in combination with other constraints like PRIMARY KEY or UNIQUE to create robust data validation rules.",
    "code": "CREATE TABLE products (id INT NOT NULL, name VARCHAR(50) NOT NULL, description TEXT);"
  },
  {
    "title": "SQL Unique",
    "note": "Ensures all values in a column are unique. Prevents duplicate entries in the specified column. NULL values are typically allowed (multiple NULLs may be permitted unless combined with NOT NULL).",
    "code": "CREATE TABLE users (id INT PRIMARY KEY, email VARCHAR(100) UNIQUE);"
  },
  {
    "title": "SQL Primary Key",
    "note": "Uniquely identifies each row in a table. A table can have only one primary key, which must contain unique values and cannot contain NULL values. It often serves as a link to foreign keys in other tables.",
    "code": "CREATE TABLE students (id INT PRIMARY KEY, name VARCHAR(50));"
  },
  {
    "title": "SQL Foreign Key",
    "note": "Links rows in one table to rows in another table. Enforces referential integrity by ensuring the value exists in the referenced table's primary key (or a unique key). Prevents actions that would destroy links between tables.",
    "code": "CREATE TABLE orders (id INT PRIMARY KEY, customer_id INT, FOREIGN KEY (customer_id) REFERENCES customers(id));"
  },
  {
    "title": "SQL Check",
    "note": "Ensures a column's values meet a specific condition. Used to limit the value range that can be placed in a column. If not met, the record will not be inserted or updated.",
    "code": "CREATE TABLE products (id INT PRIMARY KEY, price DECIMAL CHECK (price > 0));"
  },
  {
    "title": "SQL Default",
    "note": "Sets a default value for a column when no value is explicitly provided during an insert operation. Useful for providing a standard, pre-defined value to simplify data entry and ensure consistency.",
    "code": "CREATE TABLE customers (id INT PRIMARY KEY, country VARCHAR(50) DEFAULT 'USA');"
  },
  {
    "title": "SQL Index",
    "note": "Improves query performance by creating a sorted data structure (index) that allows the database to find data faster without scanning the entire table. Ideal for columns frequently used in WHERE, JOIN, or ORDER BY clauses. Note: Indexes slow down data insertion and updating.",
    "code": "CREATE INDEX idx_lastname ON employees(last_name);"
  },
  {
    "title": "SQL Auto Increment",
    "note": "Automatically generates a unique, sequential number for a column whenever a new record is inserted. Often used for primary key columns to ensure each row has a unique identifier without manual input. Syntax varies by database (e.g., IDENTITY in SQL Server, AUTO_INCREMENT in MySQL, SERIAL in PostgreSQL).",
    "code": "CREATE TABLE employees (id INT IDENTITY(1,1) PRIMARY KEY, name VARCHAR(50));"
  },
  {
    "title": "SQL Dates",
    "note": "Stores and queries date and time values. SQL provides specific data types (like DATE, TIME, DATETIME, TIMESTAMP) and functions (e.g., GETDATE(), NOW(), DATE_ADD) to manipulate these values. Queries often filter or calculate based on date ranges.",
    "code": "SELECT * FROM orders WHERE order_date > '2024-01-01';"
  },
  {
    "title": "SQL Views",
    "note": "A virtual table based on the result-set of a SQL query. It does not store data physically but provides a simplified, specific, or secured way to look at the data in one or more underlying tables. Useful for hiding complex queries or restricting access to certain columns.",
    "code": "CREATE VIEW sales_summary AS SELECT product_id, SUM(quantity) AS total_sold FROM sales GROUP BY product_id;"
  },
  {
    "title": "SQL Injection",
    "note": "A critical security vulnerability where an attacker inserts or 'injects' malicious SQL code into a query. This can allow them to view, modify, or delete unauthorized data. Prevented by using parameterized queries (prepared statements) and never concatenating user input directly into SQL strings.",
    "code": "-- Avoid using string concatenation in SQL queries.\n-- Use parameterized queries instead.\n-- Example: SELECT * FROM users WHERE username = @userInput;"
  },
  {
    "title": "SQL Hosting",
    "note": "Run your SQL database on a remote or cloud server rather than locally. This provides benefits like scalability, high availability, automated backups, and managed maintenance. Popular options include cloud providers like AWS RDS, Google Cloud SQL, and Azure SQL Database, which handle infrastructure, security patches, and backups.",
    "code": "-- Example: MySQL on AWS RDS\n-- Typically configured through cloud provider's console/CLI\n-- Connection string: jdbc:mysql://my-database.123abc.us-west-2.rds.amazonaws.com:3306/mydb"
  },
  {
    "title": "SQL Data Types",
    "note": "Define the type of data a column can hold, ensuring data integrity and optimizing storage. Common types include: INT for integers, VARCHAR(n) for variable-length strings, CHAR(n) for fixed-length strings, DATE for dates without time, DATETIME/TIMESTAMP for date and time, DECIMAL/NUMERIC for precise numbers, and BOOLEAN for true/false values. Choosing the appropriate type is crucial for database efficiency.",
    "code": "CREATE TABLE sample (id INT, name VARCHAR(50), created_at DATE, price DECIMAL(10, 2), is_active BOOLEAN);"
  },
],
  Python : [
 {
    "title": "Python HOME",
    "note": "The main landing point for Python resources, documentation, and tutorials. This is the official starting hub managed by the Python Software Foundation, where users download interpreters, access the vast standard library, and find community links. It serves as the gateway for both beginners and experienced developers to stay updated with the latest versions, PEPs (Python Enhancement Proposals), and events.",
    "code": "print('Welcome to Python!')"
  },
  {
    "title": "Python Intro",
    "note": "Python is a high-level, interpreted programming language known for its readability and versatility. It supports multiple programming paradigms, including procedural, object-oriented, and functional programming. Its simple syntax emphasizes readability, thereby reducing the cost of program maintenance. The language comes with a large standard library and has a vibrant community that contributes to an extensive ecosystem of frameworks and tools.",
    "code": "print('Hello, Python!')"
  },
  {
    "title": "Python Get Started",
    "note": "Install Python, write your first program, and run it using the Python interpreter. Beginners should visit the official website to download the latest version for their operating system. After installation, verify it via the command line with 'python --version'. Use any text editor or IDE to write scripts, save them with a .py extension, and execute them from the terminal or within an integrated development environment.",
    "code": "# Save as hello.py\nprint('Welcome to Python!')"
  },
  {
    "title": "Python Syntax",
    "note": "Python uses indentation instead of curly braces to define code blocks. This enforces a clean and readable coding style. The standard convention is to use 4 spaces per indentation level. Incorrect indentation will raise an IndentationError and cause the program to fail.",
    "code": "if 5 > 2:\n    print('Five is greater than two!')\n    print('This is part of the if block')\nprint('This is outside the if block')"
  },
  {
    "title": "Python Comments",
    "note": "Use comments to explain your code. Single-line comments start with #. Multi-line comments can be written using triple quotes (''') but are technically string literals that aren't assigned to a variable. Comments are ignored by the Python interpreter and are essential for documentation and code maintenance.",
    "code": "# This is a single-line comment\n\n'''\nThis is a multi-line comment\noften used for docstrings.\nIt can span several lines.\n'''\n\nprint('Hello') # This is an inline comment"
  },
  {
    "title": "Python Variables",
    "note": "Variables store data values. You don’t need to declare a type before using them; Python is dynamically typed. A variable is created the moment you first assign a value to it. Variable names are case-sensitive and can contain letters, numbers, and underscores, but cannot start with a number.",
    "code": "name = 'Alice'  # Assigns a string\nscore = 100      # Assigns an integer\npercentage = 98.5 # Assigns a float\nis_valid = True  # Assigns a boolean\n\nprint(name)\nprint(score)"
  },
  {
    "title": "Python Data Types",
    "note": "Common built-in types include str (text), int (integer), float (decimal), bool (True/False), list (ordered, mutable sequence), tuple (ordered, immutable sequence), dict (key-value pairs), and set (unordered collection of unique elements). The type() function can be used to check the data type of any object.",
    "code": "age = 25                    # int\nprice = 19.99               # float\nname = \"Charlie\"            # str\nis_active = True            # bool\ncolors = ['red', 'blue']    # list\ncoordinates = (10, 20)      # tuple\nperson = {'name': 'Alice'}  # dict\nunique_ids = {1, 2, 3}      # set\n\nprint(type(age))  # Output: <class 'int'>"
  },
  {
    "title": "Python Numbers",
    "note": "Numbers can be integers (int), floating-point (float), or complex (complex). Integers are whole numbers of unlimited length. Floats are real numbers with a decimal point. Complex numbers have a real and imaginary part, denoted by 'j'. Python also supports arithmetic operations like addition, subtraction, multiplication, and division on these number types.",
    "code": "x = 10          # int\ny = -5          # negative int\npi = 3.14159    # float\ntemperature = -10.5  # negative float\nz = 2 + 3j      # complex number (2 is real part, 3j is imaginary)\n\n# Arithmetic operations\nsum = x + y         # 10 + (-5) = 5\nproduct = x * pi    # 10 * 3.14159 = 31.4159\n\nprint(sum)\nprint(product)"
  },
{
    "title": "Python Casting",
    "note": "Convert variables from one type to another using int(), float(), str(). This is essential when you need to ensure a variable is of a specific type for operations or when receiving input (which is always a string) that needs to be treated as a number. Be cautious, as converting non-numeric strings to numbers will raise a ValueError.",
    "code": "x = int(3.5)      # Converts float to int (truncates decimal part, result: 3)\ny = float('2.7')  # Converts numeric string to float (result: 2.7)\nz = str(123)      # Converts integer to string (result: '123')\n\n# Example with user input\nuser_input = input('Enter a number: ')  # Input is always a string\nnumber = int(user_input)  # Cast to integer for arithmetic\nresult = number * 2\nprint(result)"
  },
  {
    "title": "Python Strings",
    "note": "Strings are text enclosed in quotes and support many built-in methods. They are immutable sequences of Unicode characters, meaning once created, they cannot be changed. You can use single, double, or triple quotes. Triple quotes allow strings to span multiple lines. Strings support indexing, slicing, and a rich set of methods for manipulation, searching, and formatting.",
    "code": "greeting = 'Hello World'\nprint(greeting.upper())       # Converts to uppercase: 'HELLO WORLD'\nprint(greeting.lower())       # Converts to lowercase: 'hello world'\nprint(greeting.find('World')) # Returns index: 6\nprint(len(greeting))          # Returns length: 11\nprint(greeting[0:5])          # Slicing: 'Hello'\n\n# Multi-line string\nmulti_line = '''This is a\nstring that spans\nmultiple lines.'''\nprint(multi_line)"
  },
  {
    "title": "Python Booleans",
    "note": "Booleans represent True or False values. They are the result of comparison operations (like ==, >, <) and logical operations (and, or, not). In Python, many values can be evaluated in a Boolean context (truthy and falsy values). For example, empty sequences (like '', [], ()) are considered False, while non-empty ones are True. The bool() function can explicitly convert a value to a Boolean.",
    "code": "is_ready = True\nis_done = False\n\n# Comparison operations return booleans\nprint(5 > 3)   # True\nprint(5 == 3)  # False\n\n# Logical operations\nresult = is_ready and (5 > 3)  # True and True -> True\nprint(result)\n\n# Truthy/Falsy evaluation\nprint(bool('Hello'))  # True (non-empty string)\nprint(bool(''))       # False (empty string)\nprint(bool(0))        # False (zero)\nprint(bool(10))       # True (non-zero number)"
  },
  {
    "title": "Python Operators",
    "note": "Operators are symbols that perform operations on variables and values. Python has arithmetic operators (+, -, *, /, %, **, //), assignment operators (=, +=, -=, etc.), comparison operators (==, !=, >, <, >=, <=), logical operators (and, or, not), and identity/membership operators (is, is not, in, not in). Understanding operator precedence is crucial for writing correct expressions.",
    "code": "# Arithmetic\nsum_val = 5 + 3    # 8\nproduct = 5 * 3    # 15\nremainder = 7 % 3  # 1\nfloor_division = 7 // 3  # 2\n\n# Assignment\ncount = 5\ncount += 2  # Equivalent to count = count + 2 -> 7\n\n# Comparison\nis_equal = (5 == 3)      # False\nis_greater = (5 > 3)     # True\n\n# Logical\nlogical_and = (5 > 3) and (10 < 20)  # True\nlogical_or = (5 < 3) or (10 > 5)     # True\nlogical_not = not (5 == 5)           # False\n\n# Membership\nfruits = ['apple', 'banana']\nprint('apple' in fruits)  # True\nprint('cherry' not in fruits) # True"
  },
  {
    "title": "Python Lists",
    "note": "Lists are ordered, changeable collections of items. They are one of Python's most versatile and commonly used data structures. Items in a list are ordered (they maintain their insertion order), mutable (can be changed after creation), and allow duplicate values. Lists can contain items of different data types and are created using square brackets []. They support indexing, slicing, and a wide range of methods for manipulation.",
    "code": "fruits = ['apple', 'banana', 'cherry']\n\n# Access elements\nprint(fruits[0])   # 'apple' (first item, index 0)\nprint(fruits[-1])  # 'cherry' (last item, index -1)\n\n# Modify list\nfruits.append('orange')      # Adds to the end\nfruits.insert(1, 'mango')    # Inserts at index 1\nfruits[2] = 'blueberry'      # Replaces item at index 2\n\n# Remove items\nremoved_fruit = fruits.pop() # Removes and returns last item\nfruits.remove('banana')      # Removes first occurrence of 'banana'\n\nprint(fruits)  # Current state of the list\nprint(len(fruits))  # Number of items"
  },
  {
    "title": "Python Tuples",
    "note": "Tuples are ordered, unchangeable collections of items. They are similar to lists but are immutable, meaning once created, their elements cannot be added, removed, or changed. This makes them useful for storing data that should not be modified, such as constant values or records. Tuples are written with parentheses (). They are generally faster than lists and can be used as keys in dictionaries (unlike lists).",
    "code": "coordinates = (10, 20)  # A tuple with two integers\nperson = ('Alice', 25, 'Engineer')  # A tuple with mixed data types\n\n# Access elements (same as lists)\nprint(coordinates[0])  # 10\nprint(person[1])       # 25\n\n# Tuples are immutable - this would cause an error:\n# coordinates[0] = 15  # TypeError: 'tuple' object does not support item assignment\n\n# You can create a new tuple by concatenating existing ones\nnew_tuple = coordinates + (30,)\nprint(new_tuple)  # (10, 20, 30)\n\n# Single-item tuple requires a trailing comma\nsingle_item = (42,)\nprint(type(single_item))  # <class 'tuple'>"
  },
  {
    "title": "Python Sets",
    "note": "Sets are unordered collections with no duplicate items. They are mutable, meaning you can add and remove items, but the items themselves must be immutable (like numbers, strings, or tuples). Sets are optimized for membership testing (checking if an element is in the set) and mathematical set operations like union, intersection, difference, and symmetric difference. They are created using curly braces {} or the set() function.",
    "code": "colors = {'red', 'green', 'blue'}  # Create a set\n\n# Add items\ncolors.add('yellow')\ncolors.update(['orange', 'purple'])  # Add multiple items\n\n# Remove items\ncolors.remove('red')   # Raises KeyError if item doesn't exist\ncolors.discard('pink') # No error if item doesn't exist\n\n# Set operations\nset_a = {1, 2, 3, 4}\nset_b = {3, 4, 5, 6}\n\nprint(set_a | set_b)   # Union: {1, 2, 3, 4, 5, 6}\nprint(set_a & set_b)   # Intersection: {3, 4}\nprint(set_a - set_b)   # Difference: {1, 2}\n\n# Check membership\nprint('green' in colors)  # True"
  },
  {
    "title": "Python Dictionaries",
    "note": "Dictionaries store key-value pairs. They are unordered (until Python 3.7, where insertion order is preserved), mutable, and indexed by unique, immutable keys (usually strings, numbers, or tuples). Dictionaries are optimized for retrieving values when the key is known. They are incredibly flexible and are used to represent real-world data structures. Dictionaries are created with curly braces {} containing key:value pairs.",
    "code": "person = {'name': 'Alice', 'age': 25, 'occupation': 'Engineer'}\n\n# Access values\nprint(person['name'])        # 'Alice' - using key\nprint(person.get('age'))     # 25 - using get() method\nprint(person.get('city', 'Unknown'))  # 'Unknown' - default if key doesn't exist\n\n# Add or modify items\nperson['city'] = 'London'    # Add new key-value pair\nperson['age'] = 26           # Modify existing value\n\n# Remove items\nremoved_value = person.pop('occupation')  # Remove and return value\ndel person['city']           # Remove key-value pair\n\n# Loop through dictionary\nfor key, value in person.items():\n    print(f'{key}: {value}')\n\n# Check if key exists\nprint('name' in person)  # True"
  },
  {
    "title": "Python If...Else",
    "note": "Conditional statements execute code based on conditions. The if statement evaluates a condition and executes a block of code if the condition is True. You can add elif (short for 'else if') to check multiple conditions in sequence, and else to provide a default block that runs if all previous conditions are False. Proper indentation is crucial to define which code blocks belong to which condition.",
    "code": "age = 20\n\n# Basic if-elif-else structure\nif age >= 18:\n    print('You are an adult.')\nelif age >= 13:\n    print('You are a teenager.')\nelse:\n    print('You are a child.')\n\n# Nested if statements\nif age > 0:\n    if age < 120:\n        print('Valid age')\n    else:\n        print('Age is too high')\nelse:\n    print('Age cannot be negative')\n\n# Conditional expressions (ternary operator)\nstatus = 'Adult' if age >= 18 else 'Minor'\nprint(status)"
  },
  {
    "title": "Python Match",
    "note": "Match-case is a structural pattern matching feature (Python 3.10+). It provides a more powerful and readable alternative to long if-elif-else chains for comparing a value against multiple patterns. It can match against literal values, unpack sequences, check types, and use capture patterns. It's often described as switch-case on steroids and is incredibly useful for handling complex data structures and different cases cleanly.",
    "code": "status = 404\nmatch status:\n    case 200:\n        print('OK')\n    case 404:\n        print('Not Found')\n    case 500:\n        print('Server Error')\n    case _:  # The wildcard _ acts as a default case\n        print('Unknown status code')\n\n# Example with type checking and unpacking\ndef handle_command(command):\n    match command.split():\n        case ['exit']:\n            print('Exiting...')\n        case ['load', filename]:\n            print(f'Loading {filename}...')\n        case _:\n            print('Unknown command')"
  },
  {
    "title": "Python While Loops",
    "note": "Repeats a block of code while a condition is true. It's used when the number of iterations is not known beforehand and depends on a dynamic condition. It's crucial to include a statement that eventually makes the condition false to avoid creating an infinite loop. The `break` statement can exit the loop prematurely, and the `continue` statement skips the rest of the current iteration and jumps back to the condition check.",
    "code": "count = 0\nwhile count < 5:  # Condition checked before each iteration\n    print(count)\n    count += 1  # This increment is vital to avoid an infinite loop\n\n# Example with break and continue\nuser_input = ''\nwhile user_input.lower() != 'quit':\n    user_input = input('Enter a command (or \"quit\" to exit): ')\n    if user_input == '':\n        print('Please enter something.')\n        continue  # Skip the rest and ask again\n    print(f'You entered: {user_input}')\n    # The loop condition will check if it's 'quit' on the next iteration"
  },
  {
    "title": "Python For Loops",
    "note": "Iterates over the items of any sequence (like a list, tuple, string, or dictionary) or any other iterable object. It's the primary tool for definite iteration when you want to execute a block of code a specific number of times or for each element in a collection. The `range()` function is commonly used with for loops to generate a sequence of numbers. Like while loops, it supports `break` and `continue` statements for flow control.",
    "code": "for fruit in ['apple', 'banana', 'cherry']:  # Iterating over a list\n    print(f'I like {fruit}s')\n\nfor char in 'Hello':  # Iterating over a string\n    print(char)\n\n# Using range() for a numerical sequence\nfor i in range(5):  # Generates numbers from 0 to 4\n    print(i)\n\nfor i in range(2, 10, 2):  # Start at 2, up to (but not including) 10, step by 2\n    print(i)  # Prints 2, 4, 6, 8"
  },
  {
    "title": "Python Functions",
    "note": "Functions group reusable blocks of code. They are defined using the `def` keyword and allow you to break your program into smaller, modular, and manageable chunks. Functions can take parameters (inputs) and return values (outputs) using the `return` statement. Using functions avoids code duplication, improves readability, and makes code easier to test and maintain. Parameters can have default values, making them optional when calling the function.",
    "code": "def greet(name, greeting='Hello'):  # 'greeting' has a default value\n    \"\"\"This function greets the person passed in as a parameter.\"\"\"  # Docstring\n    return f'{greeting}, {name}!'\n\n# Calling the function\nmessage = greet('Alice')  # Uses default greeting\nprint(message)  # Output: Hello, Alice!\n\nmessage2 = greet('Bob', 'Good morning')\nprint(message2) # Output: Good morning, Bob!\n\n# Function with multiple returns\ndef check_even(num):\n    if num % 2 == 0:\n        return True, num**2  # Returning a tuple: (True, 4)\n    else:\n        return False, None\n\nis_even, square = check_even(2)  # Unpacking the returned tuple"
  },
  {
    "title": "Python Lambda",
    "note": "Lambda functions are small, anonymous functions defined with the `lambda` keyword. They can take any number of arguments but can only have one expression. They are not meant for complex logic but are perfect for short, throwaway functions often used as arguments to higher-order functions like `sorted()`, `map()`, `filter()`, or `reduce()`. Their syntax is `lambda arguments: expression`.",
    "code": "square = lambda x: x * x\nprint(square(4))  # Output: 16\n\n# Lambda is often used inline without assigning to a variable\n# Example with map(): Apply a function to every item in an iterable\nnumbers = [1, 2, 3, 4]\nsquared_list = list(map(lambda x: x**2, numbers))\nprint(squared_list)  # Output: [1, 4, 9, 16]\n\n# Example with filter(): Filter items based on a function\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)  # Output: [2, 4]\n\n# Example with sorted(): Custom sort key\nwords = ['apple', 'banana', 'cherry', 'date']\nsorted_by_length = sorted(words, key=lambda word: len(word))\nprint(sorted_by_length)  # Output: ['date', 'apple', 'banana', 'cherry']"
  },
  {
    "title": "Python Arrays",
    "note": "Arrays store multiple items of the same type (use list or array module). While lists can hold elements of different types, arrays from the `array` module are more memory-efficient for large sequences of homogeneous data (e.g., all integers or all floats). They behave very similarly to lists but require a type code (like 'i' for signed int, 'f' for float) upon creation to specify the data type. For most general purposes, lists are preferred.",
    "code": "import array as arr\n\n# Creating an array of integers (typecode 'i')\nnumbers = arr.array('i', [1, 2, 3, 4, 5])\nprint(numbers)        # Output: array('i', [1, 2, 3, 4, 5])\nprint(numbers[0])     # Output: 1 (indexing works like lists)\n\nnumbers.append(6)     # Add an item\nprint(numbers)        # Output: array('i', [1, 2, 3, 4, 5, 6])\n\n# Trying to add a float will cause an error\n# numbers.append(3.14) # TypeError: integer argument expected, got float\n\n# Creating an array of floats (typecode 'f')\nfloat_array = arr.array('f', [1.0, 2.5, 3.14])\nprint(float_array)    # Output: array('f', [1.0, 2.5, 3.140000104904175])"
  },
  {
    "title": "Python OOP",
    "note": "Object-Oriented Programming uses classes and objects. It is a programming paradigm that models real-world things as objects that have properties (attributes) and behaviors (methods). A class is a blueprint for creating objects (instances). The `__init__()` method is a special constructor method that is automatically called when a new object is created. The `self` parameter is a reference to the current instance of the class and is used to access variables and methods belonging to that object.",
    "code": "class Car:\n    # Class Attribute - shared by all instances\n    wheels = 4\n\n    # The constructor method\n    def __init__(self, brand, model):\n        # Instance Attributes - unique to each instance\n        self.brand = brand\n        self.model = model\n        self.is_running = False  # Default value\n\n    # Instance Method - defines behavior\n    def start_engine(self):\n        self.is_running = True\n        print(f'The {self.brand} {self.model} engine is now running.')\n\n    def stop_engine(self):\n        self.is_running = False\n        print(f'The {self.brand} {self.model} engine has stopped.')\n\n# Creating objects (instances) of the Car class\nmy_car = Car('Toyota', 'Corolla')\nyour_car = Car('Tesla', 'Model 3')\n\n# Accessing attributes and calling methods\nprint(my_car.brand)       # Output: Toyota\nprint(your_car.wheels)    # Output: 4 (accessing class attribute)\nmy_car.start_engine()     # Output: The Toyota Corolla engine is now running.\nprint(my_car.is_running)  # Output: True"
  },
  {
    "title": "Python Classes/Objects",
    "note": "Classes define blueprints for objects. They encapsulate data (attributes) and functionality (methods) together. Creating a new object from a class is called instantiation. The `__init__` method initializes the object's state by assigning values to the object's properties. The `self` parameter is a convention for the first argument of any method that references the instance itself, allowing access to its attributes and other methods.",
    "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name  # Assign the 'name' argument to the object's 'name' attribute\n        self.age = age    # Assign the 'age' argument to the object's 'age' attribute\n\n    def introduce(self):\n        # Method to use the object's data\n        print(f'Hello, my name is {self.name} and I am {self.age} years old.')\n\n    def have_birthday(self):\n        # Method that modifies the object's state\n        self.age += 1\n        print(f'Happy Birthday, {self.name}! You are now {self.age}.')\n\n# Creating instances (objects) of the Person class\np1 = Person('Alice', 25)\np2 = Person('Bob', 30)\n\n# Accessing object attributes\nprint(p1.name)  # Output: Alice\n\n# Calling object methods\np1.introduce()  # Output: Hello, my name is Alice and I am 25 years old.\np2.have_birthday() # Output: Happy Birthday, Bob! You are now 31.\nprint(p2.age)   # Output: 31 (the state was changed)"
  },
  {
    "title": "Python Inheritance",
    "note": "Inheritance allows classes to inherit attributes and methods from another class. The class being inherited from is called the parent, base, or superclass. The class that inherits is called the child, derived, or subclass. This promotes code reusability and establishes a logical relationship between classes. A subclass can override methods from its superclass to provide specific implementation, and it can also extend the superclass by adding new attributes and methods.",
    "code": "class Animal:  # Parent class (Superclass)\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        print('The animal makes a sound.')\n\n    def sleep(self):\n        print(f'{self.name} is sleeping.')  # Common method for all animals\n\n\nclass Dog(Animal):  # Child class (Subclass) inherits from Animal\n    def __init__(self, name, breed):\n        super().__init__(name)  # Call the parent class's __init__ method\n        self.breed = breed      # New attribute specific to Dog\n\n    def speak(self):  # Override the parent's speak method\n        print(f'{self.name} says: Woof!')\n\n    def fetch(self):  # New method specific to Dog\n        print(f'{self.name} is fetching the ball!')\n\n\nclass Cat(Animal):  # Another child class\n    def speak(self):  # Override with different behavior\n        print(f'{self.name} says: Meow!')\n\n\n# Using the classes\nmy_dog = Dog('Rex', 'Labrador')\nmy_cat = Cat('Whiskers')\n\nmy_dog.speak()  # Output: Rex says: Woof! (Uses overridden method)\nmy_cat.speak()  # Output: Whiskers says: Meow! (Uses overridden method)\n\nmy_dog.sleep()  # Output: Rex is sleeping. (Inherited from Animal)\nmy_dog.fetch()  # Output: Rex is fetching the ball! (Specific to Dog)\n\nmy_cat.sleep()  # Output: Whiskers is sleeping. (Inherited from Animal)"
  },
  {
    "title": "Python Iterators",
    "note": "Iterators are objects that can be iterated upon (looped over), returning one element at a time. Technically, an iterator is an object which implements the iterator protocol, consisting of the `__iter__()` and `__next__()` methods. Lists, tuples, dictionaries, and sets are all iterable containers, but they are not iterators themselves. You can get an iterator from any iterable by using the `iter()` function. The `next()` function is used to manually get the next item from the iterator.",
    "code": "# Getting an iterator from a list\nfruits = ['apple', 'banana', 'cherry']\nmy_iterator = iter(fruits)  # Creates an iterator object\n\n# Manually getting the next items\nprint(next(my_iterator))  # Output: apple\nprint(next(my_iterator))  # Output: banana\nprint(next(my_iterator))  # Output: cherry\n# print(next(my_iterator))  # This would raise StopIteration error, no more items\n\n# This is what a for loop does internally:\nmy_iterator2 = iter(fruits)\nwhile True:\n    try:\n        fruit = next(my_iterator2)\n        print(fruit)\n    except StopIteration:\n        break  # Exit the loop when no more items\n\n# Creating a custom iterator (a class that implements __iter__ and __next__)\nclass CountUpTo:\n    def __init__(self, max_num):\n        self.max = max_num\n        self.current = 0\n\n    def __iter__(self):\n        return self  # Returns the iterator object itself\n\n    def __next__(self):\n        if self.current < self.max:\n            self.current += 1\n            return self.current\n        else:\n            raise StopIteration  # Signal that iteration is complete\n\n# Using the custom iterator\ncounter = CountUpTo(3)\nfor num in counter:\n    print(num)  # Output: 1, 2, 3"
  },
  {
    "title": "Python Polymorphism",
    "note": "Polymorphism allows the same method name to have different behavior depending on the object that calls it. It is a core concept in OOP that lets us define methods in the child class with the same name as defined in their parent class. This allows a single interface (like a method name) to be used for a general class of actions. The specific action is determined by the exact nature of the object. This makes code more flexible and easier to extend with new subclasses.",
    "code": "class Bird:\n    def sound(self):\n        print('The bird makes a sound.')\n\n    def move(self):\n        print('The bird flies.')\n\n\nclass Duck(Bird):\n    def sound(self):  # Override with specific implementation\n        print('The duck says: Quack!')\n\n\nclass Penguin(Bird):\n    def sound(self):  # Override with specific implementation\n        print('The penguin says: Honk!')\n\n    def move(self):   # Override because penguins can't fly\n        print('The penguin waddles.')\n\n\nclass Airplane:\n    # This is not a Bird subclass, but it has a move method (Duck Typing)\n    def move(self):\n        print('The airplane flies through the air.')\n\n\n# Function demonstrating polymorphism\ndef make_it_move(entity):\n    # This function doesn't care about the class, only that it has a move() method\n    entity.move()\n\n\n# Creating objects\nanimals = [Duck(), Penguin(), Bird()]  # List of different Bird objects\n\n# Polymorphism in action: the same method call produces different results\nfor animal in animals:\n    animal.sound()  # Output: Quack!, Honk!, The bird makes a sound.\n    animal.move()   # Output: The bird flies., The penguin waddles., The bird flies.\n\n# Duck Typing: If it looks like a duck and quacks like a duck, it's a duck.\n# The make_it_move function works with any object that has a move() method.\nplane = Airplane()\nmake_it_move(plane)  # Output: The airplane flies through the air.\nmake_it_move(animals[0]) # Output: The bird flies."
  },
  {
    "title": "Python Scope",
    "note": "Scope determines where variables can be accessed in code. It defines the visibility and lifetime of a variable. Python has four main scopes: Local (inside a function), Enclosing (in nested functions), Global (at the top level of a module), and Built-in (names in the built-in namespace like `print`). The LEGB rule is used to resolve names: Python searches for a name first in the Local scope, then Enclosing, then Global, and finally Built-in. The `global` and `nonlocal` keywords can modify this behavior.",
    "code": "x = 'global x'  # Global variable\n\ndef test_scope():\n    y = 'local y'  # Local variable - only accessible inside this function\n    print(y)        # Output: local y (found in local scope)\n    print(x)        # Output: global x (found in global scope, read is allowed)\n\n    # Trying to print z here would cause an error, it's not defined yet\n    z = 'local z'\n    print(z)        # Output: local z\n\n    # Modifying a global variable from inside a function requires the 'global' keyword\n    global x\n    x = 'modified global x inside function'\n    print(x)        # Output: modified global x inside function\n\ndef outer():\n    enclosing_var = 'enclosing'\n\n    def inner():\n        # 'nonlocal' allows modifying a variable from the enclosing (non-global) scope\n        nonlocal enclosing_var\n        enclosing_var = 'modified in inner function'\n        local_var = 'local'\n        print(local_var)          # Output: local\n        print(enclosing_var)      # Output: modified in inner function\n\n    inner()\n    print(enclosing_var)  # Output: modified in inner function (was changed by inner)\n\n# Calling the functions\ntest_scope()\nprint(x)  # Output: modified global x inside function (the global var was changed)\n\nouter()\n\n# Built-in scope example\n# 'len' is a built-in function, available everywhere\nprint(len('hello'))  # Output: 5"
  },
  {
    "title": "Python Modules",
    "note": "Modules are files containing Python code, which can be imported into other programs. They allow you to logically organize your code, group related functionality, and promote reusability. A module can define functions, classes, and variables. Using modules helps avoid naming conflicts and makes large programs more manageable. The `import` statement is used to bring a module's contents into the current namespace. You can import the whole module, specific parts, or import with an alias using the `as` keyword.",
    "code": "# Assuming a file named 'mymodule.py' exists with this content:\n# def greet(name):\n#     print(f'Hello, {name}!')\n#\n# version = '1.0'\n\n# main.py - Different ways to import and use the module\n\n# 1. Import the entire module\nimport mymodule\nmymodule.greet('Alice')  # Call function using module_name.function_name\nprint(mymodule.version)  # Access variable\n\n# 2. Import specific attributes/functions\nfrom mymodule import greet, version\ngreet('Bob')  # Call directly without module prefix\nprint(version)\n\n# 3. Import everything from a module (generally discouraged)\n# from mymodule import *\n# greet('Charlie')\n\n# 4. Import with an alias (useful for long module names)\nimport mymodule as mm\nmm.greet('David')\n\n# 5. Import standard library modules\nimport math\nprint(math.sqrt(25))  # Output: 5.0\n\n# 6. Check if a module is run directly or imported\n# In mymodule.py, you can have:\n# if __name__ == '__main__':\n#     print('This runs if the module is executed directly')\n# else:\n#     print('This runs if the module is imported')"
  },
  {
    "title": "Python Dates",
    "note": "The datetime module works with dates and times. It provides classes for manipulating dates and times in both simple and complex ways. The main classes are: `date` (for year, month, day), `time` (for hour, minute, second, microsecond), `datetime` (a combination of date and time), and `timedelta` (a duration expressing the difference between two date/time instances). This module is essential for any application that requires scheduling, logging, or calculating time intervals.",
    "code": "import datetime\n\n# Get the current local date and time\nnow = datetime.datetime.now()\nprint(now)  # Output: e.g., 2023-10-27 14:35:22.123456\n\n# Create a specific date\nyesterday = datetime.datetime(2023, 10, 26, 12, 30, 0)\nprint(yesterday)  # Output: 2023-10-26 12:30:00\n\n# Extract components from a datetime object\nprint(f'Year: {now.year}')\nprint(f'Month: {now.month}')\nprint(f'Day: {now.day}')\nprint(f'Hour: {now.hour}')\nprint(f'Minute: {now.minute}')\n\n# Format a date as a string using strftime (String Format Time)\nformatted_date = now.strftime('%A, %B %d, %Y at %I:%M %p')\nprint(formatted_date)  # Output: e.g., Friday, October 27, 2023 at 02:35 PM\n\n# Parse a string into a datetime object using strptime (String Parse Time)\ndate_string = '31/12/2023'\nparsed_date = datetime.datetime.strptime(date_string, '%d/%m/%Y')\nprint(parsed_date)  # Output: 2023-12-31 00:00:00\n\n# Calculate the difference between two dates (results in a timedelta object)\ntime_difference = now - yesterday\nprint(time_difference)        # Output: e.g., 1 day, 2:05:22.123456\nprint(time_difference.days)   # Output: 1\n\n# Create a timedelta to add or subtract time\none_week_later = now + datetime.timedelta(weeks=1)\nprint(one_week_later)"
  },
  {
    "title": "Python Math",
    "note": "The math module provides mathematical functions and constants beyond the basic arithmetic operators. It includes functions for number-theoretic and representation functions (ceil, floor, fabs), power and logarithmic functions (pow, sqrt, log), trigonometric functions (sin, cos, tan), angular conversion (radians, degrees), and constants like π (pi) and e. For complex numbers, use the `cmath` module. For fast operations on arrays of numbers, the `numpy` library is preferred.",
    "code": "import math\n\n# Constants\nprint(math.pi)   # Output: 3.141592653589793\nprint(math.e)    # Output: 2.718281828459045\n\n# Rounding numbers\nnum = 3.7\nprint(math.ceil(num))   # Output: 4 (round up to nearest integer)\nprint(math.floor(num))  # Output: 3 (round down to nearest integer)\nprint(round(num))       # Output: 4 (built-in round function)\n\n# Powers and roots\nprint(math.pow(2, 3))   # Output: 8.0 (2 raised to the power of 3)\nprint(math.sqrt(16))    # Output: 4.0 (square root)\nprint(math.exp(2))      # Output: ~7.389 (e raised to the power of 2)\n\n# Logarithms\nprint(math.log(100, 10))  # Output: 2.0 (log base 10 of 100)\nprint(math.log(8, 2))     # Output: 3.0 (log base 2 of 8)\nprint(math.log10(1000))   # Output: 3.0 (log base 10)\n\n# Trigonometric functions (work in radians by default)\nangle_in_radians = math.radians(45)  # Convert 45 degrees to radians\nprint(math.sin(angle_in_radians))    # Output: ~0.7071 (sine)\nprint(math.cos(angle_in_radians))    # Output: ~0.7071 (cosine)\nprint(math.tan(angle_in_radians))    # Output: ~1.0 (tangent)\n\n# Other useful functions\nprint(math.fabs(-5.5))  # Output: 5.5 (absolute value as float)\nprint(math.factorial(5)) # Output: 120 (5! = 5*4*3*2*1)\nprint(math.gcd(48, 18)) # Output: 6 (greatest common divisor)"
  },
  {
  "title": "Python JSON",
  "note": "The json module parses JSON strings and converts Python objects to JSON with comprehensive error handling and formatting options.",
  "code": "import json\n\n# Convert Python object to JSON string with formatting\ndata = {'name': 'Alice', 'age': 30, 'city': 'New York'}\njson_str = json.dumps(data, indent=4, sort_keys=True)\nprint(\"JSON String:\")\nprint(json_str)\n\n# Parse JSON string back to Python object\nparsed_data = json.loads(json_str)\nprint(\"\\nParsed Data:\")\nprint(f\"Name: {parsed_data['name']}\")\nprint(f\"Age: {parsed_data['age']}\")\n\n# Working with JSON files\nwith open('data.json', 'w') as json_file:\n    json.dump(data, json_file, indent=2)\n\nwith open('data.json', 'r') as json_file:\n    loaded_data = json.load(json_file)\n    print(f\"\\nData from file: {loaded_data}\")"
},
{
  "title": "Python RegEx",
  "note": "Regular expressions allow for advanced pattern matching, searching, and text manipulation with comprehensive pattern matching capabilities.",
  "code": "import re\n\n# Basic pattern matching\ntext = 'Contact us at: abc123, xyz456, test789'\npattern = r'\\w+\\d+'\nmatches = re.findall(pattern, text)\nprint(\"All matches:\", matches)\n\n# Search with groups\nmatch = re.search(r'(\\w+)(\\d+)', 'abc123')\nif match:\n    print(f\"Full match: {match.group()}\")\n    print(f\"Letters: {match.group(1)}\")\n    print(f\"Numbers: {match.group(2)}\")\n\n# Substitution (replace patterns)\nnew_text = re.sub(r'\\d+', 'NUM', 'abc123 def456')\nprint(\"After substitution:\", new_text)\n\n# Email validation example\nemail = \"user@example.com\"\nemail_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\nis_valid = bool(re.match(email_pattern, email))\nprint(f\"Email valid: {is_valid}\")"
},
{
  "title": "Python PIP",
  "note": "PIP is the comprehensive package manager for Python with installation, upgrade, dependency management, and virtual environment integration.",
  "code": "# Install specific version of a package\npip install requests==2.28.0\n\n# Upgrade a package to latest version\npip install --upgrade requests\n\n# Install from requirements file\npip install -r requirements.txt\n\n# List installed packages\npip list\n\n# Show package information\npip show requests\n\n# Create requirements file\npip freeze > requirements.txt\n\n# Install package in user space (no admin rights)\npip install --user package_name\n\n# Install with specific index\npip install --index-url https://pypi.org/simple/ package_name\n\n# Uninstall package\npip uninstall package_name"
},
{
  "title": "Python Try...Except",
  "note": "Comprehensive exception handling with multiple exception types, else and finally clauses, custom exceptions, and proper error logging.",
  "code": "try:\n    # Attempt risky operations\n    numerator = 10\n    denominator = int(input(\"Enter denominator: \"))\n    result = numerator / denominator\n    \n    # File operation that might fail\n    with open('data.txt', 'r') as file:\n        content = file.read()\n    \n    print(f\"Result: {result}\")\n    print(f\"File content: {content}\")\n\nexcept ZeroDivisionError:\n    print(\"Error: Cannot divide by zero!\")\n\nexcept ValueError:\n    print(\"Error: Please enter a valid integer!\")\n\nexcept FileNotFoundError:\n    print(\"Error: File not found!\")\n\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n    # Log the error for debugging\n    import logging\n    logging.error(f\"An error occurred: {e}\")\n\nelse:\n    print(\"All operations completed successfully!\")\n\nfinally:\n    print(\"This block always executes (cleanup code here)\")\n    print(\"Execution complete.\")"
},
{
  "title": "Python String Formatting",
  "note": "Comprehensive string formatting techniques including f-strings, format() method, % formatting, and advanced formatting options with alignment and precision.",
  "code": "# f-strings (Python 3.6+)\nname = 'Alice'\nage = 30\nheight = 1.75\nprint(f'Hello {name}! You are {age} years old.')\nprint(f'Height: {height:.2f} meters')\n\n# format() method\nprint('Hello {}! You are {} years old.'.format(name, age))\nprint('{0} is {1} years old. Welcome {0}!'.format(name, age))\n\n# % formatting (older style)\nprint('Hello %s! You are %d years old.' % (name, age))\n\n# Advanced formatting\nprice = 19.999\nquantity = 3\ntotal = price * quantity\nprint(f'Price: ${price:.2f}')\nprint(f'Quantity: {quantity:03d}')  # Pad with zeros\nprint(f'Total: ${total:,.2f}')  # With thousands separator\n\n# Multi-line f-string\nmessage = f\"\"\"\nCustomer Information:\nName: {name:>10}\nAge:  {age:>10}\nTotal: ${total:>8.2f}\n\"\"\"\nprint(message)\n\n# String methods for formatting\ntext = \"  hello world  \"\nprint(f\"Original: '{text}'\")\nprint(f\"Strip: '{text.strip()}'\")\nprint(f\"Title: '{text.strip().title()}'\")"
},
{
  "title": "Python User Input",
  "note": "Comprehensive user input handling with validation, type conversion, error handling, and multiple input scenarios including secure password input.",
  "code": "# Basic input\nname = input('Enter your name: ')\nprint(f'Hello, {name}!')\n\n# Input with type conversion and validation\nwhile True:\n    try:\n        age = int(input('Enter your age: '))\n        if age < 0 or age > 120:\n            print(\"Please enter a valid age (0-120)\")\n            continue\n        break\n    except ValueError:\n        print(\"Please enter a valid integer!\")\n\nprint(f'You are {age} years old.')\n\n# Multiple inputs\nname = input('Enter your name: ').strip()\nemail = input('Enter your email: ').strip().lower()\n\n# Password input (hidden)\nimport getpass\npassword = getpass.getpass('Enter your password: ')\nprint(f'Password length: {len(password)} characters')\n\n# Menu-driven input\nprint(\"\\nChoose an option:\")\nprint(\"1. Add numbers\")\nprint(\"2. Multiply numbers\")\nprint(\"3. Exit\")\n\nchoice = input(\"Enter choice (1-3): \")\n\nif choice == '1':\n    num1 = float(input(\"Enter first number: \"))\n    num2 = float(input(\"Enter second number: \"))\n    print(f\"Sum: {num1 + num2}\")\nelif choice == '2':\n    num1 = float(input(\"Enter first number: \"))\n    num2 = float(input(\"Enter second number: \"))\n    print(f\"Product: {num1 * num2}\")\nelse:\n    print(\"Goodbye!\")"
},
{
  "title": "Python VirtualEnv",
  "note": "Complete virtual environment management with creation, activation, package isolation, requirements management, and cross-platform compatibility.",
  "code": "# Create virtual environment\npython -m venv myenv\n\n# Activate virtual environment (Windows)\n# myenv\\\\Scripts\\\\activate\n\n# Activate virtual environment (Unix/MacOS)\n# source myenv/bin/activate\n\n# Once activated, your terminal prompt should show (myenv)\n\n# Install packages in virtual environment\n# pip install requests pandas numpy\n\n# Create requirements file\n# pip freeze > requirements.txt\n\n# Install from requirements file\n# pip install -r requirements.txt\n\n# Deactivate virtual environment\n# deactivate\n\n# Create virtual environment with specific Python version\n# python3.9 -m venv myenv\n\n# Virtual environment with system site packages\n# python -m venv --system-site-packages myenv\n\n# Upgrade pip in virtual environment\n# python -m pip install --upgrade pip\n\n# Check which Python is being used\n# which python  # Unix/MacOS\n# where python  # Windows\n\nprint(\"Virtual environment commands executed successfully!\")"
},
{
  "title": "Python File Handling",
  "note": "Comprehensive file operations including reading, writing, appending, error handling, context management, and file metadata operations.",
  "code": "import os\n\n# Basic file operations\n# Writing to a file\nwith open('data.txt', 'w') as f:\n    f.write('Hello, World!\\n')\n    f.write('This is a second line.\\n')\n    f.write('Third line with some data.\\n')\n\n# Reading entire file\nwith open('data.txt', 'r') as f:\n    content = f.read()\n    print(\"Full content:\")\n    print(content)\n\n# Reading line by line\nprint(\"\\nLine by line:\")\nwith open('data.txt', 'r') as f:\n    for i, line in enumerate(f, 1):\n        print(f\"Line {i}: {line.strip()}\")\n\n# Appending to file\nwith open('data.txt', 'a') as f:\n    f.write('This line was appended.\\n')\n\n# File metadata\nfile_path = 'data.txt'\nif os.path.exists(file_path):\n    print(f\"\\nFile size: {os.path.getsize(file_path)} bytes\")\n    print(f\"Last modified: {os.path.getmtime(file_path)}\")\n\n# Error handling with files\ntry:\n    with open('nonexistent.txt', 'r') as f:\n        content = f.read()\nexcept FileNotFoundError:\n    print(\"\\nFile not found! Creating a new one...\")\n    with open('nonexistent.txt', 'w') as f:\n        f.write('New file content')\n\n# Working with different file modes\n# 'r' - read, 'w' - write, 'a' - append, 'r+' - read/write\n# 'b' - binary mode (e.g., 'rb', 'wb')"
},
{
  "title": "Python Read Files",
  "note": "Comprehensive file reading techniques including different reading methods, encoding handling, large file processing, and error management.",
  "code": "import os\n\n# Check if file exists before reading\nfilename = 'data.txt'\n\nif not os.path.exists(filename):\n    print(f\"File {filename} does not exist!\")\n    # Create sample file for demonstration\n    with open(filename, 'w') as f:\n        f.write('Line 1: Hello World\\n')\n        f.write('Line 2: Python Programming\\n')\n        f.write('Line 3: File Handling Demo\\n')\n        f.write('Line 4: Data processing example\\n')\n        f.write('Line 5: End of file content\\n')\n\n# Method 1: Read entire file\nprint(\"=== Reading entire file ===\")\nwith open(filename, 'r', encoding='utf-8') as f:\n    content = f.read()\n    print(content)\n\n# Method 2: Read line by line (memory efficient)\nprint(\"\\n=== Reading line by line ===\")\nwith open(filename, 'r') as f:\n    line_number = 1\n    for line in f:\n        print(f\"Line {line_number}: {line.strip()}\")\n        line_number += 1\n\n# Method 3: Read specific number of characters\nprint(\"\\n=== Reading first 20 characters ===\")\nwith open(filename, 'r') as f:\n    first_chars = f.read(20)\n    print(first_chars)\n\n# Method 4: Read all lines into list\nprint(\"\\n=== Reading all lines into list ===\")\nwith open(filename, 'r') as f:\n    lines = f.readlines()\n    for i, line in enumerate(lines, 1):\n        print(f\"Line {i}: {line.strip()}\")\n\n# Method 5: Using readline() for controlled reading\nprint(\"\\n=== Using readline() ===\")\nwith open(filename, 'r') as f:\n    first_line = f.readline()\n    second_line = f.readline()\n    print(f\"First line: {first_line.strip()}\")\n    print(f\"Second line: {second_line.strip()}\")\n\n# Handling different encodings\ntry:\n    with open(filename, 'r', encoding='utf-8') as f:\n        content = f.read()\nexcept UnicodeDecodeError:\n    print(\"UTF-8 decoding failed, trying latin-1...\")\n    with open(filename, 'r', encoding='latin-1') as f:\n        content = f.read()"
},
{
  "title": "Python Write/Create Files",
  "note": "Comprehensive file writing and creation techniques including different modes, error handling, data formatting, and best practices for file operations.",
  "code": "import os\nimport csv\nimport json\n\n# Basic file writing\nprint(\"=== Basic File Writing ===\")\n\n# Write mode ('w') - creates new file or overwrites existing\nwith open('output.txt', 'w') as f:\n    f.write('Hello, World!\\n')\n    f.write('This is a new line.\\n')\n    f.write('Writing multiple lines of text.\\n')\n\nprint(\"Basic text file created successfully!\")\n\n# Append mode ('a') - adds to existing file or creates new\nprint(\"\\n=== Appending to File ===\")\nwith open('output.txt', 'a') as f:\n    f.write('This line was appended.\\n')\n    f.write('Another appended line.\\n')\n\nprint(\"Content appended successfully!\")\n\n# Writing multiple lines efficiently\nprint(\"\\n=== Writing Multiple Lines ===\")\nlines_to_write = [\n    'First line of batch',\n    'Second line of batch',\n    'Third line with some data',\n    'Fourth line completes the set'\n]\n\nwith open('batch_output.txt', 'w') as f:\n    f.writelines(line + '\\n' for line in lines_to_write)\n\nprint(\"Batch writing completed!\")\n\n# Writing formatted data\nprint(\"\\n=== Formatted Data Writing ===\")\nuser_data = [\n    {'name': 'Alice', 'age': 30, 'city': 'New York'},\n    {'name': 'Bob', 'age': 25, 'city': 'London'},\n    {'name': 'Charlie', 'age': 35, 'city': 'Tokyo'}\n]\n\nwith open('formatted_data.txt', 'w') as f:\n    for user in user_data:\n        f.write(f\"Name: {user['name']}, Age: {user['age']}, City: {user['city']}\\n\")\n\nprint(\"Formatted data written!\")\n\n# Writing CSV files\nprint(\"\\n=== CSV File Writing ===\")\nwith open('data.csv', 'w', newline='') as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow(['Name', 'Age', 'City'])\n    writer.writerow(['Alice', 30, 'New York'])\n    writer.writerow(['Bob', 25, 'London'])\n    writer.writerow(['Charlie', 35, 'Tokyo'])\n\nprint(\"CSV file created!\")\n\n# Writing JSON data\nprint(\"\\n=== JSON File Writing ===\")\ndata = {\n    'users': [\n        {'name': 'Alice', 'age': 30, 'hobbies': ['reading', 'swimming']},\n        {'name': 'Bob', 'age': 25, 'hobbies': ['gaming', 'coding']}\n    ],\n    'metadata': {'created': '2024-01-20', 'version': 1.0}\n}\n\nwith open('data.json', 'w') as jsonfile:\n    json.dump(data, jsonfile, indent=2)\n\nprint(\"JSON file created!\")\n\n# Error handling and file existence check\nprint(\"\\n=== Error Handling ===\")\nfilename = 'important_data.txt'\n\ntry:\n    with open(filename, 'x') as f:  # 'x' mode - exclusive creation, fails if exists\n        f.write('This is exclusive content!')\n    print(f\"File {filename} created exclusively!\")\nexcept FileExistsError:\n    print(f\"File {filename} already exists! Using append mode instead...\")\n    with open(filename, 'a') as f:\n        f.write('\\nAdditional content appended.')\n\nprint(\"All file writing operations completed successfully!\")"
},
{
  "title": "Python Delete Files",
  "note": "Comprehensive file and directory deletion techniques with safety checks, error handling, recursive deletion, and alternative methods.",
  "code": "import os\nimport shutil\nimport glob\n\n# Basic file deletion with existence check\nprint(\"=== Basic File Deletion ===\")\n\nfilename = 'file_to_delete.txt'\n\n# Create a sample file first\nwith open(filename, 'w') as f:\n    f.write('This file will be deleted.')\n\nprint(f\"File {filename} created for demonstration.\")\n\n# Safe deletion with existence check\nif os.path.exists(filename):\n    os.remove(filename)\n    print(f\"File {filename} deleted successfully!\")\nelse:\n    print(f\"File {filename} does not exist!\")\n\n# Handling deletion errors\nprint(\"\\n=== Error Handling ===\")\nprotected_file = 'protected_file.txt'\n\n# Create a file and make it read-only for demonstration\nwith open(protected_file, 'w') as f:\n    f.write('This file has read-only permissions.')\n\n# On Windows: make file read-only\nif os.name == 'nt':\n    import stat\n    os.chmod(protected_file, stat.S_IREAD)\n\ntry:\n    os.remove(protected_file)\n    print(f\"File {protected_file} deleted!\")\nexcept PermissionError:\n    print(f\"Permission denied: Cannot delete {protected_file}\")\n    # Clean up: remove read-only attribute and delete\n    if os.name == 'nt':\n        os.chmod(protected_file, stat.S_IWRITE)\n        os.remove(protected_file)\n        print(f\"File {protected_file} deleted after fixing permissions!\")\nexcept Exception as e:\n    print(f\"Error deleting file: {e}\")\n\n# Deleting multiple files with patterns\nprint(\"\\n=== Multiple File Deletion ===\")\n\n# Create some sample files\nfor i in range(3):\n    with open(f'temp_file_{i}.txt', 'w') as f:\n        f.write(f'Content of temp file {i}')\n\nprint(\"Created temporary files for deletion demonstration.\")\n\n# Delete files matching pattern\ntemp_files = glob.glob('temp_file_*.txt')\nfor file in temp_files:\n    if os.path.exists(file):\n        os.remove(file)\n        print(f\"Deleted: {file}\")\n\n# Directory operations\nprint(\"\\n=== Directory Operations ===\")\n\ndir_to_delete = 'temp_directory'\n\n# Create a directory and some files in it\nos.makedirs(dir_to_delete, exist_ok=True)\nwith open(os.path.join(dir_to_delete, 'file1.txt'), 'w') as f:\n    f.write('File in directory')\nwith open(os.path.join(dir_to_delete, 'file2.txt'), 'w') as f:\n    f.write('Another file in directory')\n\nprint(f\"Created directory {dir_to_delete} with files.\")\n\n# Delete empty directory\nif os.path.exists(dir_to_delete) and os.path.isdir(dir_to_delete):\n    try:\n        os.rmdir(dir_to_delete)  # Fails if directory not empty\n        print(f\"Directory {dir_to_delete} deleted!\")\n    except OSError:\n        print(f\"Directory {dir_to_delete} is not empty!\")\n\n# Force delete directory with contents (DANGEROUS - use with caution!)\nif os.path.exists(dir_to_delete):\n    shutil.rmtree(dir_to_delete)\n    print(f\"Directory {dir_to_delete} and all contents force-deleted!\")\n\n# Safe deletion function\ndef safe_delete(filepath):\n    \"\"\"Safely delete a file with comprehensive error handling\"\"\"\n    try:\n        if os.path.exists(filepath):\n            if os.path.isfile(filepath):\n                os.remove(filepath)\n                print(f\"Successfully deleted file: {filepath}\")\n                return True\n            else:\n                print(f\"Path is a directory, not a file: {filepath}\")\n                return False\n        else:\n            print(f\"File does not exist: {filepath}\")\n            return False\n    except PermissionError:\n        print(f\"Permission denied: {filepath}\")\n        return False\n    except Exception as e:\n        print(f\"Error deleting {filepath}: {e}\")\n        return False\n\nprint(\"\\n=== Using Safe Deletion Function ===\")\nsafe_delete('nonexistent_file.txt')  # Should handle gracefully\n\n# Create and delete a test file\ntest_file = 'test_delete.txt'\nwith open(test_file, 'w') as f:\n    f.write('Test content')\n\nsafe_delete(test_file)\n\nprint(\"\\nAll deletion operations completed!\")"
}
],
Java : [
{
  "title": "Java HOME",
  "note": "Java HOME serves as the central hub for Java resources, tutorials, and project entry points. It provides comprehensive guidance on structuring projects, executing Java programs, and understanding the JVM ecosystem. Java HOME is your starting point to learn everything from installation and configuration to advanced features, including multithreading, collections, streams, and APIs. It emphasizes best practices, maintainable code, debugging techniques, and platform-independent development using JVM.",
  "code": "// Main.java - Primary Java Application Entry Point\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"=== Welcome to Java Programming! ===\");\n        \n        // Display system properties\n        System.out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n        System.out.println(\"JVM Vendor: \" + System.getProperty(\"java.vendor\"));\n        System.out.println(\"OS: \" + System.getProperty(\"os.name\") + \" - \" + System.getProperty(\"os.arch\"));\n        \n        // Demonstrate features\n        displayWelcomeMessage();\n        demonstrateBasicOperations();\n        demonstrateAdvancedOperations();\n        demonstrateControlFlow();\n    }\n\n    public static void displayWelcomeMessage() {\n        System.out.println(\"\\n--- Getting Started ---\");\n        System.out.println(\"1. Install JDK from Oracle or OpenJDK\");\n        System.out.println(\"2. Set JAVA_HOME environment variable\");\n        System.out.println(\"3. Add Java bin directory to PATH\");\n        System.out.println(\"4. Verify installation using: java -version and javac -version\");\n        System.out.println(\"5. Choose IDE: IntelliJ IDEA, Eclipse, VS Code, or NetBeans\");\n    }\n\n    public static void demonstrateBasicOperations() {\n        System.out.println(\"\\n--- Basic Operations ---\");\n\n        String language = \"Java\";\n        int version = 21;\n        boolean isObjectOriented = true;\n\n        System.out.println(\"Language: \" + language);\n        System.out.println(\"Latest Version: \" + version);\n        System.out.println(\"Object Oriented: \" + isObjectOriented);\n\n        int result = calculateSquare(7);\n        System.out.println(\"Square of 7: \" + result);\n\n        double area = calculateCircleArea(5);\n        System.out.println(\"Area of circle with radius 5: \" + area);\n    }\n\n    public static int calculateSquare(int number) {\n        return number * number;\n    }\n\n    public static double calculateCircleArea(double radius) {\n        final double PI = 3.14159;\n        return PI * radius * radius;\n    }\n\n    public static void demonstrateAdvancedOperations() {\n        System.out.println(\"\\n--- Advanced Operations ---\");\n        int[] numbers = {1, 2, 3, 4, 5};\n        int sum = 0;\n        for(int num : numbers) sum += num;\n        System.out.println(\"Sum of array numbers: \" + sum);\n\n        String combined = String.join(\", \", \"Java\", \"Python\", \"C++\");\n        System.out.println(\"Joined languages: \" + combined);\n    }\n\n    public static void demonstrateControlFlow() {\n        System.out.println(\"\\n--- Control Flow Examples ---\");\n        int score = 85;\n        if(score >= 90) {\n            System.out.println(\"Grade: A\");\n        } else if(score >= 75) {\n            System.out.println(\"Grade: B\");\n        } else {\n            System.out.println(\"Grade: C or below\");\n        }\n\n        System.out.println(\"Loop from 1 to 5:\");\n        for(int i=1; i<=5; i++) {\n            System.out.println(i);\n        }\n    }\n}\n\n// Compile: javac Main.java\n// Run: java Main"
},
{
  "title": "Java Intro",
  "note": "Java is a versatile, high-level programming language that is class-based, object-oriented, and platform-independent. It follows the 'Write Once, Run Anywhere' philosophy, which allows compiled bytecode to run on any device with a JVM. Java enforces strong typing, automatic memory management through garbage collection, and provides a rich set of standard libraries for networking, I/O, collections, and concurrency. Its syntax is influenced by C/C++ but simplified for ease of use. Java is widely used in enterprise applications, Android development, web services, and large-scale distributed systems.",
  "code": "// Introduction to Java Programming\npublic class JavaIntroduction {\n    public static void main(String[] args) {\n        System.out.println(\"=== Java Programming Introduction ===\\n\");\n\n        demonstratePlatformIndependence();\n        demonstrateObjectOrientedNature();\n        demonstrateStrongTyping();\n        demonstrateMemoryManagement();\n        demonstrateUseCases();\n    }\n\n    public static void demonstratePlatformIndependence() {\n        System.out.println(\"1. Platform Independence:\");\n        System.out.println(\"   - Java code compiles to bytecode\");\n        System.out.println(\"   - Bytecode runs on any JVM-enabled system\");\n        System.out.println(\"   - Example: Windows, Linux, macOS\");\n    }\n\n    public static void demonstrateObjectOrientedNature() {\n        System.out.println(\"\\n2. Object-Oriented Programming:\");\n        System.out.println(\"   - Classes and Objects\");\n        System.out.println(\"   - Encapsulation, Inheritance, Polymorphism, Abstraction\");\n\n        Car myCar = new Car(\"Toyota\", \"Camry\", 2023);\n        myCar.displayInfo();\n        myCar.startEngine();\n    }\n\n    public static void demonstrateStrongTyping() {\n        System.out.println(\"\\n3. Strong Typing System:\");\n        int age = 25;\n        String name = \"Alice\";\n        System.out.println(\"   Name: \" + name + \", Age: \" + age);\n    }\n\n    public static void demonstrateMemoryManagement() {\n        System.out.println(\"\\n4. Automatic Memory Management:\");\n        System.out.println(\"   - Garbage Collector handles memory allocation and freeing\");\n    }\n\n    public static void demonstrateUseCases() {\n        System.out.println(\"\\n5. Common Java Use Cases:\");\n        System.out.println(\"   - Android App Development\");\n        System.out.println(\"   - Web Applications (Spring, Jakarta EE)\");\n        System.out.println(\"   - Enterprise Systems\");\n        System.out.println(\"   - Big Data & Distributed Systems\");\n    }\n}\n\nclass Car {\n    private String make, model; private int year;\n    public Car(String make, String model, int year){this.make=make;this.model=model;this.year=year;}\n    public void displayInfo(){System.out.println(\"   Car: \" + year + \" \" + make + \" \" + model);}\n    public void startEngine(){System.out.println(\"   Engine started! Vroom vroom!\");}\n}"
},
{
  "title": "Java Get Started",
  "note": "Guide for setting up a complete Java development environment, including JDK installation, IDE configuration, first program creation, compiling, running, and package management. Covers project folder structure, best practices for code organization, and essential tools for productivity and debugging.",
  "code": "// Getting Started with Java\npublic class GettingStarted {\n    public static void main(String[] args) {\n        System.out.println(\"=== Java Development Environment Setup ===\");\n\n        displayInstallationSteps();\n        demonstrateFirstProgram();\n        demonstrateCompilationProcess();\n        demonstratePackageManagement();\n        demonstrateIDESetup();\n    }\n\n    public static void displayInstallationSteps() {\n        System.out.println(\"1. Install JDK from Oracle or Adoptium\");\n        System.out.println(\"2. Set JAVA_HOME and update PATH\");\n        System.out.println(\"3. Verify installation: java -version, javac -version\");\n    }\n\n    public static void demonstrateFirstProgram() {\n        System.out.println(\"\\n2. First Java Program - HelloWorld.java\");\n        System.out.println(\"   - Compile: javac HelloWorld.java\");\n        System.out.println(\"   - Run: java HelloWorld\");\n        System.out.println(\"   Output: Hello, World!\");\n    }\n\n    public static void demonstrateCompilationProcess() {\n        System.out.println(\"\\n3. Compilation produces .class files for JVM execution\");\n    }\n\n    public static void demonstratePackageManagement() {\n        System.out.println(\"\\n4. Package Management Example\");\n        System.out.println(\"   - Organize code in src/com/company/\");\n        System.out.println(\"   - Compile with javac -d bin src/com/company/*.java\");\n    }\n\n    public static void demonstrateIDESetup() {\n        System.out.println(\"\\n5. Recommended IDEs:\");\n        System.out.println(\"   - IntelliJ IDEA, Eclipse, VS Code\");\n    }\n}\n\nclass HelloWorldExtended {\n    public static void main(String[] args){\n        System.out.println(\"Hello, World!\\nWelcome to Java Programming!\");\n        String name=\"Alice\"; int age=20; double gpa=3.8;\n        System.out.printf(\"Student Info: %s, Age: %d, GPA: %.2f\\n\", name, age, gpa);\n    }\n}"
},
{
  "title": "Java Syntax",
  "note": "A complete guide to Java syntax covering class and method structures, data types, operators, control flow, arrays, loops, exception handling, naming conventions, comments, constants, and best practices. Includes modern Java constructs such as enhanced for-loops, switch expressions, and try-with-resources, designed for professional and maintainable code.",
  "code": "// Java Syntax Masterclass - Expanded\npublic class JavaSyntax {\n\n    // Constants (UPPER_SNAKE_CASE)\n    public static final double PI = 3.14159;\n    public static final int MAX_CONNECTIONS = 100;\n\n    // Class variables (camelCase)\n    private int instanceCount = 0;\n    private static String applicationName = \"SyntaxDemo\";\n\n    public static void main(String[] args) {\n        System.out.println(\"=== Java Syntax Rules and Conventions ===\\n\");\n\n        demonstrateBasicSyntax();\n        demonstrateDataTypesAndOperators();\n        demonstrateControlFlow();\n        demonstrateArraysAndLoops();\n        demonstrateExceptionHandling();\n        demonstrateNamingAndStructure();\n        demonstrateBestPractices();\n    }\n\n    public static void demonstrateBasicSyntax() {\n        System.out.println(\"1. Basic Syntax Rules:\");\n        System.out.println(\"   - Java is case-sensitive: 'variable' != 'Variable'\");\n        System.out.println(\"   - Statements end with semicolons\");\n        System.out.println(\"   - Curly braces {} define code blocks\");\n        System.out.println(\"   - Main method is entry point: public static void main(String[] args)\");\n\n        int validVariable = 42;\n        String validString = \"Hello\";\n        boolean isValid = true;\n\n        System.out.println(\"   Example: int x = 5; // valid\");\n    }\n\n    public static void demonstrateDataTypesAndOperators() {\n        System.out.println(\"\\n2. Data Types and Operators:\");\n        \n        int integerVal = 10;\n        double doubleVal = 5.5;\n        char letter = 'A';\n        boolean flag = true;\n\n        System.out.println(\"Integer: \" + integerVal);\n        System.out.println(\"Double: \" + doubleVal);\n        System.out.println(\"Char: \" + letter);\n        System.out.println(\"Boolean: \" + flag);\n\n        // Arithmetic Operators\n        System.out.println(\"Sum: \" + (integerVal + doubleVal));\n        System.out.println(\"Difference: \" + (integerVal - doubleVal));\n        System.out.println(\"Product: \" + (integerVal * doubleVal));\n        System.out.println(\"Division: \" + (integerVal / doubleVal));\n\n        // Logical and relational operators\n        System.out.println(\"Is integerVal > doubleVal? \" + (integerVal > doubleVal));\n        System.out.println(\"Is flag AND true? \" + (flag && true));\n    }\n\n    public static void demonstrateControlFlow() {\n        System.out.println(\"\\n3. Control Flow Statements:\");\n\n        int number = 7;\n        if (number % 2 == 0) {\n            System.out.println(number + \" is even\");\n        } else {\n            System.out.println(number + \" is odd\");\n        }\n\n        // Switch expression (modern Java)\n        String day = \"MON\";\n        String typeOfDay = switch(day) {\n            case \"SAT\", \"SUN\" -> \"Weekend\";\n            default -> \"Weekday\";\n        };\n        System.out.println(day + \" is a \" + typeOfDay);\n    }\n\n    public static void demonstrateArraysAndLoops() {\n        System.out.println(\"\\n4. Arrays and Loops:\");\n\n        int[] numbers = {1, 2, 3, 4, 5};\n\n        System.out.println(\"Enhanced for-loop:\");\n        for (int num : numbers) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Classic for-loop with index:\");\n        for (int i = 0; i < numbers.length; i++) {\n            System.out.print(numbers[i] + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"While loop example:\");\n        int i = 0;\n        while (i < numbers.length) {\n            System.out.print(numbers[i] + \" \");\n            i++;\n        }\n        System.out.println();\n    }\n\n    public static void demonstrateExceptionHandling() {\n        System.out.println(\"\\n5. Exception Handling:\");\n\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        } finally {\n            System.out.println(\"Finally block executed regardless of exception\");\n        }\n\n        // Try-with-resources example (automatic resource management)\n        try (java.util.Scanner scanner = new java.util.Scanner(System.in)) {\n            System.out.print(\"Enter a number: \");\n            int num = scanner.nextInt();\n            System.out.println(\"You entered: \" + num);\n        } catch (Exception e) {\n            System.err.println(\"Input error: \" + e.getMessage());\n        }\n    }\n\n    public static void demonstrateNamingAndStructure() {\n        System.out.println(\"\\n6. Naming Conventions and Code Structure:\");\n        System.out.println(\"   - Classes: PascalCase\");\n        System.out.println(\"   - Methods/Variables: camelCase\");\n        System.out.println(\"   - Constants: UPPER_SNAKE_CASE\");\n        System.out.println(\"   - Packages: lowercase\");\n\n        System.out.println(\"Example Class Structure:\");\n        System.out.println(\"public class MyClass { private int value; public void display() {} }\");\n    }\n\n    public static void demonstrateBestPractices() {\n        System.out.println(\"\\n7. Best Practices:\");\n        System.out.println(\"   - Meaningful variable names\");\n        System.out.println(\"   - Consistent 4-space indentation\");\n        System.out.println(\"   - Small focused methods\");\n        System.out.println(\"   - Use comments to explain why, not what\");\n        System.out.println(\"   - Constants for fixed values\");\n        System.out.println(\"   - Proper exception handling\");\n    }\n\n    private static boolean performOperation() {\n        return Math.random() > 0.3;\n    }\n}\n\nclass Employee {\n    private String name;\n    private int id;\n    private double salary;\n\n    public Employee(String name, int id, double salary) {\n        this.name = name;\n        this.id = id;\n        this.salary = salary;\n    }\n\n    public String getName() { return name; }\n    public int getId() { return id; }\n    public double getSalary() { return salary; }\n\n    public void setSalary(double salary) {\n        if (salary >= 0) this.salary = salary;\n        else throw new IllegalArgumentException(\"Salary cannot be negative\");\n    }\n\n    public void giveRaise(double percent) {\n        if (percent > 0) this.salary += this.salary * (percent / 100);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Employee[ID: %d, Name: %s, Salary: $%.2f]\", id, name, salary);\n    }\n}"
},
{
  "title": "Java Output",
  "note": "Comprehensive guide to Java output techniques, covering standard printing (print, println), formatted output (printf, String.format, Formatter), error output (System.err), logging simulation, advanced console manipulation, table display, date and number formatting, and best practices for professional console applications. Includes interactive console input and modern Java features for robust and readable output.",
  "code": "// Java Output Masterclass - Expanded\nimport java.util.Date;\nimport java.text.SimpleDateFormat;\nimport java.util.Formatter;\nimport java.util.Arrays;\nimport java.io.Console;\n\npublic class JavaOutput {\n\n    public static void main(String[] args) {\n        System.out.println(\"=== Java Output Methods Masterclass ===\\n\");\n\n        demonstrateBasicOutput();\n        demonstrateFormattedOutput();\n        demonstrateErrorOutput();\n        demonstrateAdvancedFormatting();\n        demonstrateLogging();\n        demonstrateConsoleClass();\n        OutputUtils.demoTableOutput();\n    }\n\n    public static void demonstrateBasicOutput() {\n        System.out.println(\"1. Basic Output Methods:\");\n\n        // print() - no newline\n        System.out.print(\"Hello, \");\n        System.out.print(\"World! \");\n\n        // println() - with newline\n        System.out.println(\"This appears on a new line.\");\n\n        // printf() - formatted output\n        String name = \"Alice\";\n        int age = 25;\n        double score = 95.5;\n        System.out.printf(\"Name: %s, Age: %d, Score: %.1f%%\\n\", name, age, score);\n\n        // String concatenation\n        System.out.println(\"Welcome \" + name + \"! You are \" + age + \" years old.\");\n    }\n\n    public static void demonstrateFormattedOutput() {\n        System.out.println(\"\\n2. Formatted Output (printf & Formatter):\");\n\n        // Table-style formatting with printf\n        System.out.printf(\"%-15s %-10s %-8s\\n\", \"Name\", \"Age\", \"Score\");\n        System.out.printf(\"%-15s %-10d %-8.2f\\n\", \"Alice\", 25, 95.5);\n        System.out.printf(\"%-15s %-10d %-8.2f\\n\", \"Bob\", 30, 88.75);\n        System.out.printf(\"%-15s %-10d %-8.2f\\n\", \"Charlie\", 22, 91.25);\n\n        // Number formatting\n        double price = 1234.5678;\n        int quantity = 1500;\n        System.out.printf(\"\\nNumber Formatting:\\n\");\n        System.out.printf(\"Price: $%,.2f\\n\", price);\n        System.out.printf(\"Quantity: %,d units\\n\", quantity);\n        System.out.printf(\"Total: $%,.2f\\n\", price * quantity);\n\n        // Date formatting\n        Date now = new Date();\n        System.out.printf(\"Current date: %tF\\n\", now);\n        System.out.printf(\"Current time: %tT\\n\", now);\n\n        // Formatter class for reusable formatted output\n        Formatter formatter = new Formatter();\n        formatter.format(\"%-20s %-10s %-10s\\n\", \"Product\", \"Price\", \"In Stock\");\n        formatter.format(\"%-20s %-10.2f %-10b\\n\", \"Laptop\", 999.99, true);\n        formatter.format(\"%-20s %-10.2f %-10b\\n\", \"Mouse\", 25.50, false);\n        System.out.println(formatter.toString());\n        formatter.close();\n\n        // String.format for creating formatted strings\n        String summary = String.format(\"Customer: %s | Balance: $%,.2f | Status: %s\", \"John Doe\", 12345.67, \"Active\");\n        System.out.println(summary);\n    }\n\n    public static void demonstrateErrorOutput() {\n        System.out.println(\"\\n3. Error Output (System.err):\");\n        System.out.println(\"This is normal output\");\n        System.err.println(\"This is error output\");\n        System.err.println(\"Warning: Something might be wrong!\");\n\n        // Exception demonstration\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public static void demonstrateAdvancedFormatting() {\n        System.out.println(\"\\n4. Advanced Formatting Techniques:\");\n\n        String multiLine = String.format(\"\"\"\n            Customer Information:\n            =====================\n            Name:   %s\n            Email:  %s\n            Phone:  %s\n            Balance: $%,.2f\n            \"\"\", \"Alice Smith\", \"alice@email.com\", \"(555) 123-4567\", 5432.10);\n        System.out.println(multiLine);\n    }\n\n    public static void demonstrateLogging() {\n        System.out.println(\"\\n5. Logging Simulation:\");\n        System.out.println(\"[INFO] Application started successfully\");\n        System.out.println(\"[DEBUG] Loading configuration files\");\n        System.out.println(\"[WARN] Configuration file not found, using defaults\");\n        System.out.println(\"[ERROR] Failed to connect to database\");\n\n        System.out.println(\"\\nFor production logging, use:\");\n        System.out.println(\"- java.util.logging (JUL)\");\n        System.out.println(\"- Log4j 2\");\n        System.out.println(\"- SLF4J with Logback\");\n    }\n\n    public static void demonstrateConsoleClass() {\n        System.out.println(\"\\n6. Interactive Console I/O:\");\n        Console console = System.console();\n        if (console != null) {\n            String username = console.readLine(\"Enter username: \");\n            char[] password = console.readPassword(\"Enter password: \");\n            console.printf(\"Welcome, %s!\\n\", username);\n            Arrays.fill(password, ' ');\n        } else {\n            System.out.println(\"Console not available (IDEs may not support it)\");\n        }\n    }\n}\n\nclass OutputUtils {\n\n    public static void printHeader(String title) {\n        System.out.println(\"\\n\" + \"=\".repeat(50));\n        System.out.println(title);\n        System.out.println(\"=\".repeat(50));\n    }\n\n    public static void printTable(String[] headers, String[][] data) {\n        int[] widths = new int[headers.length];\n        for (int i = 0; i < headers.length; i++) widths[i] = headers[i].length();\n        for (String[] row : data) for (int i = 0; i < row.length; i++) widths[i] = Math.max(widths[i], row[i].length());\n\n        printTableRow(headers, widths);\n        System.out.print(\"+\");\n        for (int w : widths) System.out.print(\"-\".repeat(w + 2) + \"+\");\n        System.out.println();\n        for (String[] row : data) printTableRow(row, widths);\n    }\n\n    private static void printTableRow(String[] row, int[] widths) {\n        System.out.print(\"|\");\n        for (int i = 0; i < row.length; i++) System.out.printf(\" %-\" + widths[i] + \"s |\", row[i]);\n        System.out.println();\n    }\n\n    public static void demoTableOutput() {\n        String[] headers = {\"ID\", \"Name\", \"Department\", \"Salary\"};\n        String[][] data = {\n            {\"1\", \"Alice Johnson\", \"Engineering\", \"$85,000\"},\n            {\"2\", \"Bob Smith\", \"Marketing\", \"$72,500\"},\n            {\"3\", \"Charlie Brown\", \"Sales\", \"$68,000\"},\n            {\"4\", \"Diana Prince\", \"Engineering\", \"$92,000\"}\n        };\n        printHeader(\"Employee Directory\");\n        printTable(headers, data);\n    }\n}"
}, 
  {
    "title": "Java Comments",
    "note": "Single-line comments start with // and continue to the end of the line. Multi-line comments are enclosed between /* and */ and can span multiple lines. Comments are ignored by the compiler and are used to explain code, provide documentation, or temporarily disable code execution.",
    "code": "// This is a single-line comment\n/* This is a\n   multi-line comment */"
  },
  {
    "title": "Java Variables",
    "note": "Variables are containers that store data values in memory. They must be declared with a specific data type before use (type name = value). Java variables are case-sensitive and follow camelCase naming convention. Variables can be reassigned new values as long as the type remains compatible.",
    "code": "int age = 25;\nString name = \"Alice\";"
  },
  {
    "title": "Java Data Types",
    "note": "Java has two main data type categories: primitive types (int, double, boolean, char, byte, short, long, float) which store simple values directly, and reference types (objects, arrays, Strings) which store references to memory locations. Primitive types have fixed sizes and default values, while reference types default to null.",
    "code": "int x = 10;\ndouble pi = 3.14;\nboolean isTrue = false;"
  },
  {
    "title": "Java Type Casting",
    "note": "Type casting converts a value from one data type to another. Widening casting (implicit) occurs automatically when converting from a smaller to larger type (int to double). Narrowing casting (explicit) requires manual intervention using parentheses and converts from larger to smaller types, potentially causing data loss (double to int).",
    "code": "int x = (int) 3.14; // explicit\ndouble y = 10;     // implicit"
  },
  {
    "title": "Java Operators",
    "note": "Operators perform operations on variables and values. Arithmetic operators (+, -, *, /, %) perform mathematical calculations. Comparison operators (==, !=, >, <, >=, <=) compare values and return boolean results. Logical operators (&&, ||, !) combine boolean expressions. Assignment operators (=, +=, -=, *=, /=) assign values to variables.",
    "code": "int sum = 5 + 3;\nboolean result = (5 > 3) && (2 < 4);"
  },
  {
    "title": "Java Strings",
    "note": "Strings are immutable objects that represent sequences of characters, implemented through the String class. They can be created using string literals (pooled for memory efficiency) or with the 'new' keyword. The String class provides numerous methods for manipulation (length(), substring(), toUpperCase(), toLowerCase(), trim(), replace(), etc.), comparison (equals(), compareTo()), and searching (indexOf(), contains()). Strings support concatenation using the + operator.",
    "code": "String greeting = \"Hello\";\nSystem.out.println(greeting.toUpperCase());"
  },
  {
    "title": "Java Math",
    "note": "The Math class in java.lang package provides static methods for performing common mathematical operations without needing to create an instance. It includes methods for basic arithmetic (abs(), max(), min()), exponential functions (pow(), sqrt(), exp(), log()), trigonometric functions (sin(), cos(), tan()), rounding operations (round(), ceil(), floor()), and random number generation (random()). All methods are static and called directly on the Math class.",
    "code": "int absVal = Math.abs(-10);\ndouble sqrtVal = Math.sqrt(16);"
  },
  {
    "title": "Java Booleans",
    "note": "The boolean primitive data type can only store two values: true or false. Boolean values are fundamental for controlling program flow through conditional statements and loops. They are typically the result of comparison operations (==, !=, >, <, >=, <=) and logical operations (&&, ||, !). Boolean variables default to false when declared as instance variables, but must be explicitly initialized when declared as local variables.",
    "code": "boolean isActive = true;\nboolean isDone = false;"
  },
  {
    "title": "Java If...Else",
    "note": "If-else statements control program flow based on boolean conditions. The 'if' block executes when the condition is true, while the optional 'else' block executes when false. Multiple conditions can be chained using 'else if'. Curly braces are required for multi-line code blocks but optional for single statements (though recommended for readability). Conditions can be complex expressions combining multiple boolean operations using logical operators.",
    "code": "if (age >= 18) {\n    System.out.println(\"Adult\");\n} else {\n    System.out.println(\"Minor\");\n}"
  },
  {
    "title": "Java Switch",
    "note": "Switch statements provide an efficient alternative to multiple if-else-if chains when testing a single variable against multiple constant values. They work with byte, short, char, int, String, and enum types. Each 'case' represents a possible value, and the 'default' case handles all unmatched values. The 'break' statement prevents fall-through to subsequent cases, while its absence allows intentional fall-through behavior. Java 14+ introduced enhanced switch expressions with arrow syntax and yield statements.",
    "code": "switch(day) {\n  case 1:\n    System.out.println(\"Monday\");\n    break;\n  default:\n    System.out.println(\"Other day\");\n}"
  },
  {
    "title": "Java While Loop",
    "note": "While loops repeatedly execute a code block as long as the specified boolean condition remains true. The condition is evaluated before each iteration, meaning the loop may execute zero times if the condition is initially false. While loops are ideal when the number of iterations is unknown beforehand but depends on a changing condition. Care must be taken to ensure the condition eventually becomes false to prevent infinite loops.",
    "code": "int i = 0;\nwhile (i < 5) {\n    System.out.println(i);\n    i++;\n}"
  },
  {
    "title": "Java For Loop",
    "note": "For loops provide compact syntax for iteration with three components: initialization (executed once), condition (checked before each iteration), and update (executed after each iteration). They are ideal when the number of iterations is known in advance. The loop variable is typically declared within the for statement, limiting its scope to the loop. Enhanced for loops (for-each) provide simplified syntax for iterating through arrays and collections without explicit index management.",
    "code": "for (int i = 0; i < 5; i++) {\n    System.out.println(i);\n}"
  },
  {
    "title": "Java Break/Continue",
    "note": "The 'break' statement terminates the innermost loop or switch statement immediately, transferring control to the next statement after the loop/switch. The 'continue' statement skips the remaining code in the current iteration and proceeds to the next iteration of the loop. Both statements are typically used with conditional logic to alter normal loop behavior. Labeled break and continue statements can control outer loops from within nested loops when specific labels are used.",
    "code": "for (int i=0; i<5; i++) {\n  if (i==3) break;\n  if (i==1) continue;\n  System.out.println(i);\n}"
  },
  {
    "title": "Java Arrays",
    "note": "Arrays are fixed-size data structures that store elements of the same type in contiguous memory locations. Elements are accessed by zero-based index. Arrays can be declared and initialized in several ways: with explicit size (new int[5]), with initial values ({1,2,3}), or through multi-step declaration and initialization. Arrays have a 'length' property (not a method) that returns the fixed size. Multi-dimensional arrays are arrays of arrays, allowing matrix-like structures with potentially varying row lengths.",
    "code": "int[] numbers = {1, 2, 3, 4};\nSystem.out.println(numbers[0]);"
  },
  {
    "title": "Java Methods",
    "note": "Methods are reusable blocks of code that perform specific tasks when called by name. They promote code reusability, modularity, and organization. Methods must be declared within a class and can have access modifiers (public, private, protected), return types (void if no return value), and parameters. The method signature consists of the method name and parameter list. Methods help avoid code duplication and make programs easier to maintain and debug.",
    "code": "public void greet() {\n    System.out.println(\"Hello from method!\");\n}"
  },
  {
    "title": "Java Method Parameters",
    "note": "Parameters (also called arguments) allow methods to accept input values that can be used within the method body. Parameters are declared in the method signature with their data types and names. Java uses pass-by-value, meaning copies of the values are passed to methods. Primitive types pass actual value copies, while object references pass copies of references (the original object can be modified through the reference). Methods can have multiple parameters separated by commas, and parameter order must match when calling the method.",
    "code": "public int add(int a, int b) {\n    return a + b;\n}"
  },
  {
    "title": "Java Method Overloading",
    "note": "Method overloading allows multiple methods to have the same name but different parameter lists (different number, type, or order of parameters). The compiler determines which method to call based on the arguments provided. Overloading enables polymorphism at compile-time and provides flexibility in method usage. Return type alone is not sufficient for overloading - methods must differ in their parameter signatures. Overloaded methods typically perform similar operations but on different data types or with different input combinations.",
    "code": "public int add(int a, int b) { return a + b; }\npublic double add(double a, double b) { return a + b; }"
  },
  {
    "title": "Java Scope",
    "note": "Scope defines the accessibility and lifetime of variables, methods, and classes within a program. Java has several scope levels: class scope (instance variables accessible throughout the class), method scope (local variables accessible only within the method), block scope (variables declared inside {} blocks accessible only within that block), and loop scope (variables declared in for loops accessible only within the loop). Variables shadow outer scope variables when they have the same name. Understanding scope prevents naming conflicts and manages memory efficiently.",
    "code": "{\n  int x = 5; // local to this block\n}\n// x not accessible here"
  },
  {
    "title": "Java Recursion",
    "note": "Recursion occurs when a method calls itself directly or indirectly to solve a problem by breaking it down into smaller, similar subproblems. Every recursive method must have a base case (terminating condition) that stops the recursion and a recursive case that reduces the problem size. Recursion is elegant for problems like tree traversals, mathematical sequences, and divide-and-conquer algorithms. However, it can be memory-intensive due to stack frame accumulation and may cause stack overflow for deep recursion. Tail recursion optimization can help mitigate some performance issues.",
    "code": "public int factorial(int n) {\n  if (n <= 1) return 1;\n  else return n * factorial(n - 1);\n}"
  },
  {
    "title": "Java Classes",
    "note": "Classes are fundamental templates or blueprints in object-oriented programming that define the structure and behavior of objects. A class encapsulates data (attributes/fields) and methods (functions) that operate on that data. Classes define the state (what an object knows) and behavior (what an object does). They serve as the foundation for creating objects through instantiation. Classes can contain constructors for object initialization, nested classes, and static members. They support access modifiers (public, private, protected) to control visibility and encapsulation.",
    "code": "public class Car {\n    String model;\n    int year;\n}"
  },
  {
    "title": "Java OOP",
    "note": "Object-Oriented Programming (OOP) is a programming paradigm based on four main principles: encapsulation (bundling data and methods that operate on that data, hiding internal implementation), inheritance (creating new classes from existing ones, promoting code reuse), polymorphism (objects of different classes responding to the same method call in different ways), and abstraction (hiding complex implementation details while exposing only essential features). OOP models real-world entities as objects that interact with each other, making programs more modular, maintainable, and scalable.",
    "code": "// Example: Creating an object\nCar myCar = new Car();"
  },
  {
    "title": "Java Classes/Objects",
    "note": "Classes are templates that define the structure and capabilities of objects, while objects are specific instances created from those classes. A class is like a blueprint, and objects are the actual houses built from that blueprint. Objects are created using the 'new' keyword followed by a constructor call. Each object has its own copy of instance variables (state) but shares method implementations (behavior). Objects can interact with each other through method calls and can be passed as parameters, returned from methods, or stored in collections.",
    "code": "Car myCar = new Car();\nmyCar.model = \"Toyota\";"
  },
  {
    "title": "Java Class Attributes",
    "note": "Class attributes (also called fields or instance variables) are variables declared within a class but outside any method. They define the state or properties of objects created from the class. Attributes can be of any data type (primitive or reference) and can have access modifiers (public, private, protected) to control visibility. Instance variables are initialized to default values (0, false, or null) if not explicitly initialized. Static attributes (class variables) are shared among all instances, while instance attributes have separate copies for each object.",
    "code": "public class Person {\n    String name;\n    int age;\n}"
  },
  {
    "title": "Java Class Methods",
    "note": "Class methods (also called member functions) are functions defined within a class that define the behavior of objects. They can access and modify the object's state (instance variables) and perform operations. Methods can be instance methods (require object instantiation) or static methods (called on the class itself). They support access modifiers (public, private, protected) to control visibility and can be declared as final (cannot be overridden), abstract (no implementation), or synchronized (thread-safe). Methods enable objects to communicate and interact with each other through well-defined interfaces.",
    "code": "public class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}"
  },
  {
    "title": "Java Constructors",
    "note": "Constructors are special methods that initialize newly created objects. They have the same name as the class and no return type (not even void). Constructors are called automatically when objects are created with the 'new' keyword. Classes can have multiple constructors through overloading (different parameter lists). If no constructor is defined, Java provides a default no-argument constructor. Constructors can call other constructors in the same class using 'this()' and parent class constructors using 'super()'. They ensure objects start in a valid, initialized state.",
    "code": "public class Person {\n    String name;\n    Person(String name) {\n        this.name = name;\n    }\n}"
  },
  {
    "title": "Java this Keyword",
    "note": "The 'this' keyword is a reference to the current object instance within non-static methods and constructors. It's primarily used to: resolve naming conflicts between instance variables and parameters (this.variable = parameter), call other constructors in the same class (this()), pass the current object as a parameter to other methods, or return the current object from methods. 'this' helps avoid ambiguity and makes code more readable by explicitly distinguishing instance members from local variables or parameters.",
    "code": "this.name = name; // Assign parameter to instance variable"
  },
  {
    "title": "Java Modifiers",
    "note": "Modifiers are keywords that define accessibility, behavior, and characteristics of classes, methods, and variables. Access modifiers (public, protected, private, package-private) control visibility scope. Non-access modifiers include: static (class-level rather than instance-level), final (cannot be changed or overridden), abstract (no implementation, must be extended), synchronized (thread-safe access), volatile (variable value changes are visible to all threads), and transient (exclude from serialization). Modifiers enforce encapsulation, security, and proper object-oriented design principles.",
    "code": "private int age;\npublic static final double PI = 3.14159;"
  },
  {
    "title": "Java Encapsulation",
    "note": "Encapsulation is a fundamental OOP principle that bundles data (attributes) and methods (behavior) together within a class while restricting direct access to internal implementation details. It's achieved by declaring fields as private and providing public getter and setter methods to control access. Encapsulation protects object integrity by validating data before assignment, enables controlled access through well-defined interfaces, allows internal implementation changes without affecting external code, and maintains data consistency by preventing unauthorized modifications.",
    "code": "private String name;\npublic String getName() { return name; }\npublic void setName(String n) { name = n; }"
  },
  {
    "title": "Java Packages / API",
    "note": "Packages are namespace mechanisms that organize related classes and interfaces into logical groups, preventing naming conflicts. The Java API (Application Programming Interface) provides a comprehensive collection of pre-built packages and classes for common programming tasks. Key packages include java.lang (fundamental classes), java.util (collections, date/time), java.io (input/output), and java.net (networking). Import statements allow classes to be used without fully qualified names. Packages facilitate code organization, reuse, and maintenance while providing a rich ecosystem of built-in functionality.",
    "code": "import java.util.ArrayList;\nArrayList<String> list = new ArrayList<>();"
  },
  {
    "title": "Java Inheritance",
    "note": "Inheritance is an OOP mechanism where a class (subclass/child) acquires properties and behaviors from another class (superclass/parent). It promotes code reuse, establishes hierarchical relationships, and enables polymorphism. The 'extends' keyword creates inheritance relationships. Subclasses inherit all non-private members and can override methods to provide specialized implementations. Java supports single inheritance for classes (one parent only) but multiple inheritance through interfaces. Inheritance creates 'is-a' relationships and facilitates method overriding and dynamic method dispatch.",
    "code": "public class Dog extends Animal {\n    public void bark() {\n        System.out.println(\"Woof!\");\n    }\n}"
  },
  {
    "title": "Java Polymorphism",
    "note": "Polymorphism ('many forms') allows objects of different classes to be treated as objects of a common superclass and respond differently to the same method call. It occurs in two forms: compile-time polymorphism (method overloading) and runtime polymorphism (method overriding through inheritance). Polymorphism enables flexible, extensible code where the specific method implementation is determined at runtime based on the actual object type. This facilitates writing generic code that works with broad categories of objects while allowing specialized behavior through subclass implementations.",
    "code": "Animal a = new Dog();\na.makeSound(); // Calls Dog's version"
  },
  {
    "title": "Java super Keyword",
    "note": "The 'super' keyword refers to the immediate parent class object and is used to access parent class members (methods and variables) that are hidden or overridden by the subclass. It can call the parent class constructor (super() must be the first statement in a constructor), access parent class methods (super.method()), or reference parent class fields (super.field). 'super' enables subclasses to extend rather than completely replace parent functionality, maintain the parent class contract, and reuse validated parent class implementations while adding specialized behavior.",
    "code": "super(); // Calls parent class constructor"
  },
  {
    "title": "Java Inner Classes",
    "note": "Inner classes are classes defined within other classes, creating a logical grouping that enhances encapsulation and organization. Types include: member inner classes (regular classes within outer classes), local inner classes (defined within methods or blocks), anonymous inner classes (unnamed classes for one-time use, often for event handlers), and static nested classes (static members of outer classes). Inner classes can access all members of the outer class (including private ones) and are useful for implementing helper classes, event listeners, and specialized implementations that are tightly coupled to the outer class.",
    "code": "class Outer {\n    class Inner {\n        void display() { System.out.println(\"Inner class\"); }\n    }\n}"
  },
  {
    "title": "Java Abstraction",
    "note": "Abstraction is an OOP principle that hides complex implementation details while exposing only essential features and functionality. It's achieved through abstract classes (cannot be instantiated, may contain abstract methods without implementation) and interfaces. Abstraction focuses on what an object does rather than how it does it, reducing complexity by providing simplified interfaces. Abstract classes can contain both implemented and abstract methods, serving as partial implementations that must be completed by subclasses. Abstraction enables programming to interfaces rather than implementations, facilitating flexibility and maintainability.",
    "code": "abstract class Animal {\n    abstract void sound();\n}"
  },
  {
    "title": "Java Interface",
    "note": "Interfaces define contracts that classes must implement, specifying what methods a class must provide without defining how they're implemented. They contain abstract methods (implicitly public and abstract), constants (implicitly public, static, and final), and can include default and static methods (Java 8+). Interfaces enable multiple inheritance-like behavior (a class can implement multiple interfaces) and promote loose coupling. They're used to define capabilities, establish communication protocols between unrelated classes, and support polymorphism across different class hierarchies without requiring inheritance relationships.",
    "code": "interface Movable {\n    void move();\n}\nclass Car implements Movable {\n    public void move() { System.out.println(\"Car moves\"); }\n}"
  },
  {
    "title": "Java Enums",
    "note": "Enums (enumerations) are special classes that represent fixed sets of named constants, providing type safety and readability. They can contain fields, methods, and constructors (private by default). Enums implicitly extend java.lang.Enum and cannot extend other classes. They support switch statements, can implement interfaces, and provide built-in methods like values() and valueOf(). Enums are ideal for representing predefined options (days, states, categories), preventing invalid values, and grouping related constants with associated behavior. They're more powerful and type-safe than traditional constant definitions.",
    "code": "enum Day { MONDAY, TUESDAY, WEDNESDAY }"
  },
  {
    "title": "Java User Input",
    "note": "Java provides the Scanner class in java.util package to read user input from various sources, primarily System.in (keyboard input). Scanner offers methods to read different data types: nextLine() for strings, nextInt() for integers, nextDouble() for doubles, nextBoolean() for booleans, etc. It handles tokenization and parsing automatically. Always close Scanner objects with close() to release resources. For more advanced input handling, BufferedReader with InputStreamReader can be used for better performance with large inputs.",
    "code": "import java.util.Scanner;\nScanner sc = new Scanner(System.in);\nString name = sc.nextLine();"
  },
  {
    "title": "Java Date",
    "note": "Java offers multiple date/time APIs: legacy java.util.Date and java.util.Calendar (thread-unsafe and poorly designed), and modern java.time package (Java 8+). The java.time package includes LocalDate (date only), LocalTime (time only), LocalDateTime (both), ZonedDateTime (with timezone), and Instant (machine-time timestamp). The new API is immutable, thread-safe, and follows ISO-8601 standards. DateTimeFormatter handles parsing and formatting. Always prefer java.time over legacy classes for new development.",
    "code": "import java.util.Date;\nDate now = new Date();\nSystem.out.println(now);"
  },
  {
    "title": "Java Errors",
    "note": "Java errors are problems that prevent normal program execution, categorized as: compile-time errors (syntax violations caught during compilation), runtime errors (exceptions occurring during execution), and logical errors (incorrect program behavior despite correct syntax). Common errors include NullPointerException (accessing null references), ArrayIndexOutOfBoundsException (invalid array access), ClassCastException (invalid casting), and OutOfMemoryError (insufficient heap space). Understanding error types and stack traces is crucial for effective debugging and robust application development.",
    "code": "// Example: ArrayIndexOutOfBoundsException\nint[] arr = new int[3];\narr[5] = 10; // Error"
  },
  {
    "title": "Java Debugging",
    "note": "Debugging is the process of identifying, analyzing, and resolving defects in code. Techniques include: using IDE debuggers (breakpoints, step execution, variable inspection), print debugging (System.out.println), logging frameworks (Log4j, SLF4J), exception stack trace analysis, and unit testing. Effective debugging requires understanding program flow, variable states, and execution context. Modern IDEs provide advanced debugging features like conditional breakpoints, watch expressions, and remote debugging. Systematic debugging approaches help isolate issues and verify fixes.",
    "code": "System.out.println(\"Debug info: variable x = \" + x);"
  },
  {
    "title": "Java Exceptions",
    "note": "Exceptions are events that disrupt normal program flow and are handled through try-catch-finally blocks. Checked exceptions (compile-time) must be declared or handled (IOException, SQLException). Unchecked exceptions (runtime) extend RuntimeException and don't require explicit handling (NullPointerException, IllegalArgumentException). The try block contains risky code, catch blocks handle specific exceptions, and finally blocks execute cleanup code regardless of exceptions. Custom exceptions can be created by extending Exception or RuntimeException. Proper exception handling prevents crashes and enables graceful error recovery.",
    "code": "try {\n    int result = 10 / 0;\n} catch (ArithmeticException e) {\n    System.out.println(\"Cannot divide by zero!\");\n}"
  },
  {
    "title": "Java File Handling",
    "note": "Java provides comprehensive file I/O capabilities through java.io and java.nio packages. File operations include creating, reading, writing, deleting, and manipulating files and directories. Stream-based I/O (FileInputStream, FileOutputStream) handles raw byte data, while Reader/Writer classes (FileReader, FileWriter) handle character data. Buffered classes (BufferedReader, BufferedWriter) improve performance. The newer java.nio.file package (Paths, Files) offers modern, non-blocking I/O operations with better exception handling and symbolic link support. Always close resources using try-with-resources to prevent leaks.",
    "code": "import java.io.*;\n\nFile file = new File(\"data.txt\");"
  },
  {
    "title": "Java Files",
    "note": "The File class (java.io.File) represents file and directory pathnames, providing methods to check file properties (exists(), isFile(), isDirectory(), canRead(), canWrite()), get metadata (length(), lastModified()), perform operations (createNewFile(), delete(), mkdir(), listFiles()), and manipulate paths (getName(), getPath(), getAbsolutePath()). However, File has limitations: no symbolic link support, poor error handling, and blocking operations. The newer java.nio.file.Path interface and Files utility class are recommended for new development as they offer better performance and features.",
    "code": "File file = new File(\"data.txt\");\nif(file.exists()) {\n    System.out.println(\"File exists\");\n}"
  },
  {
    "title": "Java Create/Write Files",
    "note": "Creating and writing files can be done using various approaches: FileWriter for simple character writing (but lacks buffering), BufferedWriter for efficient character output, FileOutputStream for raw bytes, PrintWriter for formatted text output, and Files.write() (java.nio) for modern convenience. Always use try-with-resources to ensure proper resource closure. Character encoding can be specified (UTF-8, ISO-8859-1) to handle international text. File writing operations may throw IOException if the file doesn't exist, is inaccessible, or if disk space is insufficient.",
    "code": "try (FileWriter writer = new FileWriter(\"data.txt\")) {\n    writer.write(\"Hello, World!\");\n} catch (IOException e) {\n    e.printStackTrace();\n}"
  },
  {
    "title": "Java Read Files",
    "note": "Reading files involves several approaches: FileReader for simple character reading, BufferedReader for efficient line-by-line reading, FileInputStream for byte-level access, Scanner for parsed input, and Files.readAllLines() (java.nio) for convenient bulk reading. BufferedReader.readLine() is efficient for text files as it minimizes I/O operations. For large files, stream processing (reading in chunks) prevents memory issues. Character encoding must match the file's encoding to avoid corruption. Always handle IOException for file not found, permission denied, or other I/O errors.",
    "code": "try (BufferedReader reader = new BufferedReader(new FileReader(\"data.txt\"))) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}"
  },
  {
    "title": "Java Delete Files",
    "note": "File deletion is performed using File.delete() method which returns true if successful, false otherwise. Common reasons for failure include: file doesn't exist, insufficient permissions, file is open/locked by another process, or it's a non-empty directory. The Files.delete() method (java.nio) provides better error information through exceptions. For directories, ensure they're empty before deletion or use recursive deletion methods. Secure deletion (overwriting data) requires special utilities. Always check deletion results and handle potential SecurityException for permission issues.",
    "code": "File file = new File(\"data.txt\");\nif (file.delete()) {\n    System.out.println(\"File deleted successfully\");\n} else {\n    System.out.println(\"Failed to delete the file\");\n}"
  },
  {
    "title": "Java Data Structures",
    "note": "Data structures are specialized formats for organizing, storing, and manipulating data efficiently. Java provides built-in data structures through the Collections Framework and arrays. Arrays offer fixed-size, indexed storage for primitives and objects. The Collections Framework includes Lists (ordered, indexed), Sets (unique elements), Queues (FIFO/LIFO), Maps (key-value pairs), and specialized implementations. Choosing the right data structure depends on requirements: access patterns (random, sequential), mutation frequency, ordering needs, memory constraints, and performance characteristics (time complexity of operations).",
    "code": "// Example: Using an array\nint[] numbers = {1, 2, 3, 4};"
  },
  {
    "title": "Java Collections",
    "note": "The Java Collections Framework provides a unified architecture for representing and manipulating collections of objects. It includes interfaces (Collection, List, Set, Queue, Map, Iterator, Comparable, Comparator), implementations (ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap), and algorithms (sorting, searching, shuffling) in java.util package. Collections are type-safe through generics, support iteration, and provide various operations (add, remove, contains, size). The framework promotes code reuse, interoperability, and provides high-performance, well-tested data structure implementations that reduce development effort.",
    "code": "import java.util.*;\nList<String> list = new ArrayList<>();"
  },
  {
    "title": "Java List",
    "note": "List is an ordered Collection that maintains elements in a specific sequence and allows duplicate elements. It provides positional access (get, set, add at index), search (indexOf, lastIndexOf), iteration (ListIterator with bidirectional traversal), and range operations (sublist). Main implementations: ArrayList (resizable array, fast random access), LinkedList (doubly-linked list, fast insertions/deletions), Vector (synchronized, legacy), and CopyOnWriteArrayList (thread-safe for read-heavy workloads). Lists are ideal when element order matters or when duplicates are required, such as maintaining insertion sequences or sorted collections.",
    "code": "List<String> fruits = new ArrayList<>();\nfruits.add(\"Apple\");"
  },
  {
    "title": "Java ArrayList",
    "note": "ArrayList is a resizable-array implementation of the List interface that provides fast O(1) random access via indexing but slower O(n) insertions/removals in the middle. It automatically grows when capacity is exceeded (typically by 50%) and shrinks when trimmed. ArrayList is not synchronized (not thread-safe) but can be wrapped with Collections.synchronizedList(). It's ideal for read-heavy workloads, random access patterns, and when the approximate size is known beforehand. Performance considerations include initial capacity tuning and avoiding frequent middle insertions which require element shifting.",
    "code": "ArrayList<Integer> numbers = new ArrayList<>();\nnumbers.add(10);"
  },
  {
    "title": "Java LinkedList",
    "note": "LinkedList is a doubly-linked list implementation of both List and Deque interfaces. It provides O(1) insertions/removals at both ends but O(n) random access (slow indexing). Each element (node) contains references to previous and next nodes, enabling efficient additions/removals anywhere in the list without shifting elements. LinkedList consumes more memory per element due to node overhead. It's ideal for frequent additions/removals, implementing stacks/queues, or when memory usage is less critical than modification performance. Not thread-safe but can be synchronized externally.",
    "code": "LinkedList<String> names = new LinkedList<>();\nnames.add(\"Alice\");"
  },
  {
    "title": "Java List Sorting",
    "note": "List sorting can be performed using Collections.sort() which uses a modified mergesort algorithm (stable, O(n log n)) or List.sort() (Java 8+). For natural ordering, elements must implement Comparable interface. Custom sorting can be achieved using Comparator implementations for different ordering logic (reverse order, multiple fields, custom criteria). Java 8+ introduced lambda expressions and method references for concise Comparator creation. Sorting performance considerations include element comparison cost and list implementation characteristics (ArrayList sorts faster than LinkedList due to better memory locality).",
    "code": "Collections.sort(fruits);\n// For custom sort: Collections.sort(list, Comparator);"
  },
  {
    "title": "Java Set",
    "note": "Set is a Collection that contains no duplicate elements and models mathematical set abstraction. It ensures uniqueness through element equality (equals() method) and may or may not maintain ordering. Core operations include add (returns false if duplicate), remove, contains (fast membership testing), and set operations (union, intersection, difference). Main implementations: HashSet (hash table, O(1) operations, no ordering), TreeSet (red-black tree, O(log n) operations, sorted ordering), LinkedHashSet (hash table + linked list, insertion-order), and EnumSet (bit vector, enum-specific). Sets are ideal for uniqueness enforcement and mathematical set operations.",
    "code": "Set<String> set = new HashSet<>();\nset.add(\"Java\");"
  },
  {
    "title": "Java HashSet",
    "note": "HashSet is a hash table-based implementation of the Set interface that provides constant-time O(1) performance for basic operations (add, remove, contains) assuming good hash function and proper capacity. It doesn't maintain any order of elements and permits null elements. Backed by a HashMap, it uses hashCode() for bucketing and equals() for collision resolution. Performance depends on initial capacity and load factor (default 0.75). Not synchronized but can be wrapped with Collections.synchronizedSet(). Ideal for general-purpose sets where ordering doesn't matter and fast membership testing is required.",
    "code": "HashSet<Integer> numbers = new HashSet<>();\nnumbers.add(1);"
  },
  {
    "title": "Java TreeSet",
    "note": "TreeSet is a red-black tree (self-balancing binary search tree) implementation of the NavigableSet interface that maintains elements in sorted order (natural ordering or specified Comparator). Provides O(log n) time for basic operations and guaranteed log(n) time for add, remove, and contains. Offers additional navigation methods (lower, floor, ceiling, higher) and range views (subSet, headSet, tailSet). Doesn't permit null elements if natural ordering is used. Not synchronized but can be wrapped. Ideal when sorted iteration or range queries are needed, or when elements need to be automatically sorted upon insertion.",
    "code": "TreeSet<String> sortedSet = new TreeSet<>();\nsortedSet.add(\"B\");"
  },
  {
    "title": "Java LinkedHashSet",
    "note": "LinkedHashSet is a hash table and linked list implementation of the Set interface that maintains a doubly-linked list running through all entries. This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). It provides predictable iteration order while offering HashSet's performance characteristics for add, contains, and remove operations. LinkedHashSet spares clients from the unspecified, generally chaotic ordering provided by HashSet without incurring the increased cost associated with TreeSet. It permits null elements and is not synchronized.",
    "code": "LinkedHashSet<String> linkedSet = new LinkedHashSet<>();"
  },
  {
    "title": "Java Map",
    "note": "Map is an object that maps keys to values, where each key must be unique (no duplicate keys) but values can be duplicated. A map cannot contain duplicate keys; each key can map to at most one value. The Map interface provides three collection views: set of keys, collection of values, and set of key-value mappings. Common operations include put (add key-value pair), get (retrieve value by key), remove (remove mapping by key), containsKey, containsValue, and size. Maps are essential for associative arrays, dictionaries, caches, and any scenario requiring efficient key-based value retrieval.",
    "code": "Map<Integer, String> map = new HashMap<>();"
  },
  {
    "title": "Java HashMap",
    "note": "HashMap is a hash table-based implementation of the Map interface that provides constant-time O(1) performance for basic operations (get and put) assuming the hash function disperses elements properly among buckets. It permits null values and the null key, is not synchronized, and makes no guarantees about the order of the map. HashMap is backed by an array of buckets where each bucket is a linked list (or tree in Java 8+ for large collisions). Performance depends on initial capacity and load factor. It's the most commonly used Map implementation for general-purpose key-value storage.",
    "code": "HashMap<String, Integer> map = new HashMap<>();\nmap.put(\"One\", 1);"
  },
  {
    "title": "Java TreeMap",
    "note": "TreeMap is a Red-Black tree-based implementation of the NavigableMap interface that maintains entries in sorted order according to the natural ordering of its keys or by a Comparator provided at map creation time. This guarantees O(log n) time cost for containsKey, get, put, and remove operations. TreeMap provides guaranteed log(n) time cost for these operations and additional methods like firstKey, lastKey, headMap, tailMap, and subMap for range operations. It doesn't permit null keys if natural ordering is used but permits null values. Ideal when sorted key-order iteration is required.",
    "code": "TreeMap<Integer, String> treeMap = new TreeMap<>();"
  },
  {
    "title": "Java LinkedHashMap",
    "note": "LinkedHashMap is a hash table and linked list implementation of the Map interface with predictable iteration order, which is normally the order in which keys were inserted into the map (insertion-order). It maintains a doubly-linked list running through all its entries, defining the iteration ordering. This implementation spares clients from the unspecified, generally chaotic ordering provided by HashMap without incurring the increased cost associated with TreeMap. It provides O(1) performance for basic operations while maintaining insertion order. Can also be configured to use access-order for LRU cache implementations.",
    "code": "LinkedHashMap<String, String> linkedMap = new LinkedHashMap<>();"
  },
  {
    "title": "Java Iterator",
    "note": "Iterator is an interface that provides a standard way to traverse through elements in a collection sequentially, allowing access to each element exactly once. It provides methods hasNext() (checks if more elements exist), next() (returns next element), and remove() (removes current element). Iterators are fail-fast - they throw ConcurrentModificationException if the collection is modified during iteration except through the iterator's own remove method. The enhanced for-loop (for-each) internally uses iterators. ListIterator extends Iterator for bidirectional traversal and element modification in Lists. Essential for safe collection traversal and element removal during iteration.",
    "code": "Iterator<String> it = list.iterator();\nwhile(it.hasNext()) {\n    System.out.println(it.next());\n}"
  },
  {
    "title": "Java Wrapper Classes",
    "note": "Wrapper classes provide object representations of the eight primitive data types (Integer, Double, Boolean, Character, Byte, Short, Long, Float), enabling primitives to be used in contexts that require objects (Collections, Generics). They offer utility methods for conversion (parseInt, valueOf), constants (MAX_VALUE, MIN_VALUE), and boxing/unboxing capabilities. Autoboxing (automatic conversion from primitive to wrapper) and unboxing (wrapper to primitive) were introduced in Java 5. Wrapper classes are immutable and final. Essential for storing primitive values in collections and working with reflection APIs that require objects.",
    "code": "Integer num = Integer.valueOf(10);\nDouble pi = Double.valueOf(3.14);"
  },
  {
    "title": "Java Generics",
    "note": "Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods. They provide stronger type checks at compile time, eliminate the need for explicit casting, and enable programmers to implement generic algorithms that work on collections of different types. Generics use type parameters (e.g., <T>, <K,V>) and support bounded type parameters (extends), wildcards (?), and generic methods. They ensure type safety in collections, prevent ClassCastException at runtime, and promote code reuse. The compiler performs type erasure, removing generic type information at runtime.",
    "code": "List<String> list = new ArrayList<>();"
  },
  {
    "title": "Java Annotations",
    "note": "Annotations provide metadata about program elements that can be used by the compiler, development tools, or at runtime through reflection. They start with @ symbol and can be applied to classes, methods, fields, parameters, and other program elements. Built-in annotations include @Override (method overrides superclass method), @Deprecated (element should no longer be used), @SuppressWarnings (suppress compiler warnings), and @FunctionalInterface (interface has exactly one abstract method). Custom annotations can be created using @interface. Annotations are widely used in frameworks like Spring, Hibernate, and JUnit for configuration and behavior modification.",
    "code": "@Override\npublic String toString() { return \"example\"; }"
  },
  {
    "title": "Java RegEx",
    "note": "Regular Expressions (RegEx) provide a powerful way to perform pattern matching and text manipulation through the java.util.regex package. The Pattern class compiles regex patterns, and Matcher class performs match operations against input strings. Regex supports character classes (\\d, \\w, \\s), quantifiers (*, +, ?, {n,m}), anchors (^, $), groups and capturing, alternation (|), and lookahead/lookbehind assertions. Common uses include validation (emails, phone numbers), search and replace, string splitting, and text parsing. Regex patterns should be compiled once and reused for efficiency in performance-critical code.",
    "code": "import java.util.regex.*;\nPattern p = Pattern.compile(\"a*b\");"
  },
  {
    "title": "Java Threads",
    "note": "Threads are lightweight processes that enable concurrent execution within a Java program, allowing multiple operations to proceed simultaneously. Threads share the same memory space but have their own stack. Threads can be created by extending Thread class or implementing Runnable interface (preferred). Key concepts include thread lifecycle (new, runnable, blocked, waiting, terminated), synchronization (synchronized keyword, locks), thread communication (wait, notify, notifyAll), and thread pools. Proper thread management is crucial for responsive applications, parallel processing, and efficient resource utilization in multi-core systems.",
    "code": "Thread t = new Thread(() -> System.out.println(\"Running in thread\"));\nt.start();"
  },
  {
    "title": "Java Lambda",
    "note": "Lambda expressions (Java 8+) provide a concise way to represent instances of single-method interfaces (functional interfaces) using arrow syntax (->). They enable functional programming features in Java, making code more readable and reducing boilerplate. Lambda expressions can capture effectively final variables from their enclosing scope. They're commonly used with the java.util.function package interfaces (Function, Predicate, Consumer, Supplier) and stream operations. Lambda expressions are implemented using invokedynamic and method handles for better performance. They facilitate writing more expressive, functional-style code for collections, event handlers, and parallel processing.",
    "code": "Runnable r = () -> System.out.println(\"Lambda expression\");"
  },
  {
    "title": "Java Advanced Sorting",
    "note": "Advanced sorting in Java involves using Comparator and Comparable interfaces for custom sorting logic. Comparable provides natural ordering (compareTo method), while Comparator allows multiple custom ordering strategies (compare method). Java 8+ enhanced sorting with method references (Comparator.comparing), chained comparators (thenComparing), and built-in comparators (naturalOrder, reverseOrder). For complex objects, sorting can be based on multiple fields, custom criteria, or derived properties. The sort stability (equal elements maintain relative order) is guaranteed. Advanced sorting is essential for domain-specific ordering requirements beyond primitive type comparisons.",
    "code": "Collections.sort(list, (a, b) -> a.length() - b.length());"
  },
  {
    "title": "Add Two Numbers",
    "note": "This simple method demonstrates basic arithmetic operation by adding two integer parameters and returning their sum. It showcases method definition with parameters and return type, fundamental arithmetic operations, and the simplicity of method invocation in Java. The method can be easily extended to handle different numeric types, overflow conditions, or additional mathematical operations. This pattern is fundamental to understanding method structure, parameter passing, and return values in Java programming.",
    "code": "public int add(int a, int b) {\n    return a + b;\n}"
  },
  {
    "title": "Count Words",
    "note": "This approach counts words in a string by splitting it using regular expression \\\\s+ which matches one or more whitespace characters (spaces, tabs, newlines). The split method returns an array of substrings, and the array length gives the word count. This method handles multiple spaces between words correctly but may not properly handle punctuation or special word boundaries. For more sophisticated word counting, consider using StringTokenizer or pattern matching with word boundary matchers (\\\\b). Always validate input for null values before processing.",
    "code": "String s = \"Hello world\";\nint count = s.split(\"\\\\s+\").length;"
  },
  {
    "title": "Reverse a String",
    "note": "This efficient method reverses a string using StringBuilder's reverse() method, which provides O(n) time complexity. StringBuilder is mutable and more efficient for string manipulation than immutable String objects. The approach handles Unicode characters including surrogate pairs correctly. Alternative methods include using character array swapping or recursion, but they are less efficient. For large strings or performance-critical applications, consider checking if reversal is actually needed or if the problem can be solved by processing the string in reverse order without creating a new string.",
    "code": "String reversed = new StringBuilder(s).reverse().toString();"
  },
  {
    "title": "Sum of Array Elements",
    "note": "This code calculates the sum of integer array elements using an enhanced for-loop (for-each) that iterates through each element. The for-each loop provides clean, readable syntax and avoids off-by-one errors. For very large arrays, consider using parallel streams (Arrays.stream(arr).parallel().sum()) for better performance on multi-core systems. The approach can be adapted for other numeric types (double, long) and can be extended to calculate other aggregates (product, average, min, max). Always handle potential integer overflow for large arrays by using long or BigInteger.",
    "code": "int sum = 0;\nfor(int num : arr) sum += num;"
  },
  {
    "title": "Convert String to Array",
    "note": "The toCharArray() method converts a string to a new character array, providing direct access to individual characters. This is useful for character-level manipulation, sorting, or algorithms requiring random access to characters. The resulting array length equals the string length, and each character maintains its position. Remember that character arrays are mutable, unlike strings. For Unicode strings, be aware that some characters may be represented by multiple char values (surrogate pairs). Alternative approaches include using charAt() for sequential access or getChars() for partial copying to existing arrays.",
    "code": "char[] chars = s.toCharArray();"
  },
  {
    "title": "Sort an Array",
    "note": "Arrays.sort() uses a tuned quicksort for primitive arrays (O(n log n) average, O(n²) worst-case) and mergesort for object arrays (guaranteed O(n log n)). For primitive arrays, sorting modifies the original array, while object arrays are sorted based on natural ordering (Comparable) or a provided Comparator. For large arrays, consider parallelSort() (Java 8+) which uses Fork/Join framework for better performance on multi-core systems. Sorting is essential for binary search, duplicate removal, range queries, and many algorithmic solutions that require ordered data.",
    "code": "Arrays.sort(arr);"
  },
  {
    "title": "Find Array Average",
    "note": "This calculates the average of array elements by first computing the sum and then dividing by the array length. The cast to double before division ensures floating-point division occurs, preventing integer truncation. For better numerical stability with large arrays, consider using a running average algorithm or using Java 8 streams (Arrays.stream(arr).average().getAsDouble()). Handle empty arrays to avoid division by zero. The approach can be extended to weighted averages or other statistical measures. For precise financial calculations, consider using BigDecimal instead of double.",
    "code": "double avg = (double) sum / arr.length;"
  },
  {
    "title": "Find Smallest Element",
    "note": "This uses Java 8 streams to find the minimum value in an array concisely. Arrays.stream() creates an IntStream, min() returns an OptionalInt, and getAsInt() extracts the value. This approach is elegant but creates some overhead compared to a simple loop. For better performance with large arrays, use traditional iteration (int min = arr[0]; for(int num : arr) if(num < min) min = num;). The stream approach can be easily modified to find maximum, average, or other statistics. Always check for empty arrays before calling getAsInt() to avoid NoSuchElementException.",
    "code": "int min = Arrays.stream(arr).min().getAsInt();"
  },
  {
    "title": "ArrayList Loop",
    "note": "This demonstrates iterating through an ArrayList using the enhanced for-loop (for-each), which is clean, readable, and avoids manual index management. The for-each loop internally uses an iterator and provides sequential access to elements. For scenarios requiring index access (updating elements, parallel processing), use traditional for-loop with get(index). For concurrent modification during iteration, use Iterator with remove() or ListIterator for bidirectional traversal. For large ArrayLists, consider that get(index) is O(1) while iterator traversal is also efficient due to array backing.",
    "code": "for(String item : list) {\n    System.out.println(item);\n}"
  },
  {
    "title": "HashMap Loop",
    "note": "Iterating through a HashMap can be done using several approaches: entrySet() for key-value pairs, keySet() for keys only, or values() for values only. The entrySet() approach is most efficient when both keys and values are needed, as it avoids separate lookups. HashMap iteration order is not guaranteed (unordered), unlike LinkedHashMap which maintains insertion order. For concurrent modification during iteration, use Iterator.remove() or consider ConcurrentHashMap. Java 8+ forEach method with lambda expressions provides a concise alternative: map.forEach((k, v) -> System.out.println(k + \": \" + v)).",
    "code": "for(Map.Entry<Key, Value> entry : map.entrySet()) {\n    System.out.println(entry.getKey() + \": \" + entry.getValue());\n}"
  },
  {
    "title": "Loop Through an Enum",
    "note": "Enums provide the values() method which returns an array of all enum constants in the order they were declared. This array can be iterated using enhanced for-loop, traditional for-loop, or Java 8+ streams. Enum iteration is useful for generating UI options, validation, or processing all possible values. The values() method returns a new array each time, so for performance-critical code, cache the result. Enums also support valueOf() method to get an enum constant by name. Enum iteration maintains the declared order, which is important for ordinal-dependent operations.",
    "code": "for(Day d : Day.values()) {\n    System.out.println(d);\n}"
  },
  {
    "title": "Area of Rectangle",
    "note": "The area of a rectangle is calculated by multiplying its width by height. This fundamental geometric operation demonstrates basic arithmetic in programming. The formula assumes consistent units (both dimensions in same unit). For integer dimensions, be aware of potential integer overflow with large values (use long or BigInteger if needed). The calculation can be encapsulated in a method with validation for non-negative dimensions. This pattern extends to other geometric shapes (circle, triangle) and forms the basis for more complex area calculations in graphics, CAD, and computational geometry applications.",
    "code": "int area = width * height;"
  },
  {
    "title": "Even or Odd Number",
    "note": "Checking even/odd status uses the modulus operator (%) which returns the remainder of division by 2. Even numbers have remainder 0, odd numbers have remainder 1. This is more efficient than division-based approaches. For negative numbers, the modulus operation works correctly in Java (unlike some languages). Alternative approaches include bitwise AND with 1 (num & 1 == 0 for even), but modulus is more readable. This check is fundamental in many algorithms: alternating patterns, parity checks, distribution balancing, and optimization problems where even/odd properties affect behavior.",
    "code": "if(num % 2 == 0) {\n    System.out.println(\"Even\");\n} else {\n    System.out.println(\"Odd\");\n}"
  },
  {
    "title": "Positive or Negative",
    "note": "This conditional check determines a number's sign by comparing with zero. The three-way classification (positive, negative, zero) is fundamental in mathematics and programming. For floating-point numbers, consider using tolerance checks rather than exact zero comparison due to precision issues. The approach can be extended to include special cases like NaN or infinity for double/float types. Sign checking is crucial in many domains: physics (direction), finance (profit/loss), graphics (coordinate systems), and algorithm design where behavior depends on value sign.",
    "code": "if(num > 0) System.out.println(\"Positive\");\nelse if(num < 0) System.out.println(\"Negative\");\nelse System.out.println(\"Zero\");"
  },
  {
    "title": "Square Root",
    "note": "Math.sqrt() calculates the square root of a double value using hardware-optimized native implementations. For negative inputs, it returns NaN. The method has high precision (within 1-2 ulp) and handles special cases like infinity and NaN appropriately. For integer square roots, consider casting or using Math.floor/ceil. For very precise calculations, consider alternative algorithms (Newton's method) or BigDecimal. Performance is typically excellent due to hardware support. Square roots are essential in distance calculations, statistics (standard deviation), graphics (normalization), and scientific computations.",
    "code": "double root = Math.sqrt(num);"
  },
  {
    "title": "Random Number",
    "note": "Random number generation using java.util.Random provides pseudorandom numbers with uniform distribution. nextInt(n) returns values from 0 (inclusive) to n (exclusive). For cryptographically secure random numbers, use java.security.SecureRandom. For better randomness quality, consider initializing with a seed or using ThreadLocalRandom (Java 7+) for multithreaded applications. Common patterns include shifting ranges (min + random.nextInt(max - min + 1)) or generating floating-point values. Random numbers are crucial in simulations, games, cryptography, sampling, and randomized algorithms.",
    "code": "int rand = new Random().nextInt(100); // 0-99"
  },
  {
    "title": "Java Reference",
    "note": "Java is a high-level, object-oriented programming language known for its platform independence (Write Once, Run Anywhere principle through JVM), robustness, security features, and rich standard library. Key characteristics include strong typing, automatic memory management (garbage collection), exception handling, multithreading support, and extensive APIs. Java applications range from enterprise systems and Android apps to web services and scientific computing. The language continues to evolve with regular releases adding features like modules (Java 9), var keyword (10), pattern matching (14), records (14), and sealed classes (15).",
    "code": "// Reference material for Java programming"
  },
  {
    "title": "Java Keywords",
    "note": "Java has 50+ reserved keywords that have predefined meanings and cannot be used as identifiers. These include primitive types (boolean, char, byte, short, int, long, float, double), flow control (if, else, switch, case, default, while, do, for, break, continue, return), access modifiers (public, protected, private), class-related (class, interface, enum, extends, implements, new, this, super), exception handling (try, catch, finally, throw, throws), and other special keywords (static, final, abstract, synchronized, volatile, transient, native, strictfp, assert, package, import).",
    "code": "abstract, boolean, break, class, final, for, if, new, public, static, void, while, etc."
  },
  {
    "title": "Java String Methods",
    "note": "The String class provides numerous methods for string manipulation: length() returns character count, charAt() gets character at index, substring() extracts portions, indexOf() finds character/string positions, contains() checks for substrings, equals() compares content, compareTo() orders lexicographically, toUpperCase()/toLowerCase() change case, trim() removes whitespace, replace() substitutes characters/strings, split() divides using regex, join() concatenates with delimiter, matches() tests against regex, startsWith()/endsWith() check prefixes/suffixes. Strings are immutable so methods return new strings.",
    "code": "String s = \"Hello\";\ns.length();\ns.substring(1, 3);"
  },
  {
    "title": "Java Math Methods",
    "note": "The Math class provides static methods for common mathematical operations: basic (abs() absolute value, max()/min() maximum/minimum), exponential (sqrt() square root, cbrt() cube root, pow() power, exp() e^x, log() natural log, log10() base-10 log), trigonometric (sin(), cos(), tan(), asin(), acos(), atan(), atan2()), hyperbolic (sinh(), cosh(), tanh()), angular (toRadians(), toDegrees()), rounding (ceil() round up, floor() round down, round() nearest integer, rint() double nearest), and random() for random 0.0-1.0. All handle edge cases like NaN and infinity appropriately.",
    "code": "Math.sqrt(16);\nMath.pow(2, 3);"
  },
  {
    "title": "Java Output Methods",
    "note": "System.out (PrintStream) provides output methods: print() prints without newline, println() prints with newline, printf() formatted output (like C's printf), format() same as printf. println() has overloads for all primitive types, char[], String, and Object (calls toString()). printf() uses format specifiers (%d integer, %f float, %s string, %c char, %b boolean, %n newline). System.err provides similar methods for error output. For advanced formatting, use Formatter class directly. Output can be redirected using System.setOut()/setErr().",
    "code": "System.out.println(\"Hello World\");"
  },
  {
    "title": "Java Arrays Methods",
    "note": "Arrays utility class provides static methods: sort() sorts arrays (quicksort primitives, mergesort objects), binarySearch() searches sorted arrays, fill() fills with value, equals() compares arrays, copyOf()/copyOfRange() copy arrays, asList() returns fixed-size list backed by array, toString()/deepToString() string representation, stream() creates stream from array, parallelSort() parallel sorting, parallelPrefix() parallel prefix computation, setAll()/parallelSetAll() set via generator function, spliterator() creates spliterator. Methods handle null elements and multidimensional arrays appropriately.",
    "code": "Arrays.sort(arr);\nint index = Arrays.binarySearch(arr, 5);"
  },
  {
    "title": "Java ArrayList Methods",
    "note": "ArrayList implements List with array backing: add()/addAll() append elements, get() access by index, set() replace at index, remove() remove by index or object, clear() remove all, size() get element count, isEmpty() check empty, contains() check existence, indexOf()/lastIndexOf() find positions, toArray() convert to array, subList() get view of portion, ensureCapacity() preallocate space, trimToSize() reduce capacity to size, forEach() iterate with action, replaceAll() transform elements, sort() sort with comparator, iterator()/listIterator() get iterators. Methods throw IndexOutOfBoundsException for invalid indices.",
    "code": "list.add(\"item\");\nlist.remove(0);"
  },
  {
    "title": "Java LinkedList Methods",
    "note": "LinkedList implements List and Deque with doubly-linked list: add()/addFirst()/addLast() add elements, get()/getFirst()/getLast() access elements, set() replace element, remove()/removeFirst()/removeLast() remove elements, size() get count, contains() check existence, indexOf() find position, clear() remove all, toArray() convert to array, descendingIterator() reverse iterator, offer()/offerFirst()/offerLast() add (capacity-restricted), poll()/pollFirst()/pollLast() retrieve and remove, peek()/peekFirst()/peekLast() retrieve without removal. Efficient for add/remove at ends but slow for random access.",
    "code": "linkedList.addFirst(\"start\");"
  },
  {
    "title": "Java HashMap Methods",
    "note": "HashMap implements Map with hash table: put()/putAll() add mappings, get() retrieve value by key, remove() remove mapping, containsKey()/containsValue() check existence, size() get mapping count, isEmpty() check empty, clear() remove all, keySet() get set of keys, values() get collection of values, entrySet() get set of entries, getOrDefault() get value or default, putIfAbsent() put if key absent, compute()/computeIfAbsent()/computeIfPresent() compute values, merge() merge values, replace()/replaceAll() replace values, forEach() iterate with action. Provides constant-time performance for basic operations.",
    "code": "map.put(\"key\", \"value\");\nmap.get(\"key\");"
  },
  {
    "title": "Java Scanner Methods",
    "note": "Scanner parses input into tokens: next() next token (whitespace-delimited), nextLine() next line, nextInt()/nextDouble() etc. next primitive, hasNext()/hasNextInt() etc. check next token type, useDelimiter() set token delimiter, locale() set locale for number formatting, radix() set number radix, close() close scanner, findInLine()/findWithinHorizon() find pattern, skip() skip pattern, toString() string representation. Methods throw InputMismatchException if token doesn't match expected type, NoSuchElementException if no more tokens, and IllegalStateException if scanner closed.",
    "code": "Scanner sc = new Scanner(System.in);\nint num = sc.nextInt();"
  },
  {
    "title": "Java Iterator Methods",
    "note": "Iterator provides collection traversal: hasNext() true if more elements, next() next element, remove() remove current element (optional operation), forEachRemaining() perform action on remaining elements. ListIterator extends Iterator for lists: hasPrevious()/previous() bidirectional traversal, nextIndex()/previousIndex() get indices, set() replace current element, add() insert element. Iterators are fail-fast - throw ConcurrentModificationException if collection modified during iteration except through iterator's own remove/set/add methods. Provides uniform way to traverse different collection types.",
    "code": "Iterator<String> it = list.iterator();\nwhile(it.hasNext()) {\n    System.out.println(it.next());\n}"
  },
  {
    "title": "Java Errors & Exceptions",
    "note": "Java has Throwable superclass with Error (serious unrecoverable JVM problems like OutOfMemoryError) and Exception (recoverable problems). Checked exceptions (IOException, SQLException) must be declared or handled. Unchecked exceptions (RuntimeException subclasses like NullPointerException, IllegalArgumentException) don't require handling. Exception handling: try (risky code), catch (handle exceptions), finally (cleanup), throw (throw exception), throws (declare exceptions). Best practices: catch specific exceptions, don't swallow exceptions, use try-with-resources, provide meaningful error messages, and use custom exceptions for domain-specific errors.",
    "code": "try {\n    // code\n} catch (Exception e) {\n    e.printStackTrace();\n}"
  },
  {
    "title": "Java Examples",
    "note": "Java examples provide practical implementations of programming concepts, ranging from basic 'Hello World' programs to complex enterprise applications. These examples help developers understand syntax, APIs, design patterns, and best practices. Common example categories include: language basics (variables, control structures), object-oriented programming (classes, inheritance), collections framework (lists, maps), exception handling, file I/O, multithreading, networking, database connectivity (JDBC), and framework usage (Spring, Hibernate). Studying and modifying examples accelerates learning and problem-solving skills by providing concrete patterns that can be adapted to specific use cases.",
    "code": "public class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}"
  },
  {
    "title": "Java Compiler",
    "note": "The Java compiler (javac) translates Java source code (.java files) into platform-independent bytecode (.class files) that can be executed by the Java Virtual Machine (JVM). Key compiler features include: syntax checking, type verification, optimization, and generation of debugging information. Common compiler options: -d specify output directory, -cp/-classpath set classpath, -source/-target set language version, -g generate debugging info, -nowarn suppress warnings, -verbose output compilation details. Modern IDEs automatically handle compilation, but understanding javac is essential for build automation, continuous integration, and troubleshooting compilation issues.",
    "code": "javac HelloWorld.java"
  },
  {
    "title": "Java Exercises",
    "note": "Java programming exercises are essential for developing practical coding skills and reinforcing theoretical knowledge. Effective exercises progress from basic syntax practice to complex algorithm implementation. Recommended exercise categories: basic syntax (variables, operators), control structures (loops, conditionals), methods and functions, array and string manipulation, object-oriented programming (class design, inheritance), collections framework, exception handling, file I/O operations, multithreading challenges, and algorithm implementation (sorting, searching, recursion). Platforms like LeetCode, HackerRank, and CodingBat provide graded exercises with automated testing to validate solutions.",
    "code": "// Implement factorial, Fibonacci, etc."
  },
  {
    "title": "Java Quiz",
    "note": "Java quizzes test conceptual understanding and practical knowledge through multiple-choice questions, code analysis, and debugging exercises. They cover topics including: language fundamentals, object-oriented principles, memory management, exception handling, collections framework, multithreading, Java APIs, and new language features. Quizzes help identify knowledge gaps, prepare for certifications, and reinforce learning through immediate feedback. Effective quizzes balance theoretical questions with practical code interpretation problems. Many online learning platforms and certification prep courses offer extensive quiz banks with explanations to deepen understanding of tricky concepts and common pitfalls.",
    "code": "// Multiple choice and coding quizzes"
  },
  {
    "title": "Java Server",
    "note": "Java server applications handle client requests, process business logic, and manage data persistence. Common Java server technologies include: Java Servlets (core web technology), JSP (JavaServer Pages), Spring Boot (modern application framework), Jakarta EE (enterprise edition), and microservices frameworks. Server applications typically involve: HTTP request handling, session management, database connectivity (JDBC, JPA), security implementation, RESTful web services, and deployment packaging (WAR, JAR files). Understanding servlet containers (Tomcat, Jetty) and application servers (WildFly, WebSphere) is crucial for developing scalable, secure, and maintainable server-side applications.",
    "code": "// Example using Java Servlets or Spring Boot"
  },
  {
    "title": "Java Syllabus",
    "note": "A comprehensive Java syllabus should cover: Java fundamentals (syntax, data types, operators), object-oriented programming (classes, objects, inheritance, polymorphism), exception handling, collections framework, file I/O, multithreading and concurrency, networking basics, database connectivity (JDBC), functional programming (lambdas, streams), modern features (modules, records, pattern matching), testing (JUnit), build tools (Maven, Gradle), and popular frameworks (Spring, Hibernate). The syllabus should progress from basic concepts to advanced topics, with practical projects at each stage to reinforce learning and build portfolio pieces.",
    "code": "// Topics and timeline for study"
  },
  {
    "title": "Java Study Plan",
    "note": "An effective Java study plan should include: foundation building (2-4 weeks for basic syntax and OOP), intermediate topics (2-3 weeks for collections, exceptions, I/O), advanced concepts (3-4 weeks for multithreading, networking, JDBC), framework learning (4-6 weeks for Spring, Hibernate), and project development (ongoing). Daily practice should mix theoretical learning (2-3 hours) with hands-on coding (3-4 hours), including algorithm practice, small projects, and code review. Weekly goals should be specific and measurable, with time allocated for revision and concept reinforcement. Consistency and practical application are key to mastery.",
    "code": "// Daily or weekly goals"
  },
  {
    "title": "Java Certificate",
    "note": "Oracle Java certifications validate professional competency and are recognized industry-wide. Key certifications include: Oracle Certified Associate (OCA) Java SE Programmer (foundational), Oracle Certified Professional (OCP) Java SE Programmer (intermediate/advanced), and specialized certifications for Java EE/Jakarta EE. Certification exams test knowledge of language features, API usage, platform characteristics, and troubleshooting skills. Preparation typically requires 3-6 months of study using official guides, practice exams, and hands-on coding. Certifications enhance career prospects, increase earning potential, and demonstrate commitment to professional development in Java programming.",
    "code": "// Oracle Java Certifications info"
  }
],
PHP: [
  {
    "title": "PHP Intro",
    "note": "PHP (Hypertext Preprocessor) is a widely-used open-source server-side scripting language specifically designed for web development. It can be embedded directly into HTML and is executed on the server, generating dynamic web page content. PHP supports numerous databases, protocols, and is compatible with most web servers and operating systems. It features a C-like syntax, extensive built-in functionality, and strong community support. PHP is particularly known for its ease of use, flexibility, and integration capabilities with various technologies, making it a foundational technology for many content management systems like WordPress and e-commerce platforms.",
    "code": "<?php\n// Hello World example\necho 'Hello, PHP!';\n?>"
  },
  {
    "title": "PHP Install",
    "note": "PHP can be installed through various methods: manually downloading from php.net, using system package managers (apt-get for Ubuntu, yum for CentOS, Homebrew for macOS), or installing pre-packaged solutions like XAMPP (cross-platform), WAMP (Windows), MAMP (macOS), or LAMP (Linux stack). These packages bundle PHP with Apache web server, MySQL database, and other utilities for a complete development environment. After installation, verify using 'php -v' in terminal/command prompt. Configuration is managed through php.ini file, which controls various runtime settings and extensions. For production environments, additional security hardening and performance tuning is recommended.",
    "code": "// Check PHP version\nphp -v"
  },
  {
    "title": "PHP Syntax",
    "note": "PHP syntax requires scripts to be enclosed within <?php ... ?> tags (or shorthand <? ... ?> if enabled). All statements must end with a semicolon (;). PHP is case-sensitive for variables but not for keywords (echo, if, while, etc.). The language supports mixing with HTML content, where only code within PHP tags is executed on the server. PHP files typically have .php extension and must be processed by a web server with PHP support. Basic syntax includes variables starting with $, comments using // or # for single-line and /* */ for multi-line, and code blocks enclosed in curly braces {} for control structures.",
    "code": "<?php\necho 'PHP syntax example';\n?>"
  },
  {
    "title": "PHP Comments",
    "note": "PHP supports three types of comments: single-line comments using // or #, and multi-line comments enclosed in /* ... */. Comments are ignored by the PHP parser and are essential for code documentation, explaining complex logic, temporarily disabling code, and providing metadata. Single-line comments extend to the end of the line, while multi-line comments can span multiple lines. Best practices include using comments to describe the purpose of functions, explain non-obvious code sections, and document parameters and return values. Comments should be maintained and updated alongside code changes to ensure accuracy.",
    "code": "<?php\n// This is a comment\n# Another comment\n/* Multi-line\ncomment */\n?>"
  },
  {
    "title": "PHP Variables",
    "note": "PHP variables are declared with a dollar sign $ followed by the variable name, which must start with a letter or underscore, followed by letters, numbers, or underscores. Variables are case-sensitive and don't require explicit type declaration (loosely typed). They are assigned using the = operator and can store various data types. Variables have different scopes: local (within function), global (accessible anywhere), static (persists between function calls), and superglobals (predefined arrays like $_GET, $_POST). Variables can be destroyed using unset() and checked for existence with isset() or empty().",
    "code": "<?php\n$name = 'Alice';\n$age = 25;\necho $name;\n?>"
  },
  {
    "title": "PHP Echo / Print",
    "note": "echo and print are language constructs used to output data to the browser or command line. echo can output multiple strings separated by commas, doesn't return a value, and is slightly faster. print outputs a single string and returns 1, allowing it to be used in expressions. Both can output HTML, variables, and expressions. echo has a shorthand syntax <?= $variable ?> for quick output. For more complex output formatting, printf() and sprintf() provide C-style formatted output. These output methods are essential for generating dynamic web content and debugging.",
    "code": "<?php\necho 'Hello World';\nprint 'Welcome to PHP';\n?>"
  },
  {
    "title": "PHP Data Types",
    "note": "PHP supports eight primitive data types: four scalar types (string, integer, float, boolean), two compound types (array, object), and two special types (resource, NULL). Strings can be single-quoted (literal) or double-quoted (parse variables and escape sequences). Integers can be decimal, hexadecimal, octal, or binary. Floats represent decimal numbers. Booleans are true or false. Arrays can be numeric, associative, or multidimensional. Objects are instances of classes. Resources are special handles to external resources. NULL represents a variable with no value. PHP is loosely typed but supports type declarations in functions.",
    "code": "<?php\n$number = 123;\n$text = 'Sample text';\n$isActive = true;\n?>"
  },
  {
    "title": "PHP Strings",
    "note": "PHP strings are sequences of characters that can be defined using single quotes (doesn't parse variables or most escape sequences) or double quotes (parses variables and escape sequences like \\n, \\t). The dot (.) operator concatenates strings. PHP provides extensive string functions: strlen() for length, strpos() for finding position, substr() for extracting parts, str_replace() for replacement, trim() for removing whitespace, and many more. Heredoc and Nowdoc syntax allow defining multi-line strings. Strings can be accessed like arrays using array syntax. Understanding string encoding (UTF-8) is crucial for international applications.",
    "code": "<?php\n$greeting = 'Hello';\n$name = 'World';\necho $greeting . ' ' . $name;\n?>"
  },
  {
    "title": "PHP Numbers",
    "note": "PHP handles two numeric types: integers (whole numbers) and floats (decimal numbers). Integers can be positive or negative and have platform-dependent size (usually 32-bit). Floats can represent decimal numbers or numbers in exponential form. PHP automatically converts between types when needed. Common numeric operations include arithmetic (+, -, *, /, %), increment/decrement (++, --), and comparison. Special numeric values include NAN and INF. PHP provides numerous math functions: round(), ceil(), floor() for rounding; abs() for absolute value; min(), max() for extremes; and rand(), mt_rand() for random numbers.",
    "code": "<?php\n$intNum = 10;\n$floatNum = 3.14;\n?>"
  },
  {
    "title": "PHP Casting",
    "note": "Type casting converts a value from one data type to another explicitly. PHP supports several casting methods: (int) or (integer) for integers, (float) or (double) for floating-point numbers, (string) for strings, (bool) or (boolean) for booleans, (array) for arrays, and (object) for objects. Casting follows specific rules: strings containing numbers convert to those numbers, empty values become 0 or false, arrays with elements become objects with properties, etc. PHP also performs implicit type conversion (type juggling) in expressions. Understanding casting is crucial for data validation, form processing, and working with databases.",
    "code": "<?php\n$number = (int) '123';\n$string = (string) 456;\n?>"
  },
  {
    "title": "PHP Math",
    "note": "PHP provides extensive mathematical capabilities through built-in functions and operators. Basic arithmetic operators (+, -, *, /, %) handle fundamental operations. Math functions include: abs() for absolute values, round()/ceil()/floor() for rounding, sqrt() for square roots, pow() for exponents, log()/log10() for logarithms, sin()/cos()/tan() for trigonometry, pi() for π constant, and rand()/mt_rand() for random numbers. For advanced mathematics, PHP supports arbitrary precision arithmetic with BC Math functions and GNU Multiple Precision functions. These mathematical capabilities are essential for calculations, algorithms, financial applications, and scientific computing.",
    "code": "<?php\necho sqrt(16); // 4\n?>"
  },
  {
    "title": "PHP Constants",
    "note": "Constants are identifiers for simple values that cannot change during script execution. They are defined using define('NAME', value) or const NAME = value (within classes). Constants are case-sensitive by default (use third parameter true in define() for case-insensitive). Unlike variables, constants don't use the $ prefix and have global scope. They can only contain scalar data (boolean, integer, float, string) or arrays. Common uses include configuration values, mathematical constants, and magic constants (predefined like __FILE__, __LINE__). Constants improve code readability, prevent accidental value changes, and centralize configuration.",
    "code": "<?php\ndefine('PI', 3.1416);\necho PI;\n?>"
  },
  {
    "title": "PHP Magic Constants",
    "note": "PHP provides several predefined magic constants that change depending on their context in the code. These include __LINE__ (current line number), __FILE__ (full path and filename), __DIR__ (directory of the file), __FUNCTION__ (function name), __CLASS__ (class name), __TRAIT__ (trait name), __METHOD__ (class method name), and __NAMESPACE__ (current namespace). Unlike regular constants, magic constants are resolved at compile time and provide valuable debugging information and metadata about the current execution context. They are particularly useful for logging, debugging, and building flexible, self-aware applications.",
    "code": "<?php\necho __FILE__;\n?>"
  },
  {
    "title": "PHP Operators",
    "note": "PHP supports a comprehensive set of operators: arithmetic operators (+, -, *, /, %), assignment operators (=, +=, -=, *=, /=, %=, .=), comparison operators (==, ===, !=, !==, <, >, <=, >=, <=>), increment/decrement operators (++, --), logical operators (&&, ||, !, and, or, xor), string operators (., .=), array operators (+, ==, ===, !=, !==, <>), and type operators (instanceof). The spaceship operator (<=>) introduced in PHP 7 returns -1, 0, or 1 for comparisons. Understanding operator precedence and associativity is crucial for writing correct expressions.",
    "code": "<?php\n$a = 5 + 3;\nif($a > 7 && $a < 10) { echo 'Yes'; }\n?>"
  },
  {
    "title": "PHP If...Else...Elseif",
    "note": "Conditional statements control program flow based on boolean expressions. The if statement executes code if condition is true. elseif (or else if) provides additional conditions to check if previous conditions are false. else provides a default block that executes when all conditions are false. Conditions can be complex expressions using comparison and logical operators. Curly braces are required for multi-statement blocks but optional for single statements (though recommended for readability). Alternative syntax using colons (if(): ... endif;) is available for better HTML integration. Proper conditional logic is fundamental to decision-making in programs.",
    "code": "<?php\nif($a > 10) {\n  echo 'Greater';\n} elseif($a == 10) {\n  echo 'Equal';\n} else {\n  echo 'Smaller';\n}\n?>"
  },
  {
    "title": "PHP Switch",
    "note": "The switch statement provides an efficient way to execute different code blocks based on a single expression's value. It compares the expression against multiple case values and executes the matching block. The break statement prevents fall-through to subsequent cases (unless intentional fall-through is desired). The default case handles values not matching any case. Switch statements are cleaner than multiple if-elseif statements when testing the same variable against multiple constant values. PHP 8 introduced match expressions as a more concise alternative for simple value matching with implicit return.",
    "code": "<?php\nswitch($color) {\n  case 'red':\n    echo 'Red';\n    break;\n  default:\n    echo 'Other';\n}\n?>"
  },
  {
    "title": "PHP Loops",
    "note": "PHP provides four loop types: for loops (execute code a specific number of times with initialization, condition, and increment), while loops (execute while condition is true, check condition before iteration), do-while loops (execute at least once, check condition after iteration), and foreach loops (iterate over arrays and objects). Loop control statements include break (exit loop), continue (skip to next iteration), and goto (jump to label). foreach is particularly powerful for array traversal, offering both value-only and key-value iteration. Loops are essential for processing collections and repetitive tasks.",
    "code": "<?php\nfor($i=0; $i<5; $i++) {\n  echo $i;\n}\n?>"
  },
  {
    "title": "PHP Functions",
    "note": "Functions encapsulate reusable code blocks that perform specific tasks. They are defined using the function keyword, can accept parameters (with type declarations and default values), and return values using return. PHP supports variable functions (call functions using variables), anonymous functions (closures), arrow functions (PHP 7.4+), and variadic functions (accept variable number of arguments). Functions can have parameters passed by value (default) or by reference (using &). Understanding function scope, recursion, and built-in functions is crucial for writing modular, maintainable code.",
    "code": "<?php\nfunction greet($name) {\n  return 'Hello ' . $name;\n}\necho greet('Alice');\n?>"
  },
  {
    "title": "PHP Arrays",
    "note": "Arrays in PHP are ordered maps that can hold multiple values of any type. They can be indexed arrays (numeric keys), associative arrays (string keys), or multidimensional arrays (arrays containing arrays). Arrays are created using array() or shorthand []. Key functions include count() for size, array_push()/array_pop() for stack operations, array_merge() for combining, array_keys()/array_values() for extraction, and various sorting functions (sort, asort, ksort, etc.). Arrays are flexible data structures used for collections, configuration, and data transformation in virtually all PHP applications.",
    "code": "<?php\n$colors = array('Red', 'Green', 'Blue');\necho $colors[0];\n?>"
  },
  {
    "title": "PHP Superglobals",
    "note": "Superglobals are built-in variables that are always available in all scopes. Key superglobals include: $_GET (URL parameters), $_POST (form data), $_REQUEST (combined GET/POST/cookie data), $_SERVER (server and execution environment information), $_SESSION (session variables), $_COOKIE (HTTP cookies), $_FILES (uploaded files), $_ENV (environment variables), and $GLOBALS (references all variables in global scope). These variables provide access to HTTP request data, server configuration, and user state. Proper validation and sanitization of superglobal data is critical for security to prevent injection attacks.",
    "code": "<?php\necho $_SERVER['PHP_SELF'];\n?>"
  },
  {
    "title": "PHP RegEx",
    "note": "PHP supports Perl-compatible regular expressions through PCRE functions. preg_match() checks if pattern matches, preg_match_all() finds all matches, preg_replace() performs search and replace, preg_split() splits string by pattern, and preg_grep() filters array elements. Patterns are delimited by characters (usually /) and can include modifiers (i for case-insensitive, m for multiline, etc.). Regular expressions are powerful for validation, extraction, and transformation of text data. Common patterns include email validation, URL parsing, and text formatting. Understanding regex syntax and performance implications is important for effective text processing.",
    "code": "<?php\nif(preg_match('/^a/', 'apple')) {\n  echo 'Match';\n}\n?>"
  },
  {
    "title": "PHP Forms",
    "note": "HTML forms are the primary method for collecting user input in web applications. Forms use <form> element with action (processing script URL), method (GET or POST), and enctype (encoding type, especially important for file uploads). Common form controls include text inputs, checkboxes, radio buttons, selects, and file uploads. Each control should have a name attribute for PHP access. GET method appends data to URL (bookmarkable, length limits), while POST sends data in request body (more secure, no size limits). Proper form design includes labels, validation, and accessibility features.",
    "code": "<form method='post'>\n  Name: <input type='text' name='name'>\n  <input type='submit'>\n</form>"
  },
  {
    "title": "PHP Form Handling",
    "note": "Form data is accessed through $_GET (for method='get') or $_POST (for method='post') superglobal arrays. The null coalescing operator (??) provides a clean way to handle missing values. Always validate and sanitize user input to prevent security vulnerabilities. htmlspecialchars() should be used when outputting user data to prevent XSS attacks. For file uploads, use $_FILES array. Form handling should include error checking, data validation, and appropriate user feedback. CSRF protection should be implemented for sensitive actions.",
    "code": "<?php\n$name = $_POST['name'] ?? '';\necho 'Hello ' . htmlspecialchars($name);\n?>"
  },
  {
    "title": "PHP Form Validation",
    "note": "Form validation ensures user input meets application requirements. Validation should check for: required fields (empty()), data format (regex, filter_var()), data type (is_numeric(), is_array()), length (strlen()), and business rules. Validation should occur server-side (client-side validation can be bypassed). Provide clear, specific error messages. Maintain submitted values in form to avoid user re-entry. Common validation includes: email (filter_var($email, FILTER_VALIDATE_EMAIL)), URLs, numbers, dates, and custom patterns. Validation libraries can simplify complex validation rules.",
    "code": "<?php\nif(empty($_POST['email'])) {\n  echo 'Email is required';\n}\n?>"
  },
  {
    "title": "PHP Form Required",
    "note": "The HTML5 required attribute provides client-side validation that prevents form submission until the field is filled. However, this should be complemented with server-side validation as client-side validation can be disabled. Required fields should be clearly marked in the UI (often with asterisks). Server-side checks should use empty() or isset() to verify presence. For checkboxes and radio buttons, specific validation is needed since unchecked boxes don't submit values. Required field validation is the first line of defense against incomplete form submissions.",
    "code": "<input type='text' name='username' required>"
  },
  {
    "title": "PHP Form URL/E-mail",
    "note": "PHP's filter_var() function provides convenient validation for common data types. FILTER_VALIDATE_EMAIL checks email format compliance with RFC standards. FILTER_VALIDATE_URL checks URL format and can include flags for requiring specific components (query string, path, etc.). These filters are more reliable than simple regex for edge cases. For emails, consider additional verification through confirmation emails or DNS checks. For URLs, additional checks might include verifying the domain exists or checking for safe/approved domains. Always combine validation with sanitization for security.",
    "code": "<?php\nif(filter_var($email, FILTER_VALIDATE_EMAIL)) {\n  echo 'Valid email';\n}\n?>"
  },
  {
    "title": "PHP Form Complete",
    "note": "A complete form handling solution includes: form display with proper HTML structure, client-side validation (HTML5 attributes, JavaScript), server-side validation and sanitization, data processing (database storage, email sending, etc.), user feedback (success messages, error display), and security measures (CSRF protection, input sanitization). The form should preserve user input on validation errors to avoid retyping. File uploads require special handling (enctype='multipart/form-data', $_FILES array). A well-structured form handler separates presentation, validation, and processing logic for maintainability.",
    "code": "// Combine all form handling and validation logic"
  },
  {
    "title": "PHP Date and Time",
    "note": "PHP offers comprehensive date/time functionality through functions and the DateTime class. date() formats timestamps, time() gets current Unix timestamp, strtotime() parses English datetime strings. The DateTime class (PHP 5.2+) provides object-oriented interface with methods for manipulation, formatting, and timezone handling. DateTimeImmutable provides immutable version. Common operations include: getting current date/time, formatting dates, calculating differences, adding/subtracting intervals, and handling timezones. The DateInterval and DateTimeZone classes support complex date calculations. Proper date handling is crucial for international applications and time-sensitive operations.",
    "code": "<?php\necho date('Y-m-d H:i:s');\n?>"
  },
  {
    "title": "PHP Include",
    "note": "The include and require statements insert the contents of another PHP file into the current file. include produces a warning if file not found, require produces a fatal error. include_once and require_once prevent multiple inclusions of the same file. These statements are used for code reuse: separating header/footer content, organizing functions into libraries, and modularizing application components. Included files share the same variable scope as the including file. Best practices include using relative paths with __DIR__ constant, organizing includes in a dedicated directory, and avoiding circular inclusions.",
    "code": "<?php include 'header.php'; ?>"
  },
  {
    "title": "PHP File Handling",
    "note": "PHP provides functions for file system operations: fopen() opens files with various modes (r, w, a, x, etc.), fread()/fgets() read data, fwrite() writes data, fclose() closes files, file_exists() checks existence, filesize() gets size, and unlink() deletes files. File operations should include error handling as files may be missing, locked, or have permission issues. The file_get_contents() and file_put_contents() functions provide simplified one-line file reading/writing. For large files, stream processing is more memory-efficient. Always validate file paths to prevent directory traversal attacks.",
    "code": "<?php\n$file = fopen('file.txt', 'r');\necho fread($file, filesize('file.txt'));\nfclose($file);\n?>"
  },
  {
    "title": "PHP File Open/Read",
    "note": "Reading files can be done using: file_get_contents() reads entire file into string (suitable for small files), fopen() with fread()/fgets() for stream reading (memory-efficient for large files), file() reads entire file into array of lines. For large files, reading in chunks with fread() or line-by-line with fgets() prevents memory issues. File reading should include error handling for missing files or permission denied. The readfile() function outputs file contents directly to output buffer, useful for file downloads. Always consider character encoding when reading text files.",
    "code": "<?php\n$content = file_get_contents('file.txt');\necho $content;\n?>"
  },
  {
    "title": "PHP File Create/Write",
    "note": "File writing can be done using: file_put_contents() writes string to file (creates file if not exists), fopen() with fwrite() for stream writing, file_put_contents() with FILE_APPEND flag for appending. Writing modes include: 'w' truncate and write, 'a' append, 'x' exclusive create (fails if exists). File writing should include error handling for permission issues or disk full. Locking (flock()) can prevent concurrent write issues. For temporary files, tmpfile() creates file that auto-deletes on close. Always validate and sanitize data before writing to prevent injection attacks.",
    "code": "<?php\nfile_put_contents('file.txt', 'Hello World');\n?>"
  },
  {
    "title": "PHP File Upload",
    "note": "File uploads require: form with enctype='multipart/form-data', input type='file', and server-side handling via $_FILES array. The $_FILES array contains: name, type, size, tmp_name (temporary storage path), and error code. move_uploaded_file() moves file from temporary to permanent location. Uploads should be validated for: file type (check MIME type, not just extension), file size, and error codes. Security considerations include: restricting allowed file types, storing files outside web root, renaming files to prevent execution, and scanning for malware. upload_max_filesize and post_max_size PHP settings control upload limits.",
    "code": "<?php\nmove_uploaded_file($_FILES['file']['tmp_name'], 'uploads/' . $_FILES['file']['name']);\n?>"
  },
  {
    "title": "PHP Cookies",
    "note": "Cookies are small pieces of data stored in the user's browser and sent with each request. setcookie() creates cookies with parameters: name, value, expiration time, path, domain, secure (HTTPS only), and httponly (HTTP only, no JavaScript access). Cookies are accessed via $_COOKIE superglobal. Limitations include: 4KB size limit, browser-dependent quantity limits, and user ability to disable/delete cookies. Common uses include: user preferences, shopping carts, and session management. Cookies should be used for non-sensitive data as they are visible to users and vulnerable to theft.",
    "code": "<?php\nsetcookie('user', 'Alice', time() + 3600);\n?>"
  },
  {
    "title": "PHP Sessions",
    "note": "Sessions maintain user state across multiple page requests by storing data on the server and identifying users with a session ID cookie. session_start() initializes sessions, $_SESSION superglobal stores session data. Sessions use cookies by default but can work with URL rewriting if cookies are disabled. Session configuration includes: garbage collection probability, cookie parameters, and storage mechanism (files, database, memcached). Sessions are more secure than cookies for sensitive data as only the ID is stored client-side. Sessions should be regenerated (session_regenerate_id()) on login to prevent fixation attacks.",
    "code": "<?php\nsession_start();\n$_SESSION['username'] = 'Alice';\n?>"
  },
  {
    "title": "PHP Filters",
    "note": "The filter extension provides functions for validating and sanitizing data. filter_var() filters single variable, filter_var_array() filters multiple variables, filter_input() filters input variables. Validation filters include: FILTER_VALIDATE_EMAIL, FILTER_VALIDATE_URL, FILTER_VALIDATE_IP, FILTER_VALIDATE_INT, etc. Sanitization filters include: FILTER_SANITIZE_EMAIL, FILTER_SANITIZE_STRING, FILTER_SANITIZE_NUMBER_INT, etc. Filters can be combined with flags for additional options. The filter extension provides consistent, well-tested validation that's preferable to custom regex for common data types.",
    "code": "<?php\n$email = filter_var($email, FILTER_SANITIZE_EMAIL);\n?>"
  },
  {
    "title": "PHP Filters Advanced",
    "note": "Advanced filter usage includes: options for min/max range validation, regex validation, custom validation callbacks, and multiple flags combination. Flags provide additional validation criteria: FILTER_FLAG_IPV4/IPV6 for IP validation, FILTER_FLAG_QUERY_REQUIRED for URLs, FILTER_FLAG_STRIP_LOW/HIGH for character stripping. Custom filters can be created using filter_register(). The filter extension supports validating and sanitizing arrays of data with complex rules. Advanced filtering is essential for robust input validation in security-critical applications and API endpoints.",
    "code": "<?php\nfilter_var($url, FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED);\n?>"
  },
  {
    "title": "PHP Callback Functions",
    "note": "Callbacks are functions passed as arguments to other functions. They can be: string function names, array [object, method] for object methods, array [class, method] for static methods, or anonymous functions (closures). call_user_func() and call_user_func_array() execute callbacks. Callbacks are used in: array functions (array_map, array_filter, array_reduce), event handling, custom sorting (usort), and implementation of patterns like Strategy and Observer. PHP 5.3+ anonymous functions and closures enable powerful functional programming patterns. Type declarations (callable) can enforce callback parameters.",
    "code": "<?php\nfunction callFunc($func) {\n  $func();\n}\ncallFunc(function() { echo 'Callback!'; });\n?>"
  },
  {
    "title": "PHP JSON",
    "note": "JSON (JavaScript Object Notation) is a lightweight data interchange format. json_encode() converts PHP values (arrays, objects) to JSON string. json_decode() converts JSON string to PHP values, with optional assoc parameter to return arrays instead of objects. JSON encoding options include: JSON_PRETTY_PRINT for human-readable output, JSON_NUMERIC_CHECK for number conversion, JSON_UNESCAPED_UNICODE to preserve Unicode. JSON is widely used for APIs, configuration files, and data storage. Error handling should check for json_last_error() after encoding/decoding. JSON serialization is essential for modern web applications and web services.",
    "code": "<?php\n$json = json_encode(['name' => 'Alice']);\n$data = json_decode($json, true);\n?>"
  },
  {
    "title": "PHP Exceptions",
    "note": "Exceptions provide a structured error handling mechanism. throw new Exception() raises exceptions, try-catch blocks handle them. Multiple catch blocks can handle different exception types. finally blocks execute regardless of exception. Custom exception classes can extend Exception for domain-specific errors. PHP has built-in exception types: RuntimeException, InvalidArgumentException, etc. Exceptions should be used for exceptional conditions, not regular control flow. Proper exception handling includes: logging, user-friendly error messages, and appropriate recovery or graceful degradation. Exceptions improve code robustness and maintainability.",
    "code": "<?php\ntry {\n  throw new Exception('Error occurred');\n} catch (Exception $e) {\n  echo $e->getMessage();\n}\n?>"
  },
  {
    "title": "PHP What is OOP",
    "note": "Object-Oriented Programming (OOP) organizes code around objects rather than functions. Key principles include: encapsulation (bundling data and methods, controlling access), inheritance (creating new classes from existing ones), polymorphism (objects of different types responding to same method), and abstraction (hiding complex reality while exposing essentials). OOP benefits include: code reuse, modularity, easier maintenance, and better representation of real-world entities. PHP's OOP implementation includes classes, objects, properties, methods, visibility (public, protected, private), constructors, destructors, and interfaces. OOP is essential for large, complex applications.",
    "code": "<?php\nclass Person {\n  public $name;\n  function __construct($name) {\n    $this->name = $name;\n  }\n}\n?>"
  },
  {
    "title": "PHP Classes/Objects",
    "note": "Classes are blueprints for creating objects. They contain properties (variables) and methods (functions). Objects are instances of classes created with new keyword. $this refers to the current object instance. Properties and methods can have visibility: public (accessible anywhere), protected (accessible within class and subclasses), private (accessible only within class). Constructors (__construct) initialize objects, destructors (__destruct) clean up. Objects are passed by reference by default. Understanding classes and objects is fundamental to PHP OOP and enables building modular, reusable code components.",
    "code": "<?php\n$person = new Person('Alice');\necho $person->name;\n?>"
  },
  {
    "title": "PHP Constructor",
    "note": "The constructor is a special method (__construct) that is automatically called when an object is instantiated from a class. It is used to initialize object properties, set up required resources, or perform any setup operations needed for the object. Constructors can accept parameters to allow different initialization states. In inheritance hierarchies, parent constructors are not called implicitly; use parent::__construct() to invoke parent constructor. PHP allows only one constructor per class (no overloading), but default parameter values can provide flexibility. Constructors are essential for ensuring objects are in a valid state upon creation.",
    "code": "<?php\nfunction __construct() {\n  // initialization code\n}\n?>"
  },
  {
    "title": "PHP Destructor",
    "note": "The destructor (__destruct) is called when an object is destroyed or when the script ends. It is used for cleanup operations such as closing database connections, releasing file handles, or other resource cleanup. Destructors are called automatically by PHP's garbage collector and cannot be called manually. They take no parameters and return no value. In inheritance, child destructors automatically call parent destructors after execution. Destructors are particularly important for objects that manage external resources to prevent resource leaks and ensure proper cleanup.",
    "code": "<?php\nfunction __destruct() {\n  // cleanup code\n}\n?>"
  },
  {
    "title": "PHP Access Modifiers",
    "note": "Access modifiers control the visibility and accessibility of class properties and methods. Public members are accessible from anywhere. Protected members are accessible within the class itself and by inheriting classes. Private members are accessible only within the class that defines them. Access modifiers enforce encapsulation, one of the core principles of OOP, by preventing external code from directly modifying internal object state. Proper use of access modifiers improves code security, maintainability, and reduces unintended side effects by controlling how class internals are exposed.",
    "code": "<?php\npublic $name;\nprivate $id;\n?>"
  },
  {
    "title": "PHP Inheritance",
    "note": "Inheritance allows a class (child) to inherit properties and methods from another class (parent). The child class can extend the parent's functionality by adding new methods/properties or overriding existing ones. Use the 'extends' keyword to establish inheritance. Parent constructors/destructors are not called automatically; use parent::__construct() explicitly. PHP supports single inheritance (a class can extend only one parent). Inheritance promotes code reuse, establishes hierarchical relationships, and enables polymorphism. The 'final' keyword can prevent classes or methods from being extended/overridden.",
    "code": "<?php\nclass Child extends Parent {}\n?>"
  },
  {
    "title": "PHP Abstract Classes",
    "note": "Abstract classes cannot be instantiated directly and serve as base classes for other classes. They may contain abstract methods (declared without implementation) that must be implemented by concrete subclasses. Abstract classes can also contain implemented methods and properties. Classes containing at least one abstract method must be declared abstract. Abstract classes define a contract for subclasses while providing common functionality. They are useful for creating frameworks or defining interfaces with partial implementation. Unlike interfaces, abstract classes can contain member variables and implemented methods.",
    "code": "<?php\nabstract class Animal {\n  abstract function sound();\n}\n?>"
  },
  {
    "title": "PHP Interfaces",
    "note": "Interfaces define a contract that implementing classes must follow, specifying method signatures without implementations. All methods in an interface are implicitly abstract and public. A class can implement multiple interfaces (separated by commas), enabling a form of multiple inheritance. Interfaces can contain constants but not properties. Interfaces are used to define capabilities that unrelated classes can share, ensuring they provide specific functionality. PHP 8.0 added support for constructor property promotion and union types in interfaces. Interfaces promote loose coupling and polymorphism.",
    "code": "<?php\ninterface Logger {\n  public function log($msg);\n}\n?>"
  },
  {
    "title": "PHP Traits",
    "note": "Traits are mechanisms for code reuse in single inheritance languages like PHP. A trait contains methods that can be reused in multiple classes. Use the 'use' keyword inside a class to incorporate a trait. Traits can contain both abstract and concrete methods, and can define properties. Conflict resolution for method name clashes can be handled using insteadof and as operators. Traits are composed into classes at compile time and provide horizontal code reuse without the complexity of multiple inheritance. They are ideal for sharing functionality across unrelated class hierarchies.",
    "code": "<?php\ntrait LoggerTrait {\n  public function log($msg) { echo $msg; }\n}\n?>"
  },
  {
    "title": "PHP Static Methods",
    "note": "Static methods belong to the class rather than to object instances. They are called using the class name followed by :: (scope resolution operator) and the method name. Static methods cannot access non-static properties or methods (they have no $this context). They are often used for utility functions, factory methods, or operations that don't require object state. Static methods are shared across all instances and can be called without instantiating the class. Overriding static methods in subclasses works differently than instance methods due to late static binding.",
    "code": "<?php\nclass Math {\n  public static function add($a, $b) { return $a + $b; }\n}\necho Math::add(5, 3);\n?>"
  },
  {
    "title": "PHP Static Properties",
    "note": "Static properties are shared across all instances of a class and belong to the class itself rather than individual objects. They are accessed using the class name with the :: operator. Static properties are useful for maintaining state common to all objects, such as counters, configuration settings, or shared resources. Unlike instance properties, static properties are initialized only once. They can have visibility modifiers (public, protected, private) and can be accessed within static methods. Static properties persist for the duration of the script execution.",
    "code": "<?php\nclass Counter {\n  public static $count = 0;\n}\n?>"
  },
  {
    "title": "PHP Namespaces",
    "note": "Namespaces organize code into logical groups and prevent name collisions between classes, functions, and constants. They are declared using the 'namespace' keyword at the beginning of a file (except for declare statements). Namespaces can be nested hierarchically using backslashes. The 'use' keyword imports namespaces or creates aliases. The global namespace is referenced with a leading backslash. Namespaces are essential for large applications, library development, and autoloading with PSR-4 standards. They help structure code and avoid conflicts when using multiple third-party libraries.",
    "code": "<?php\nnamespace MyProject;\n?>"
  },
  {
    "title": "PHP Iterables",
    "note": "The iterable pseudo-type was introduced in PHP 7.1 to represent any value that can be iterated over with foreach, including arrays and objects implementing the Traversable interface. Generators provide an easy way to implement simple iterators using the 'yield' keyword, which allows writing code that uses foreach to iterate over a set of data without building an array. Generators are memory-efficient for working with large datasets or sequences. The yield keyword pauses function execution and returns a value to the caller, resuming from that point on the next iteration.",
    "code": "<?php\nfunction gen() {\n  yield 1;\n  yield 2;\n}\nforeach(gen() as $val) {\n  echo $val;\n}\n?>"
  },
  {
    "title": "MySQL Database",
    "note": "MySQL is a popular open-source relational database management system commonly used with PHP. PHP provides two main extensions for MySQL interaction: mysqli (MySQL Improved) and PDO (PHP Data Objects). mysqli offers both procedural and object-oriented interfaces with MySQL-specific features. PDO provides a consistent interface for accessing multiple database types with prepared statement support. Key database operations include connecting, querying, fetching results, and handling errors. Proper database interaction includes security measures like prepared statements to prevent SQL injection and proper error handling.",
    "code": "// Connect using mysqli or PDO"
  },
  {
    "title": "MySQL Connect",
    "note": "Establishing a database connection is the first step in database interaction. mysqli connections can be created using object-oriented style (new mysqli()) or procedural style (mysqli_connect()). Connection parameters include hostname, username, password, database name, and optionally port and socket. Successful connections return a connection object/resource, while failed connections should be handled gracefully with error checking. Connections should be closed explicitly when no longer needed using close() or mysqli_close(). Persistent connections can improve performance but require careful resource management.",
    "code": "<?php\n$conn = new mysqli('localhost', 'user', 'pass', 'db');\n?>"
  },
  {
    "title": "MySQL Create DB",
    "note": "Creating a database involves executing a CREATE DATABASE SQL statement. The statement can include optional clauses like CHARACTER SET and COLLATION for specifying character encoding. Database creation typically requires administrative privileges. It's good practice to check if the database already exists before attempting creation. After creation, you may need to select the database for use with mysqli_select_db() or by including it in the connection parameters. Database creation is usually done during application installation or setup rather than during normal operation.",
    "code": "<?php\n$conn->query('CREATE DATABASE mydb');\n?>"
  },
  {
    "title": "MySQL Create Table",
    "note": "Tables are created using CREATE TABLE statements defining columns with their data types, constraints, and optional table options. Common column types include INT, VARCHAR, TEXT, DATE, DATETIME, and DECIMAL. Constraints include PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, and DEFAULT values. Table options can specify storage engine (InnoDB, MyISAM), character set, and collation. Proper table design involves normalization principles, appropriate indexing, and considering relationships between tables. Table creation is typically part of database schema setup or migration scripts.",
    "code": "<?php\n$sql = 'CREATE TABLE users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100))';\n$conn->query($sql);\n?>"
  },
  {
    "title": "MySQL Insert Data",
    "note": "INSERT statements add new rows to tables. The basic syntax specifies the table name, column names, and values to insert. Multiple value formats are supported: explicit values lists, SELECT statements, or SET syntax. INSERT operations can be single-row or multi-row. The affected_rows property indicates how many rows were inserted. Auto-increment columns automatically generate unique values. Insert operations should be performed within transactions when atomicity is required and should use prepared statements for security when inserting user-provided data.",
    "code": "<?php\n$conn->query(\"INSERT INTO users (name) VALUES ('Alice')\");\n?>"
  },
  {
    "title": "MySQL Get Last ID",
    "note": "After inserting a row into a table with an AUTO_INCREMENT column, the insert_id property returns the last automatically generated ID. This is useful for obtaining the primary key of newly inserted records, especially when you need to insert related data in other tables. The value is connection-specific and remains available until the next INSERT operation. For multi-row inserts, it returns the first automatically generated value. This property works only with AUTO_INCREMENT columns and doesn't affect other operations.",
    "code": "<?php\n$last_id = $conn->insert_id;\n?>"
  },
  {
    "title": "MySQL Insert Multiple",
    "note": "Multiple rows can be inserted with a single INSERT statement by providing multiple value tuples separated by commas. This is more efficient than multiple single INSERT statements as it reduces round-trips to the database server. The syntax is: INSERT INTO table (columns) VALUES (values1), (values2), ... The maximum number of rows per statement is limited by max_allowed_packet. Multi-row inserts are atomic - either all rows are inserted or none if an error occurs. They're particularly useful for batch data loading operations.",
    "code": "<?php\n$sql = \"INSERT INTO users (name) VALUES ('Bob'), ('Carol')\";\n$conn->query($sql);\n?>"
  },
  {
    "title": "MySQL Prepared",
    "note": "Prepared statements separate SQL logic from data, preventing SQL injection attacks. They are created using prepare() method, with placeholders (?) for parameters. Parameters are bound to variables using bind_param() (mysqli) or bound implicitly (PDO). execute() runs the statement with the bound values. Prepared statements can be executed multiple times with different values, improving performance for repeated queries. They handle data type conversion and escaping automatically. Prepared statements are essential for security when handling user input and are recommended for all dynamic queries.",
    "code": "<?php\n$stmt = $conn->prepare('INSERT INTO users (name) VALUES (?)');\n$stmt->bind_param('s', $name);\n$stmt->execute();\n?>"
  },
  {
    "title": "MySQL Select Data",
    "note": "SELECT queries retrieve data from database tables. The basic syntax selects columns from a table, optionally with WHERE conditions, JOINs, GROUP BY, HAVING, and ORDER BY clauses. Results are returned as a result set object that can be iterated using methods like fetch_assoc(), fetch_array(), or fetch_object(). It's important to free result sets with free() or close() when done to release resources. SELECT queries should use appropriate indexes for performance and may need pagination (LIMIT) for large result sets. Always validate and sanitize input used in WHERE clauses.",
    "code": "<?php\n$result = $conn->query('SELECT * FROM users');\nwhile($row = $result->fetch_assoc()) {\n  echo $row['name'];\n}\n?>"
  },
  {
    "title": "MySQL Where",
    "note": "The WHERE clause filters records based on specified conditions. It supports comparison operators (=, <>, <, >, <=, >=), logical operators (AND, OR, NOT), IN for multiple values, BETWEEN for ranges, and LIKE for pattern matching. WHERE conditions can reference multiple columns and use parentheses for complex logic. Proper indexing of columns used in WHERE clauses is crucial for performance. User input in WHERE conditions must be properly parameterized using prepared statements to prevent SQL injection. The WHERE clause is fundamental for retrieving specific subsets of data from tables.",
    "code": "<?php\n$result = $conn->query(\"SELECT * FROM users WHERE id = 1\");\n?>"
  },
  {
    "title": "MySQL Order By",
    "note": "The ORDER BY clause sorts the result set by one or more columns in ascending (ASC) or descending (DESC) order. Multiple columns can be specified for secondary sorting. Columns can be referenced by name, alias, or ordinal position. Sorting text data considers collation settings. ORDER BY can be combined with LIMIT for top-N queries. Sorting large result sets can be performance-intensive; appropriate indexes can help. Be cautious when using ORDER BY with LIMIT in pagination, as it may need deterministic ordering to ensure consistent results across pages.",
    "code": "<?php\n$result = $conn->query(\"SELECT * FROM users ORDER BY name ASC\");\n?>"
  },
  {
    "title": "MySQL Delete Data",
    "note": "DELETE statements remove rows from tables. The WHERE clause specifies which rows to delete; without WHERE, all rows are deleted. DELETE operations are permanent and should be used cautiously. It's good practice to test with SELECT first to verify which rows will be affected. The affected_rows property indicates how many rows were deleted. DELETE operations can be rolled back if within a transaction. For large deletions, consider batch processing to avoid locking issues. Always use prepared statements when incorporating user input in WHERE conditions to prevent SQL injection.",
    "code": "<?php\n$conn->query(\"DELETE FROM users WHERE id = 1\");\n?>"
  },
  {
    "title": "MySQL Update Data",
    "note": "UPDATE statements modify existing data in tables. The SET clause specifies column=new_value pairs, and the WHERE clause determines which rows are updated. Without WHERE, all rows are updated. Multiple columns can be updated in one statement. UPDATE operations should be atomic when multiple related changes are needed. The affected_rows property shows how many rows were modified. Use prepared statements for values in SET and WHERE clauses involving user input. Updates should be tested thoroughly as they permanently change data. Consider using transactions for critical update operations.",
    "code": "<?php\n$conn->query(\"UPDATE users SET name = 'Dave' WHERE id = 2\");\n?>"
  },
  {
    "title": "MySQL Limit Data",
    "note": "The LIMIT clause restricts the number of rows returned by a query. It takes one or two parameters: LIMIT row_count or LIMIT offset, row_count. LIMIT is commonly used for pagination, where offset = (page_number - 1) * page_size. For large offsets, this can be inefficient; alternative pagination techniques may be better. LIMIT can improve performance by reducing result set size. When using ORDER BY with LIMIT, ensure the ordering is deterministic to avoid inconsistent results. LIMIT is MySQL-specific syntax; other databases use different approaches like TOP or ROWNUM.",
    "code": "<?php\n$result = $conn->query(\"SELECT * FROM users LIMIT 10\");\n?>"
  },
  {
    "title": "PHP XML Parsers",
    "note": "PHP provides several XML parsing options: SimpleXML for simple, tree-based parsing; XMLReader for efficient, stream-based reading; DOMDocument for full DOM implementation; and XML Parser (Expat) for event-based parsing. SimpleXML offers an easy interface for reading XML but loads the entire document into memory. XMLReader is memory-efficient for large files as it reads sequentially. DOMDocument allows full document manipulation but has high memory usage. The choice depends on factors like document size, processing needs, and memory constraints. XML parsing is essential for web services, configuration files, and data interchange.",
    "code": "// Use SimpleXML or XMLReader"
  },
  {
    "title": "PHP SimpleXML Parser",
    "note": "SimpleXML provides an easy-to-use interface for converting XML to an object that can be processed with property selectors and array iterators. It automatically converts XML elements to object properties and attributes to array elements. simplexml_load_file() parses XML files, while simplexml_load_string() parses XML strings. SimpleXML supports XPath queries for complex node selection. It's ideal for simple XML structures and quick prototyping. However, it loads the entire document into memory, making it unsuitable for very large XML files. SimpleXML is read-only; for manipulation, use DOMDocument.",
    "code": "<?php\n$xml = simplexml_load_file('file.xml');\necho $xml->title;\n?>"
  },
  {
    "title": "PHP SimpleXML - Get",
    "note": "Accessing data with SimpleXML involves using object property syntax for elements and array syntax for attributes. Multiple elements with the same name become arrays. The children() method accesses child elements, and attributes() accesses element attributes. Methods like asXML() return the XML representation, and XPath() allows complex queries. SimpleXML automatically handles CDATA sections and character encoding. For missing elements, it returns NULL rather than throwing errors. While convenient, SimpleXML has limitations with mixed content, namespaces, and complex document structures compared to more full-featured parsers.",
    "code": "<?php\necho $xml->book[0]->author;\n?>"
  },
  {
    "title": "PHP XML Expat",
    "note": "The XML Parser (Expat) extension provides an event-based, stream-oriented XML parser. Unlike tree-based parsers, it doesn't load the entire document into memory, making it suitable for large XML files. It works by defining handler functions for different XML events (start tags, end tags, character data, etc.) and then parsing the document sequentially. This approach gives fine control over parsing but requires more code to build data structures. xml_parser_create() creates a parser, xml_set_element_handler() sets element handlers, and xml_parse() processes the XML. It's efficient but lower-level than SimpleXML or DOM.",
    "code": "// XML parser with xml_parse functions"
  },
  {
    "title": "PHP XML DOM",
    "note": "The PHP DOM (Document Object Model) extension provides a tree-based approach to XML document manipulation, allowing developers to create, modify, and traverse XML documents programmatically. The DOMDocument class represents the entire XML document and provides methods to load XML from strings or files, navigate through elements, modify content, and save changes. DOM supports XPath queries for complex node selection and provides a standards-compliant interface for XML processing. Unlike SimpleXML, DOM allows full document manipulation including node creation, deletion, and modification. It's more memory-intensive but offers complete control over XML documents.",
    "code": "// Use DOMDocument class"
  },
  {
    "title": "AJAX Intro",
    "note": "AJAX (Asynchronous JavaScript and XML) is a web development technique that allows web pages to update content asynchronously by exchanging data with a web server in the background, without interfering with the current page. This enables dynamic, responsive user interfaces where specific parts of a page can be updated without full page reloads. AJAX typically uses the XMLHttpRequest object or modern Fetch API to send HTTP requests to the server and process responses. While originally designed for XML data exchange, AJAX now commonly uses JSON format. AJAX is fundamental for modern web applications, single-page applications, and interactive user experiences.",
    "code": "// JavaScript XMLHttpRequest example"
  },
  {
    "title": "AJAX PHP",
    "note": "PHP serves as the server-side processing component in AJAX applications, handling requests from JavaScript clients and returning responses in formats like JSON, XML, or HTML. Typical AJAX with PHP involves: receiving data via $_GET, $_POST, or php://input; processing the request (database operations, calculations, etc.); and returning appropriately formatted responses. PHP scripts for AJAX should set proper Content-Type headers (application/json for JSON responses), handle errors gracefully, and implement security measures like input validation and CSRF protection. PHP's simplicity makes it well-suited for quick AJAX endpoint development.",
    "code": "// PHP script returns JSON response"
  },
  {
    "title": "AJAX Database",
    "note": "AJAX database applications combine client-side JavaScript with PHP backend to create dynamic, database-driven web interfaces. The typical flow involves: JavaScript sends AJAX request to PHP script; PHP connects to database (MySQL, PostgreSQL, etc.), executes queries with proper parameterization to prevent SQL injection; processes results; returns data (usually JSON) to client; JavaScript updates page content with received data. This pattern enables features like live search, dynamic filtering, infinite scrolling, and real-time data updates without page refreshes. Security considerations include input validation, prepared statements, and proper authentication/authorization.",
    "code": "// AJAX calls PHP which queries DB and returns data"
  },
  {
    "title": "AJAX XML",
    "note": "While JSON has become more popular for AJAX data exchange, XML remains used in certain applications, particularly with legacy systems or specific industry standards. AJAX with XML involves: PHP generating XML responses using SimpleXML, DOMDocument, or manual string construction; setting proper Content-Type header (application/xml or text/xml); JavaScript processing XML response using DOM parsing methods. XML provides strong schema validation capabilities through DTD or XML Schema but is more verbose than JSON. XML is still common in RSS feeds, SOAP web services, and enterprise integration scenarios.",
    "code": "// Use XMLHttpRequest to get XML"
  },
  {
    "title": "AJAX Live Search",
    "note": "Live search provides real-time search suggestions as users type, significantly enhancing user experience. Implementation involves: JavaScript listening to input events on search field; sending AJAX requests to PHP backend with current input value; PHP querying database for matching results; returning suggestions as JSON; JavaScript displaying results dynamically. Optimization techniques include: debouncing input to reduce requests, caching results, using full-text search capabilities, and limiting result count. Live search improves usability but requires careful performance optimization to handle multiple simultaneous requests efficiently.",
    "code": "// JavaScript fetch with input event"
  },
  {
    "title": "AJAX Poll",
    "note": "AJAX polling creates dynamic voting systems where users can vote and see updated results without page refresh. Implementation involves: PHP serving poll options and handling vote submissions; database storing votes and calculating results; JavaScript handling user interactions and periodically fetching updated results. Security considerations include preventing multiple votes (through session tracking or user authentication), validating vote data, and protecting against automated voting. Real-time result updates can be achieved through periodic AJAX requests or more advanced techniques like WebSockets for instant updates when votes occur.",
    "code": "// Send and receive poll data asynchronously"
  },
  {
    "title": "PHP Examples",
    "note": "PHP code examples demonstrate practical implementation of language features, ranging from basic syntax to advanced concepts. Common example categories include: form handling with validation, file upload processing, database CRUD operations, session management, object-oriented programming patterns, API development, and integration with frontend technologies. Examples typically include error handling, security considerations, and best practices. Studying examples helps developers understand practical application of PHP features, learn common patterns, and avoid pitfalls. Well-commented examples serve as valuable learning resources and starting points for real-world projects.",
    "code": "// Hello world, form handling, DB interaction"
  },
  {
    "title": "PHP Compiler",
    "note": "PHP is primarily an interpreted language executed by the Zend Engine, but the term 'compiler' can refer to: the php command-line interface that executes PHP scripts; opcode cachers like OPcache that compile PHP to bytecode for improved performance; or alternative implementations like HipHop Virtual Machine (HHVM) that use just-in-time compilation. Online PHP compilers and sandboxes allow testing code without local installation. Understanding PHP execution helps with performance optimization, debugging, and deployment strategies. The php command provides various options for linting, configuration, and executing scripts in different environments.",
    "code": "// Use php command line or online tools"
  },
  {
    "title": "PHP Quiz",
    "note": "PHP quizzes test knowledge through multiple-choice questions, code interpretation exercises, and practical problem-solving challenges. They cover topics including: language syntax and semantics, built-in functions, security best practices, performance optimization, and framework-specific knowledge. Quizzes help identify knowledge gaps, prepare for job interviews, and reinforce learning through immediate feedback. Effective quizzes balance theoretical questions with practical code analysis problems. Many online platforms, certification programs, and educational resources offer PHP quizzes with explanations to deepen understanding of complex concepts and common pitfalls.",
    "code": "// Multiple choice and code challenges"
  },
  {
    "title": "PHP Exercises",
    "note": "PHP programming exercises provide hands-on practice to develop practical coding skills. Exercises range from basic tasks (variable manipulation, control structures) to advanced challenges (algorithm implementation, system design). Common exercise categories include: string and array manipulation, file processing, database operations, form validation, API development, and security implementation. Exercises should progress in difficulty and include testing requirements to verify correctness. Platforms like Exercism, Codewars, and project-based tutorials offer structured exercise paths. Regular practice with diverse exercises builds problem-solving skills and coding proficiency.",
    "code": "// Solve problems to improve skills"
  },
  {
    "title": "PHP Server",
    "note": "PHP runs on web servers through server modules (mod_php for Apache, php-fpm for Nginx) or built-in development servers. Configuration involves: php.ini for runtime settings, web server configuration for handler setup, and optional opcode caching for performance. Common server setups include LAMP (Linux, Apache, MySQL, PHP), LEMP (Linux, Nginx, MySQL, PHP), and WAMP/MAMP for Windows/macOS development. Production servers require security hardening, performance tuning, and monitoring. Understanding server configuration is essential for deployment, troubleshooting, and optimizing PHP application performance in different environments.",
    "code": "// Configure php.ini and server settings"
  },
  {
    "title": "PHP Syllabus",
    "note": "A comprehensive PHP syllabus covers: PHP basics (syntax, variables, data types), control structures, functions, arrays, form handling, file I/O, sessions and cookies, object-oriented programming, database integration (MySQLi, PDO), error handling, security practices, and popular frameworks (Laravel, Symfony). The syllabus should progress from fundamental concepts to advanced topics, with practical projects at each stage. A well-structured syllabus includes learning objectives, time estimates, required resources, and assessment methods. It serves as a roadmap for systematic PHP learning, ensuring coverage of essential topics and skills.",
    "code": "// Learning path for PHP beginners"
  },
  {
    "title": "PHP Study Plan",
    "note": "An effective PHP study plan includes: foundation building (2-3 weeks for basic syntax and web concepts), intermediate topics (3-4 weeks for databases and OOP), advanced concepts (4-6 weeks for security, performance, frameworks), and project development (ongoing). Daily study should mix theoretical learning (documentation, tutorials) with hands-on coding (exercises, projects). Weekly goals should be specific and measurable, with time allocated for revision and concept reinforcement. The plan should adapt based on progress and include resources for problem-solving (forums, documentation). Consistency and practical application are key to mastery.",
    "code": "// Daily or weekly study goals"
  },
  {
    "title": "PHP Certificate",
    "note": "PHP certifications validate professional competency and are offered by organizations like Zend (now part of Perforce) and various online learning platforms. Common certifications include: Zend Certified PHP Engineer (comprehensive language knowledge), framework-specific certifications (Laravel, Symfony), and specialized certifications (security, performance). Certification typically involves passing exams that test theoretical knowledge and practical skills. Preparation requires months of study using official guides, practice tests, and hands-on coding. Certifications enhance career prospects, demonstrate commitment to professional development, and provide structured learning paths for skill validation.",
    "code": "// PHP certification exam info"
  },
  {
    "title": "PHP Reference",
    "note": "The PHP official documentation (php.net) provides comprehensive reference material for all language features, functions, and extensions. Each function entry includes description, parameters, return values, examples, and user comments. The manual covers: language reference, function reference, installation and configuration, security, and features by version. Additional resources include RFCs (Request for Comments) for language changes, community tutorials, and framework documentation. The PHP manual is renowned for its quality and completeness, serving as the authoritative source for PHP developers worldwide. Regular consultation with the manual is essential for professional PHP development.",
    "code": "// PHP.net official docs"
  },
  {
    "title": "PHP Array",
    "note": "PHP provides over 80 array functions for manipulation, including: array manipulation (array_push, array_pop, array_shift, array_unshift), merging (array_merge, array_combine), slicing (array_slice, array_splice), searching (array_search, in_array), filtering (array_filter), mapping (array_map), reducing (array_reduce), sorting (sort, asort, ksort, usort), and utility functions (array_keys, array_values, array_flip). Arrays are fundamental to PHP programming, used for data storage, configuration, and as the primary data structure for many operations. Understanding array functions is crucial for effective PHP development.",
    "code": "array_push($arr, 'value');"
  },
  {
    "title": "PHP Calendar",
    "note": "The Calendar extension provides functions for converting between different calendar systems (Gregorian, Julian, Jewish, French Republican) and performing date calculations. Functions include: cal_days_in_month() (days in a month), cal_from_jd() (convert from Julian day count), cal_info() (calendar information), easter_date() (calculate Easter date), and unixtojd() (Unix timestamp to Julian day). While much date functionality is available in the core Date/Time functions, the Calendar extension offers specialized functionality for historical dates, religious calendars, and calendar system conversions.",
    "code": "cal_days_in_month(CAL_GREGORIAN, 5, 2025);"
  },
  {
    "title": "PHP Date",
    "note": "PHP date and time functions handle date manipulation, formatting, and calculations. Core functions include: date() (format timestamp), time() (current Unix timestamp), strtotime() (parse English datetime strings), mktime() (create timestamp from parts), and getdate() (get date/time components). The DateTime class (PHP 5.2+) provides object-oriented interface with methods for manipulation, comparison, and timezone handling. Date functions support various formats, timezones, and localization. Proper date handling is crucial for applications dealing with scheduling, reporting, internationalization, and time-sensitive operations.",
    "code": "date('Y-m-d');"
  },
  {
    "title": "PHP Directory",
    "note": "Directory functions provide interface for working with filesystem directories: scandir() (list files/directories), opendir()/readdir()/closedir() (directory stream handling), mkdir() (create directory), rmdir() (remove directory), chdir() (change directory), getcwd() (get current directory), and directory iteration with DirectoryIterator class. These functions enable file management, directory traversal, and filesystem operations. Security considerations include validating paths to prevent directory traversal attacks and handling permissions errors. Directory functions are essential for file management utilities, installation scripts, and content management systems.",
    "code": "scandir('/path/to/dir');"
  },
  {
    "title": "PHP Error",
    "note": "PHP error handling includes: error reporting configuration (error_reporting(), display_errors, log_errors), custom error handlers (set_error_handler()), and exception handling. Error levels include E_ERROR (fatal), E_WARNING (non-fatal), E_NOTICE (minor), and E_DEPRECATED (future incompatibility). Production environments should log errors but not display them to users. Development environments should show all errors for debugging. Proper error handling improves application robustness, security, and maintainability. PHP 7+ improved error handling by making most errors throw Error exceptions, enabling consistent error handling through try/catch blocks.",
    "code": "error_reporting(E_ALL);"
  },
  {
    "title": "PHP Exception",
    "note": "Exceptions provide structured error handling through try/catch/finally blocks. PHP exceptions extend the Exception class, with specialized exceptions like RuntimeException, InvalidArgumentException, and PDOException. Custom exception classes can be created for domain-specific errors. try blocks contain code that might throw exceptions, catch blocks handle specific exception types, and finally blocks execute regardless of exceptions. Exceptions should be used for exceptional conditions, not normal flow control. Proper exception handling includes logging, user-friendly error messages, and appropriate recovery strategies. Exceptions improve code clarity and error management.",
    "code": "try {\n  // code\n} catch (Exception $e) {\n  echo $e->getMessage();\n}"
  },
  {
    "title": "PHP Filesystem",
    "note": "Filesystem functions provide file manipulation capabilities: file existence checks (file_exists(), is_file(), is_dir()), reading/writing (file_get_contents(), file_put_contents()), file metadata (filesize(), filemtime(), fileperms()), deletion (unlink()), and permissions (chmod(), chown()). The SplFileObject class offers object-oriented file handling. Filesystem operations should include error handling for missing files, permission denied, and disk full scenarios. Security considerations include path validation to prevent directory traversal attacks and safe file permission settings. Filesystem functions are essential for file-based data storage, logging, and file processing applications.",
    "code": "file_exists('file.txt');"
  },
  {
    "title": "PHP Filter",
    "note": "The Filter extension provides functions for validating and sanitizing data: filter_var() (filter single variable), filter_var_array() (filter multiple variables), filter_input() (filter input variables). Validation filters include: FILTER_VALIDATE_EMAIL, FILTER_VALIDATE_URL, FILTER_VALIDATE_IP, FILTER_VALIDATE_INT with range options. Sanitization filters include: FILTER_SANITIZE_EMAIL, FILTER_SANITIZE_STRING, FILTER_SANITIZE_NUMBER_INT. Filters can be combined with flags for additional options. The filter extension provides consistent, well-tested validation that's preferable to custom regex for common data types, improving security and code reliability.",
    "code": "filter_var($email, FILTER_VALIDATE_EMAIL);"
  },
  {
    "title": "PHP FTP",
    "note": "The FTP extension provides functions for File Transfer Protocol operations: ftp_connect()/ftp_ssl_connect() (establish connections), ftp_login() (authenticate), ftp_put()/ftp_get() (upload/download files), ftp_nlist()/ftp_rawlist() (list directory contents), ftp_mkdir()/ftp_rmdir() (create/remove directories), ftp_delete() (delete files), and ftp_chmod() (change permissions). FTP functions enable automated file transfers, remote file management, and deployment scripts. Security considerations include using FTPS (FTP over SSL) for encryption, validating file paths, and secure credential storage. FTP is commonly used for website deployment and automated file processing.",
    "code": "ftp_connect('ftp.example.com');"
  },
  {
    "title": "PHP JSON",
    "note": "JSON functions provide conversion between PHP values and JSON format: json_encode() (PHP to JSON), json_decode() (JSON to PHP), with options for pretty printing, numeric checking, and unicode handling. JSON is the primary data format for APIs, configuration files, and data storage. PHP arrays and objects map naturally to JSON objects and arrays. Error handling should check json_last_error() after encoding/decoding. JSON functions support depth limits to prevent stack overflows with deeply nested structures. JSON has largely replaced XML for data interchange in web applications due to its simplicity and JavaScript compatibility.",
    "code": "json_encode($array);"
  },
  {
    "title": "PHP Keywords",
    "note": "PHP keywords are reserved words with special meaning in the language syntax. They include: class-related (class, interface, trait, extends, implements, new, instanceof), visibility (public, protected, private), function-related (function, return, yield), control structures (if, else, elseif, switch, case, default, while, do, for, foreach, break, continue, goto), error handling (try, catch, finally, throw), and other keywords (array, as, clone, const, declare, die, echo, empty, enddeclare, endfor, endforeach, endif, endswitch, endwhile, eval, exit, list, print, require, include, require_once, include_once, static, unset, use, var, xor). Keywords cannot be used as identifiers.",
    "code": "abstract, interface, static, etc."
  },
  {
    "title": "PHP Libxml",
    "note": "The Libxml extension provides interface to the libxml2 library, offering XML parsing and validation capabilities. Functions include: libxml_use_internal_errors() (enable user error handling), libxml_get_errors()/libxml_clear_errors() (error retrieval/clearing), and libxml_set_streams_context() (set context for stream operations). Libxml underpins PHP's XML extensions (SimpleXML, DOM, XMLReader) and provides consistent error handling across them. Understanding Libxml functions is important for robust XML processing, especially when dealing with malformed XML or needing detailed error information for debugging parsing issues.",
    "code": "libxml_use_internal_errors(true);"
  },
  {
    "title": "PHP Mail",
    "note": "The mail() function sends email messages using the local mail system. Parameters include: recipient address, subject, message body, additional headers (From, Cc, Bcc, Content-Type), and additional parameters for sendmail configuration. While simple to use, mail() has limitations: no authentication, difficult error handling, and dependency on local mail server configuration. For robust email handling, consider libraries like PHPMailer or SwiftMailer that support SMTP authentication, HTML emails, attachments, and better error reporting. Email sending should include validation of addresses and content to prevent email header injection attacks.",
    "code": "mail('test@example.com', 'Subject', 'Message');"
  },
  {
    "title": "PHP Math",
    "note": "Math functions provide mathematical operations and calculations: basic arithmetic (abs(), ceil(), floor(), round(), max(), min()), exponents and logarithms (pow(), exp(), log(), log10()), trigonometry (sin(), cos(), tan(), asin(), acos(), atan(), atan2()), random numbers (rand(), mt_rand(), random_int()), and number theory (gcd(), lcm()). For arbitrary precision arithmetic, BC Math and GMP extensions provide functions for very large numbers. Math functions are essential for financial calculations, scientific applications, graphics programming, and algorithms requiring mathematical operations.",
    "code": "pow(2, 3);"
  },
  {
    "title": "PHP Misc",
    "note": "Miscellaneous PHP functions cover various utilities: output control (ob_start(), ob_get_contents(), ob_end_clean()), program execution (exec(), shell_exec(), system()), PHP information (phpinfo(), phpversion()), network (gethostbyname(), gethostbyaddr()), and various utilities (uniqid(), sleep(), usleep()). These functions provide capabilities that don't fit into other categories but are often essential for specific tasks like output buffering, system integration, debugging, and utility functions. Their usage should be carefully considered for security and portability implications.",
    "code": "// Various small utilities"
  },
  {
    "title": "PHP MySQLi",
    "note": "The MySQLi (MySQL Improved) extension provides interface to MySQL databases with both procedural and object-oriented APIs. Features include: prepared statements for security, transactional support, multiple statements, debugging capabilities, and enhanced error reporting. MySQLi supports the full MySQL protocol and provides both client-side and server-side prepared statements. The object-oriented interface includes classes like mysqli (connection), mysqli_stmt (prepared statement), and mysqli_result (query results). MySQLi is recommended over the older mysql extension for new development, offering better performance, security, and feature support.",
    "code": "$mysqli = new mysqli('host', 'user', 'pass', 'db');"
  },
  {
    "title": "PHP Network",
    "note": "Network functions provide low-level network operations: fsockopen() (open socket connection), pfsockopen() (persistent socket), socket functions (socket_create(), socket_bind(), socket_listen(), socket_accept()), DNS functions (gethostbyname(), gethostbynamel(), checkdnsrr()), and network information (getprotobyname(), getservbyname()). These functions enable custom network protocols, server implementations, and network diagnostics. Network programming requires understanding of sockets, protocols, and error handling. For most web applications, higher-level protocols like HTTP are better handled by dedicated libraries rather than raw socket programming.",
    "code": "fsockopen('www.example.com', 80);"
  },
  {
    "title": "PHP Output Control",
    "note": "Output control functions manage output buffering: ob_start() (start buffering), ob_get_contents() (get buffer content), ob_end_flush() (send buffer and turn off buffering), ob_end_clean() (discard buffer and turn off buffering), and ob_get_level() (get nesting level). Output buffering enables: capturing output for processing, sending headers after content, compression (ob_gzhandler()), and template systems. Buffering can be nested multiple levels. Output control is essential for applications that need to manipulate output before sending, implement caching, or handle headers correctly.",
    "code": "ob_start();"
  },
  {
    "title": "PHP RegEx",
    "note": "Regular expression functions provide pattern matching using PCRE (Perl Compatible Regular Expressions) syntax: preg_match() (perform match), preg_match_all() (global match), preg_replace() (search and replace), preg_split() (split by pattern), preg_grep() (array filtering), and preg_quote() (escape regex characters). Patterns are delimited characters (usually /) with modifiers (i case-insensitive, m multiline, s dotall, x extended). Regular expressions are powerful for validation, extraction, and text transformation but can be complex and performance-intensive for certain patterns. Understanding regex is essential for advanced text processing.",
    "code": "preg_match('/pattern/', $string);"
  },
  {
    "title": "PHP SimpleXML",
    "note": "The SimpleXML extension provides a simple, tree-based interface for XML processing. Functions include: simplexml_load_file() (parse XML file), simplexml_load_string() (parse XML string), and simplexml_import_dom() (convert DOM node). SimpleXML represents XML elements as object properties and attributes as array elements. It supports XPath queries and iteration. SimpleXML is easy to use for simple XML structures but has limitations with mixed content, namespaces, and complex documents. It's read-only; for manipulation, use DOM extension. SimpleXML is ideal for configuration files, RSS feeds, and simple data exchange formats.",
    "code": "simplexml_load_string($xmlString);"
  },
  {
    "title": "PHP Stream",
    "note": "Stream functions provide unified interface for file and network I/O through stream wrappers: fopen() (open stream), fread()/fwrite() (read/write), fseek() (seek position), stream_context_create() (create context for options). PHP supports various stream wrappers: file:// (local files), http:// (HTTP resources), ftp:// (FTP resources), php:// (I/O streams), and data:// (data URLs). Stream contexts allow setting options like HTTP headers, timeout values, and SSL parameters. Streams provide consistent API for different data sources and enable features like filters (stream_filter_append()) for on-the-fly data processing.",
    "code": "fopen('php://input', 'r');"
  },
  {
    "title": "PHP String",
    "note": "String functions provide extensive text manipulation capabilities: length and position (strlen(), strpos(), strrpos()), modification (substr(), str_replace(), strtolower(), strtoupper(), trim(), ltrim(), rtrim()), formatting (printf(), sprintf(), number_format()), encoding (htmlspecialchars(), htmlentities(), urlencode(), urldecode()), and parsing (explode(), implode(), strtok()). Strings in PHP are binary-safe and can handle any data. Understanding string encoding (especially UTF-8) is crucial for international applications. String functions are used in virtually every PHP application for text processing, validation, and formatting.",
    "code": "strlen($str);"
  },
  {
    "title": "PHP Variable Handling",
    "note": "Variable handling functions inspect and manipulate variables: type checking (is_array(), is_int(), is_string(), is_object()), value checking (isset(), empty(), is_null()), conversion (settype(), intval(), strval(), floatval()), serialization (serialize(), unserialize()), and variable variables ($$var). These functions are essential for writing flexible code that handles different data types, validating user input, and implementing dynamic programming patterns. Variable handling should be used carefully to maintain code clarity and prevent security issues related to variable manipulation.",
    "code": "isset($var);"
  },
  {
    "title": "PHP XML Parser",
    "note": "The XML Parser extension (based on Expat) provides event-based XML parsing through handler functions: xml_parser_create() (create parser), xml_set_element_handler() (set start/end element handlers), xml_set_character_data_handler() (set character data handler), xml_parse() (parse data), and xml_parser_free() (free parser). Event-based parsing is memory-efficient for large XML documents as it doesn't build a tree structure. However, it requires more code to maintain state and build data structures. XML Parser is suitable for simple XML processing or very large files where memory usage is a concern.",
    "code": "xml_parser_create();"
  },
  {
    "title": "PHP Zip",
    "note": "The Zip extension provides functions for creating, reading, and modifying ZIP archives: ZipArchive class methods (open(), close(), addFile(), addFromString(), extractTo(), getNameIndex(), getFromIndex()) and functions (zip_open(), zip_read(), zip_entry_open()). ZIP archives are commonly used for file compression, packaging multiple files for download, and backup operations. The extension supports reading and writing ZIP files, listing contents, and extracting specific files. ZIP handling is useful for applications that need to process compressed files, generate downloadable packages, or implement backup functionality.",
    "code": "$zip = new ZipArchive();"
  },
  {
    "title": "PHP Timezones",
    "note": "PHP provides comprehensive timezone support through functions like date_default_timezone_set() and the DateTimeZone class. Timezones can be specified using IANA timezone database identifiers (e.g., 'America/New_York', 'Europe/London', 'Asia/Tokyo'). PHP maintains an internal timezone database and handles daylight saving time transitions automatically. The DateTime and DateTimeImmutable classes with DateTimeZone allow for complex date/time calculations across different timezones. Functions like date() and time() use the default timezone unless specified otherwise. Proper timezone handling is crucial for applications serving users in multiple regions, event scheduling, and timestamp storage and display.",
    "code": "date_default_timezone_set('America/New_York');"
  },
  {
    "title": "C Intro",
    "note": "C is a general-purpose, procedural programming language developed in the early 1970s at Bell Labs by Dennis Ritchie. It is one of the most influential programming languages, forming the foundation for many modern languages and operating systems. C provides low-level access to memory, simple keywords, and clean syntax, making it efficient for system programming, embedded systems, and performance-critical applications. Despite its age, C remains widely used in operating systems (Unix, Linux, Windows), compilers, databases, and embedded systems. Understanding C provides fundamental insights into computer architecture and memory management that apply to higher-level languages.",
    "code": "#include <stdio.h>\nint main() {\n  printf(\"Hello, C!\\n\");\n  return 0;\n}"
  },
  {
    "title": "C Get Started",
    "note": "To start programming in C, you need a text editor and a C compiler like GCC (GNU Compiler Collection). The basic workflow involves: writing source code in a .c file, compiling it with a command like 'gcc hello.c -o hello', and executing the resulting binary. GCC compiles C code into machine code, performing preprocessing, compilation, assembly, and linking. Common compiler flags include -Wall (enable warnings), -g (debug information), and -O2 (optimization). Understanding the compilation process helps with debugging and optimizing C programs. Many IDEs like Code::Blocks, Eclipse, or Visual Studio provide integrated development environments for C programming.",
    "code": "gcc hello.c -o hello\n./hello"
  },
  {
    "title": "C Syntax",
    "note": "C syntax is characterized by its simplicity and closeness to machine language. Key elements include: preprocessor directives (#include, #define), function definitions, variable declarations, statements ending with semicolons, and code blocks enclosed in curly braces. C is case-sensitive and uses free-form formatting (whitespace is generally insignificant). The main() function is the program entry point. C requires explicit type declarations, manual memory management, and provides direct memory access through pointers. Understanding C syntax is fundamental to learning many other programming languages that inherited its structural elements.",
    "code": "int x = 5;\nif (x > 0) {\n  printf(\"Positive\\n\");\n}"
  },
  {
    "title": "C Output",
    "note": "The printf() function from stdio.h is the primary output function in C, providing formatted output to stdout. It uses format specifiers: %d (integer), %f (float), %c (character), %s (string), %p (pointer), and %x (hexadecimal). Escape sequences like \\n (newline), \\t (tab), and \\\\ (backslash) control formatting. printf() returns the number of characters printed and can handle variable arguments. For unbuffered output, putchar() outputs single characters. Understanding printf formatting is essential for debugging, user interaction, and generating formatted output in C programs.",
    "code": "printf(\"Number: %d\\n\", 10);"
  },
  {
    "title": "C Comments",
    "note": "C supports two comment styles: single-line comments starting with // (C99 standard) and multi-line comments enclosed in /* ... */. Comments are ignored by the compiler and are essential for code documentation, explaining complex logic, and temporarily disabling code. Good commenting practices include describing function purposes, explaining non-obvious algorithms, and providing header comments with author, date, and description. Over-commenting obvious code should be avoided. Comments should be maintained alongside code changes to prevent inaccuracies. Proper commenting improves code readability and maintainability.",
    "code": "// This is a comment\n/* Multi-line\ncomment */"
  },
  {
    "title": "C Variables",
    "note": "Variables in C are memory locations that store data values. They must be declared with a specific data type before use. Variable names can contain letters, digits, and underscores, but cannot start with a digit. C is case-sensitive. Variables have scope (global, local, block) and storage duration (automatic, static, allocated). Declaration syntax: type variable_name; Initialization can be done at declaration: type variable_name = value; Uninitialized variables contain garbage values. Understanding variable declaration, scope, and lifetime is fundamental to C programming and memory management.",
    "code": "int age = 30;\nfloat price = 99.99;"
  },
  {
    "title": "C Data Types",
    "note": "C provides basic data types: char (character, 1 byte), int (integer, typically 4 bytes), float (single-precision floating point), double (double-precision floating point), and void (no type). Type modifiers (short, long, signed, unsigned) adjust size and representation. The exact sizes are implementation-dependent but specified in limits.h and float.h. Derived types include arrays, pointers, structures, and unions. C99 added _Bool, _Complex, and exact-width types (int8_t, int32_t, etc.) in stdint.h. Understanding data types is crucial for memory efficiency, portability, and avoiding overflow/underflow errors.",
    "code": "char letter = 'A';\nint count = 100;"
  },
  {
    "title": "C Constants",
    "note": "Constants are fixed values that cannot be changed during program execution. C supports: literal constants (5, 3.14, 'A'), symbolic constants using #define (preprocessor macro), and const-qualified variables. #define constants are replaced during preprocessing and have no memory allocation. const variables have memory storage but cannot be modified. Enum constants provide named integer constants. Constants improve code readability, prevent magic numbers, and ensure values aren't accidentally modified. Choosing between #define and const depends on needs: #define for simple values, const for typed constants with scope and storage.",
    "code": "#define PI 3.14\nconst int MAX = 100;"
  },
  {
    "title": "C Operators",
    "note": "C provides rich set of operators: arithmetic (+, -, *, /, %), relational (==, !=, <, >, <=, >=), logical (&&, ||, !), bitwise (&, |, ^, ~, <<, >>), assignment (=, +=, -=, etc.), increment/decrement (++, --), conditional (?:), and comma operator. Operator precedence determines evaluation order; parentheses can override precedence. Understanding operators is essential for expressions, conditionals, and bit manipulation. Some operators have side effects (++, --, assignment), and sequence points affect evaluation order. Operator overloading is not supported in C.",
    "code": "int sum = 5 + 3;\nint flag = (a > b) && (c < d);"
  },
  {
    "title": "C Booleans",
    "note": "C originally had no built-in boolean type; integers were used (0 for false, non-zero for true). C99 introduced _Bool type and stdbool.h header which defines bool, true, and false macros. _Bool variables can only store 0 or 1. Logical operators (&&, ||, !) return 0 or 1. When using integers as booleans, any non-zero value is considered true. Understanding truth values is crucial for conditionals and loops. The stdbool.h approach improves code clarity and type safety for boolean operations compared to traditional integer-based approach.",
    "code": "#include <stdbool.h>\nbool isTrue = true;"
  },
  {
    "title": "C If...Else",
    "note": "The if statement executes code conditionally based on boolean expressions. if evaluates a condition and executes the following statement or block if true. else provides alternative execution when the condition is false. else if allows multiple conditions. Conditions can be any expression; zero is false, non-zero is true. Curly braces are required for multi-statement blocks but optional for single statements (though recommended for clarity). Proper indentation and formatting are essential for readability. if-else statements are fundamental for decision-making and control flow in C programs.",
    "code": "if (x > 0) {\n  printf(\"Positive\\n\");\n} else {\n  printf(\"Non-positive\\n\");\n}"
  },
  {
    "title": "C Switch",
    "note": "The switch statement provides multi-way branching based on an integer expression. It compares the expression against constant case labels and executes the matching code. break statements prevent fall-through to subsequent cases. default handles unmatched values. switch is more efficient than multiple if-else statements for integer comparisons. Case labels must be constant expressions. Fall-through can be intentional but should be commented. switch is ideal for menu systems, state machines, and any scenario with multiple constant values to check against an expression.",
    "code": "switch(option) {\n  case 1: printf(\"One\\n\"); break;\n  default: printf(\"Other\\n\");\n}"
  },
  {
    "title": "C While Loop",
    "note": "The while loop repeats a statement or block while a condition remains true. The condition is evaluated before each iteration; if false initially, the loop body never executes. while loops are ideal when the number of iterations is unknown beforehand but depends on a changing condition. Proper loop design requires: initializing loop variables, updating them within the loop, and ensuring the condition eventually becomes false to prevent infinite loops. while loops are fundamental for input validation, processing until sentinel values, and iterative algorithms.",
    "code": "int i = 0;\nwhile (i < 5) {\n  printf(\"%d\\n\", i);\n  i++;\n}"
  },
  {
    "title": "C For Loop",
    "note": "The for loop provides compact syntax for iteration with initialization, condition, and increment expressions. It's ideal when the number of iterations is known in advance. The initialization executes once, the condition is checked before each iteration, and the increment executes after each iteration. Any of the three expressions can be omitted (infinite loop with all omitted). for loops are commonly used for array traversal, counting, and fixed-number iterations. The loop variable is typically declared within the for statement (C99), limiting its scope to the loop.",
    "code": "for (int i = 0; i < 5; i++) {\n  printf(\"%d\\n\", i);\n}"
  },
  {
    "title": "C Break/Continue",
    "note": "break exits the innermost loop or switch statement immediately. continue skips the remaining code in the current iteration and proceeds to the next iteration. Both statements alter normal loop flow and are typically used with conditional logic. break is useful for early termination when a condition is met or an error occurs. continue is useful for skipping certain elements in processing. These statements should be used judiciously to maintain code clarity. In nested loops, they only affect the innermost loop; labels are not supported for breaking out of outer loops in C.",
    "code": "for (int i = 0; i < 10; i++) {\n  if (i == 5) break;\n  if (i % 2 == 0) continue;\n  printf(\"%d\\n\", i);\n}"
  },
  {
    "title": "C Arrays",
    "note": "Arrays are contiguous collections of elements of the same type. Declaration specifies type, name, and size: type array[size]. Array indices start at 0. Arrays can be initialized with braces: int arr[5] = {1,2,3,4,5}. Multi-dimensional arrays are arrays of arrays. Arrays are passed to functions by reference (pointer to first element). Array bounds are not checked; accessing out-of-bounds elements causes undefined behavior. Arrays are fundamental for storing collections, implementing algorithms, and working with strings (character arrays). Understanding array-pointer relationship is key to C programming.",
    "code": "int numbers[5] = {1, 2, 3, 4, 5};"
  },
  {
    "title": "C Strings",
    "note": "Strings in C are null-terminated character arrays. The null character ('\\0') marks the end of the string. String literals are enclosed in double quotes and include implicit null terminator. Common string functions (from string.h) include: strlen() (length), strcpy() (copy), strcat() (concatenate), strcmp() (compare), and strchr() (find character). Strings are mutable unless declared as pointers to string literals. Buffer overflows are a common security issue with strings; functions like strncpy() provide length-limited alternatives. Understanding string handling is essential for text processing in C.",
    "code": "char name[] = \"Alice\";"
  },
  {
    "title": "C User Input",
    "note": "The scanf() function from stdio.h reads formatted input from stdin. It uses format specifiers similar to printf: %d (integer), %f (float), %c (character), %s (string). The & operator provides variable addresses for storage. scanf() returns the number of successfully read items. Input validation is crucial as scanf() can cause buffer overflows with %s. Alternative functions: getchar() for single characters, fgets() for line input (safer for strings). Handling input errors and flushing stdin are important for robust input processing. Understanding input functions is essential for interactive programs.",
    "code": "int age;\nprintf(\"Enter age: \");\nscanf(\"%d\", &age);"
  },
  {
    "title": "C Memory Address",
    "note": "The & (address-of) operator returns the memory address of a variable. Addresses are typically printed with %p format specifier. Understanding memory addresses is fundamental to pointers, which are variables that store memory addresses. Each variable has a unique address determined at runtime. The address size depends on the architecture (32-bit vs 64-bit). Address arithmetic enables array traversal and efficient memory manipulation. Knowing variable locations helps understand memory layout, pointer operations, and low-level programming concepts. Addresses are crucial for passing arguments by reference and dynamic memory allocation.",
    "code": "int x = 10;\nprintf(\"Address: %p\", &x);"
  },
  {
    "title": "C Pointers",
    "note": "Pointers are variables that store memory addresses rather than direct values. They are declared with an asterisk (*) and are fundamental to C programming for efficient memory management, array handling, and dynamic data structures. The address-of operator (&) gets a variable's address, and the dereference operator (*) accesses the value at a stored address. Pointers enable pass-by-reference function parameters, dynamic memory allocation, and direct memory manipulation. Understanding pointer arithmetic, pointer types, and the relationship between pointers and arrays is crucial for advanced C programming and systems-level development.",
    "code": "int x = 10;\nint *p = &x;\nprintf(\"Value: %d\", *p);"
  },
  {
    "title": "C Functions",
    "note": "Functions are self-contained blocks of code that perform specific tasks, promoting modularity, code reuse, and organization. Functions are defined with a return type, name, parameters, and body. They can return values using the return statement or be void (no return). Functions help break down complex problems into manageable pieces, reduce code duplication, and improve readability. Proper function design includes meaningful names, focused responsibilities, and clear parameter interfaces. Functions facilitate testing and maintenance by isolating functionality.",
    "code": "int add(int a, int b) {\n  return a + b;\n}"
  },
  {
    "title": "C Function Parameters",
    "note": "Function parameters allow data to be passed into functions. C uses pass-by-value by default, meaning copies of arguments are passed. For modifying original variables or passing large data structures, pointers are used to achieve pass-by-reference. Parameters are declared with types and names in the function signature. Arrays decay to pointers when passed as parameters. Understanding parameter passing mechanisms, const correctness, and the difference between value and reference parameters is essential for writing correct and efficient functions.",
    "code": "void greet(char *name) {\n  printf(\"Hello %s\\n\", name);\n}"
  },
  {
    "title": "C Scope",
    "note": "Scope defines the visibility and lifetime of variables. C has several scope levels: block scope (variables declared inside {} blocks), function scope (labels), file scope (global variables and functions), and function prototype scope (parameters in declarations). Variables can shadow outer scope variables with the same name. Understanding scope is crucial for avoiding naming conflicts, managing memory efficiently, and writing modular code. The static keyword can modify scope and lifetime, making file-scoped variables private to the translation unit.",
    "code": "int x = 5; // global\nvoid func() {\n  int x = 10; // local\n}"
  },
  {
    "title": "C Function Declaration",
    "note": "Function declarations (prototypes) specify a function's interface without defining its implementation. They include the return type, function name, and parameter types (names are optional). Declarations allow functions to be used before they are defined and enable separate compilation. Header files typically contain function declarations, while source files contain definitions. Proper declarations help the compiler check function usage and enable better code organization. Without declarations, functions are assumed to return int, which can cause subtle bugs.",
    "code": "int multiply(int a, int b);"
  },
  {
    "title": "C Recursion",
    "note": "Recursion occurs when a function calls itself directly or indirectly. Each recursive call creates a new stack frame with its own parameters and local variables. Recursive functions must have a base case (terminating condition) to prevent infinite recursion. Recursion is elegant for problems that naturally exhibit recursive structure like tree traversals, mathematical sequences, and divide-and-conquer algorithms. However, recursion can be memory-intensive due to stack usage and may cause stack overflow for deep recursion. Some problems have both recursive and iterative solutions.",
    "code": "int factorial(int n) {\n  if (n == 0) return 1;\n  else return n * factorial(n-1);\n}"
  },
  {
    "title": "C Math Functions",
    "note": "The math.h header provides common mathematical functions: sqrt() (square root), pow() (power), exp() (exponential), log() (natural logarithm), sin(), cos(), tan() (trigonometry), ceil(), floor() (rounding), and fabs() (absolute value). These functions typically operate on and return double precision floating-point numbers. Linking with the math library may require -lm flag with GCC. Math functions are essential for scientific computing, graphics, simulations, and any application requiring mathematical calculations beyond basic arithmetic.",
    "code": "#include <math.h>\ndouble x = sqrt(16);"
  },
  {
    "title": "C Files",
    "note": "File handling in C uses the FILE structure and functions from stdio.h. Files are opened with fopen() which returns a FILE pointer. Different modes include: \"r\" (read), \"w\" (write), \"a\" (append), and binary variants (\"rb\", \"wb\", \"ab\"). Files should always be closed with fclose() to release resources. File operations include reading/writing characters (fgetc(), fputc()), lines (fgets(), fputs()), formatted I/O (fscanf(), fprintf()), and binary I/O (fread(), fwrite()). Proper error checking is essential for robust file handling.",
    "code": "FILE *f = fopen(\"data.txt\", \"r\");\nchar c = fgetc(f);\nfclose(f);"
  },
  {
    "title": "C Create Files",
    "note": "Files are created using fopen() with write (\"w\") or append (\"a\") modes. \"w\" mode creates a new file or truncates an existing file. \"a\" mode creates a new file or appends to an existing file. File creation may fail due to permission issues, full disks, or invalid paths. Successful creation returns a FILE pointer; failure returns NULL. Files can be written using various functions: fputc() for characters, fputs() for strings, fprintf() for formatted output, or fwrite() for binary data. Newly created files should be properly closed to ensure all data is written.",
    "code": "FILE *f = fopen(\"file.txt\", \"w\");\nfputs(\"Hello\", f);\nfclose(f);"
  },
  {
    "title": "C Write To Files",
    "note": "Writing to files uses functions similar to standard output but with a FILE pointer argument. fprintf() writes formatted text, fputs() writes strings, fputc() writes characters, and fwrite() writes binary data. Data is typically buffered; fflush() forces writing of buffered data. Write operations may fail due to disk full, permission issues, or device errors; checking return values is important. For critical data, files should be closed properly to ensure all buffered data is written. File writing is essential for data logging, configuration storage, and output generation.",
    "code": "fprintf(f, \"Number: %d\", 100);"
  },
  {
    "title": "C Read Files",
    "note": "Reading from files uses functions that take a FILE pointer. fgets() reads a line of text, fgetc() reads a single character, fscanf() reads formatted input, and fread() reads binary data. fgets() is safer for string input as it limits the number of characters read. Reading continues until EOF is reached; feof() checks for end-of-file. Read operations may fail due to file errors or format mismatches; checking return values is crucial. File reading is used for configuration parsing, data processing, and input handling in applications.",
    "code": "char buffer[100];\nfgets(buffer, 100, f);"
  },
  {
    "title": "C Structures",
    "note": "Structures (struct) allow grouping variables of different types under a single name. They are used to represent records, complex data types, and objects. Structure members are accessed using the dot operator (.). Structures can contain other structures, arrays, and pointers. They are passed by value to functions (copied) unless pointers are used. Structures are essential for organizing related data, creating complex data types, and implementing data structures like linked lists and trees. The sizeof operator gives the structure's size, which may include padding for alignment.",
    "code": "struct Point {\n  int x;\n  int y;\n};"
  },
  {
    "title": "C Structs & Pointers",
    "note": "Pointers to structures are commonly used for efficient passing to functions, dynamic allocation, and building data structures. The arrow operator (->) accesses structure members through pointers. Structure pointers avoid the overhead of copying large structures. They are essential for linked data structures, function parameters that modify structures, and dynamic memory allocation of structures. Understanding the relationship between structures and pointers is crucial for advanced C programming and data structure implementation.",
    "code": "struct Point p;\nstruct Point *ptr = &p;\nptr->x = 10;"
  },
  {
    "title": "C Unions",
    "note": "Unions allow storing different data types in the same memory location. Only one member can contain a value at any time. Unions are useful for memory-efficient storage of alternative data types, type punning (with care), and interpreting the same data in different ways. The size of a union is at least the size of its largest member. Unions require careful management to track which member is currently valid. They are commonly used in low-level programming, protocol implementation, and memory-constrained environments.",
    "code": "union Data {\n  int i;\n  float f;\n};"
  },
  {
    "title": "C Enums",
    "note": "Enumerations (enum) define named integer constants, making code more readable and maintainable. Enum constants are assigned increasing integer values starting from 0 by default, but explicit values can be specified. Enums provide type safety compared to #define constants and can be used as integer types. They are ideal for representing fixed sets of values like states, options, or categories. Enum names are in the same namespace as other identifiers, so naming should be chosen carefully to avoid conflicts.",
    "code": "enum Color { RED, GREEN, BLUE };"
  },
  {
    "title": "C Memory Management",
    "note": "Dynamic memory allocation allows requesting memory at runtime using malloc(), calloc(), and realloc(). malloc() allocates uninitialized memory, calloc() allocates zero-initialized memory, and realloc() resizes existing allocations. Allocated memory must be freed with free() to avoid memory leaks. Memory management is manual in C, requiring careful attention to allocation sizes, initialization, and freeing. Common issues include memory leaks, dangling pointers, and buffer overflows. Proper memory management is crucial for robust, efficient programs.",
    "code": "int *p = malloc(sizeof(int));\nfree(p);"
  },
  {
    "title": "C Errors",
    "note": "C programs should check for and handle errors from library functions and system calls. Most functions indicate errors through return values (often NULL or -1) and set the global errno variable to specific error codes. perror() and strerror() convert error codes to descriptive messages. Error handling includes checking return values, validating input, and providing graceful degradation or informative error messages. Robust error handling prevents crashes, improves user experience, and aids debugging.",
    "code": "if (ptr == NULL) {\n  printf(\"Memory allocation failed\");\n}"
  },
  {
    "title": "C Debugging",
    "note": "Debugging C programs involves identifying and fixing bugs using tools like GDB (GNU Debugger), printf statements, static analyzers, and valgrind for memory checking. GDB allows setting breakpoints, stepping through code, examining variables, and analyzing crashes. Debugging requires understanding program state, reproduction of issues, and systematic problem isolation. Good practices include defensive programming, assertions, and thorough testing. Debugging skills are essential for developing reliable C programs.",
    "code": "// Run gdb ./program"
  },
  {
    "title": "C NULL",
    "note": "NULL is a macro that represents a null pointer constant, typically defined as (void*)0. It indicates that a pointer does not point to any valid memory location. NULL is used to initialize pointers, indicate errors from functions that return pointers, and check for uninitialized or freed pointers. Dereferencing a NULL pointer causes undefined behavior (usually a segmentation fault). Using NULL makes pointer intentions clear and helps prevent accidental use of invalid pointers.",
    "code": "int *p = NULL;"
  },
  {
    "title": "C Error Handling",
    "note": "Comprehensive error handling in C involves checking function return values, validating input parameters, and using errno for system error details. perror() prints descriptive error messages based on errno. Error handling strategies include returning error codes, using global error variables, or implementing exception-like mechanisms with setjmp/longjmp. Consistent error handling throughout an application improves reliability and maintainability. Error messages should be informative but avoid exposing sensitive information in production.",
    "code": "if (fopen(...) == NULL) {\n  perror(\"File open error\");\n}"
  },
  {
    "title": "C Input Validation",
    "note": "Input validation ensures that program input meets expected criteria before processing. This includes checking return values from input functions, validating ranges, formats, and lengths, and handling unexpected or malicious input. scanf() returns the number of successfully matched items, which should be checked. For user input, loops may be needed to prompt for valid input. Input validation prevents crashes, security vulnerabilities, and incorrect program behavior. It's especially important for programs that process external data or user input.",
    "code": "if (scanf(\"%d\", &num) != 1) {\n  printf(\"Invalid input\");\n}"
  },
  {
    "title": "C Date",
    "note": "The time.h header provides functions for date and time operations. time() returns the current calendar time as time_t (seconds since epoch). localtime() converts to broken-down time structure tm. strftime() formats date/time as strings. clock() measures processor time used. Date/time functions are used for logging, timing, scheduling, and any application that needs temporal information. Understanding time representation and time zones is important for correct date/time handling.",
    "code": "#include <time.h>\ntime_t now = time(NULL);"
  },
  {
    "title": "C Macros",
    "note": "Macros are defined using #define and are processed by the preprocessor. They can be simple constants or function-like macros with parameters. Macros perform text substitution before compilation. Advantages include no function call overhead and genericity. Disadvantages include lack of type checking, multiple evaluation of parameters, and debugging difficulties. Parentheses are crucial in macro definitions to ensure correct precedence. Macros are used for constants, inline functions, conditional compilation, and code generation.",
    "code": "#define MAX 100\n#define SQUARE(x) ((x) * (x))"
  },
  {
    "title": "C Organize Code",
    "note": "Large C programs are organized into multiple source and header files. Header files (.h) contain declarations, constants, and macros. Source files (.c) contain definitions. The #include directive incorporates header files. This organization enables separate compilation, code reuse, and modular design. Header guards prevent multiple inclusion. Makefiles or build systems manage compilation and linking. Good organization improves maintainability, reduces compilation times, and facilitates team development.",
    "code": "// Use #include \"header.h\""
  },
  {
    "title": "C Storage Classes",
    "note": "Storage classes determine variable storage duration and linkage: auto (default for locals, automatic storage), register (hint for register storage), static (persistent storage, file scope or persistent locals), extern (declaration without definition), and typedef (creates type aliases). Storage classes control variable lifetime, visibility, and initialization. Understanding storage classes is essential for managing variable scope across multiple files, optimizing performance, and implementing singletons or persistent state.",
    "code": "static int count = 0;"
  },
  {
    "title": "C Projects",
    "note": "Building C projects involves creating multiple source files, headers, and a build system. Common project types include: system utilities, embedded systems, games, compilers, and libraries. Project structure typically separates interface (headers) from implementation (source), with modules organized by functionality. Build tools like Make, CMake, or IDE projects manage compilation and dependencies. Version control, testing, and documentation are important aspects of project development. Real projects help integrate various C concepts and develop practical programming skills.",
    "code": "// Project ideas like calculator, file parser"
  },
  {
    "title": "C Keywords",
    "note": "C has 32 keywords that have special meaning and cannot be used as identifiers: auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, int, long, register, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while. C99 added _Bool, _Complex, _Imaginary, inline, restrict. C11 added _Alignas, _Alignof, _Atomic, _Generic, _Noreturn, _Static_assert, _Thread_local. Keywords define the language syntax and must be used in their specific contexts.",
    "code": "int, return, if, else, switch, etc."
  },
  {
    "title": "C <stdio.h>",
    "note": "The standard input/output library provides functions for console I/O, file I/O, and formatted I/O. Key functions include: printf()/scanf() (formatted I/O), getchar()/putchar() (character I/O), gets()/puts() (string I/O - avoid gets), fopen()/fclose() (file operations), and fread()/fwrite() (binary I/O). stdin, stdout, and stderr are standard streams. stdio.h is essential for most C programs as it provides basic input/output capabilities and file handling functions.",
    "code": "printf(\"Hello\");\nscanf(\"%d\", &num);"
  },
  {
    "title": "C <stdlib.h>",
    "note": "The standard library provides general-purpose functions including: memory allocation (malloc(), calloc(), realloc(), free()), process control (exit(), abort(), system()), random numbers (rand(), srand()), number conversion (atoi(), atof(), strtol()), and environment (getenv()). It also defines NULL, size_t, and several macros. stdlib.h functions are widely used for dynamic memory management, program termination, and various utility operations. Understanding these functions is crucial for robust C programming.",
    "code": "malloc(), free(), exit()"
  },
  {
    "title": "C <string.h>",
    "note": "The string library provides functions for manipulating null-terminated strings: copying (strcpy(), strncpy()), concatenation (strcat(), strncat()), comparison (strcmp(), strncmp()), searching (strchr(), strstr()), length (strlen()), and memory operations (memcpy(), memset()). These functions are essential for string processing but require careful use to avoid buffer overflows. The safer _s versions (C11) provide bounds checking. string.h is used in virtually all programs that process text data.",
    "code": "strcpy(dest, src);"
  },
  {
    "title": "C <math.h>",
    "note": "The math library provides mathematical functions: trigonometric (sin(), cos(), tan()), exponential and logarithmic (exp(), log(), log10()), power (pow(), sqrt()), rounding (ceil(), floor(), round()), and absolute value (fabs()). Most functions operate on and return double. The library may require linking with -lm. math.h is essential for scientific computing, graphics, financial calculations, and any application requiring advanced mathematical operations beyond basic arithmetic.",
    "code": "sqrt(9);"
  },
  {
    "title": "C <ctype.h>",
    "note": "The character handling library provides functions for classifying and converting characters: classification (isalpha(), isdigit(), isspace(), isupper(), islower()), conversion (toupper(), tolower()). These functions take an int (character) and return an int (nonzero for true). They are useful for input validation, parsing, and text processing. ctype.h functions are typically implemented as macros for efficiency and are used in programs that process textual data character by character.",
    "code": "isalpha('A');"
  },
  {
    "title": "C <time.h>",
    "note": "The time library provides functions for date and time operations: getting current time (time(), clock()), conversion (localtime(), gmtime(), mktime()), formatting (strftime(), asctime()), and differences (difftime()). time_t represents time in seconds since epoch, and struct tm represents broken-down time. time.h is used for logging, benchmarking, scheduling, and any application that needs to work with dates and times.",
    "code": "time(NULL);"
  },
  {
    "title": "C Examples",
    "note": "C programming examples demonstrate practical implementation of language features: basic syntax examples (Hello World, variables, control structures), algorithm implementations (sorting, searching, recursion), data structures (linked lists, trees, stacks), system programming (file I/O, processes), and utility programs (calculators, text processors). Examples help learners understand how to apply C concepts to solve problems and serve as templates for similar tasks.",
    "code": "// Hello World, factorial, array sorting"
  },
  {
    "title": "C Real-Life Examples",
    "note": "Real-life C programs solve practical problems: system utilities (ls, grep, make), embedded systems firmware, game development, compilers and interpreters, operating system kernels, network servers, and scientific simulations. These examples demonstrate how C is used in production environments, often emphasizing performance, memory efficiency, and low-level control. Studying real-life examples provides insight into professional C programming practices, code organization, and performance optimization techniques.",
    "code": "// File parser, calculator, game"
  },
  {
    "title": "C Exercises",
    "note": "C programming exercises provide practice problems to develop coding skills: basic exercises (loops, functions, arrays), pointer challenges, memory management problems, algorithm implementation, and data structure exercises. Exercises range from simple syntax practice to complex problem-solving. Platforms like LeetCode, HackerRank, and university course websites offer graded exercises with automated testing. Regular practice with diverse exercises builds problem-solving ability and deepens understanding of C concepts.",
    "code": "// Solve loops, functions, pointers exercises"
  },
  {
    "title": "C Quiz",
    "note": "C quizzes test knowledge through multiple-choice questions, code interpretation problems, and debugging exercises. Topics include: language syntax, pointer concepts, memory management, standard library functions, and common pitfalls. Quizzes help identify knowledge gaps, prepare for exams or interviews, and reinforce learning through immediate feedback. Many online learning platforms and textbooks include quizzes with explanations to clarify tricky concepts and common misunderstandings.",
    "code": "// Multiple choice questions"
  },
  {
    "title": "C Compiler",
    "note": "The C compiler translates source code into executable machine code. GCC (GNU Compiler Collection) is the most common C compiler, supporting multiple standards (C89, C99, C11, C17). Compilation involves preprocessing, compilation proper, assembly, and linking. Common compiler flags: -std (C standard), -Wall (warnings), -g (debug info), -O (optimization), -I (include paths), -L (library paths), -l (libraries). Understanding compiler options and error messages is essential for effective C development. Other compilers include Clang, MSVC, and ICC.",
    "code": "gcc program.c -o program"
  },
  {
    "title": "C Syllabus",
    "note": "A comprehensive C syllabus covers: C fundamentals (syntax, data types, operators), control structures, functions, arrays and strings, pointers, memory management, structures and unions, file I/O, preprocessor, and standard library. The syllabus should progress from basic concepts to advanced topics, with practical programming assignments at each stage. A well-structured syllabus includes learning objectives, recommended resources, assessment methods, and timeline. It serves as a roadmap for systematic learning of C programming.",
    "code": "// Topic outline for beginners"
  },
  [
  {
    "title": "C Study Plan",
    "note": "A comprehensive C study plan typically spans 8-12 weeks, starting with basic syntax and progressing to advanced topics. Week 1-2: Fundamentals (variables, data types, operators, basic I/O). Week 3-4: Control structures and functions (loops, conditionals, function definitions). Week 5-6: Arrays, strings, and pointers (memory addresses, pointer arithmetic). Week 7-8: Advanced topics (structures, unions, dynamic memory allocation). Week 9-10: File I/O and standard library usage. Week 11-12: Project work and advanced concepts (multithreading, networking basics). Daily practice should include both theoretical learning and hands-on coding exercises, with weekly projects to reinforce concepts.",
    "code": "// Assign topics and exercises"
  },
  {
    "title": "C Certificate",
    "note": "Several organizations offer C programming certifications to validate skills. The C Programming Language Certified Associate (CLA) from C++ Institute is a popular entry-level certification. More advanced certifications include the C Certified Professional Programmer (CLP) and C++ Institute's various levels. These certifications typically involve exams testing knowledge of C syntax, memory management, pointers, standard libraries, and problem-solving skills. Preparation usually requires 3-6 months of study using official guides, practice tests, and practical coding experience. Certifications can enhance job prospects, especially in embedded systems, systems programming, and safety-critical industries.",
    "code": "// Info about exams and credentials"
  },
  {
    "title": "C Networking",
    "note": "C provides low-level networking capabilities through the sockets API (sys/socket.h). Basic network programming involves creating sockets (socket()), binding to addresses (bind()), listening for connections (listen()), accepting connections (accept()), and sending/receiving data (send()/recv()). TCP provides reliable stream-oriented communication, while UDP offers connectionless datagram service. Network programming requires understanding of IP addresses, ports, byte ordering (htons(), ntohs()), and protocol specifics. Error handling is crucial as network operations can fail due to various conditions. Networking is essential for client-server applications, web servers, and distributed systems.",
    "code": "#include <sys/socket.h>\n// Basic socket setup code"
  },
  {
    "title": "C Multithreading",
    "note": "The pthreads (POSIX threads) library enables multithreading in C on Unix-like systems. Threads are created with pthread_create(), which requires a function pointer and argument. Threads can be joined (pthread_join()) or detached (pthread_detach()). Synchronization mechanisms include mutexes (pthread_mutex_t) for mutual exclusion, condition variables (pthread_cond_t) for signaling, and semaphores. Thread-safe programming requires careful attention to shared data access, avoiding race conditions, and proper cleanup. Multithreading improves performance on multi-core systems for parallelizable tasks but increases complexity significantly.",
    "code": "#include <pthread.h>\nvoid* thread_func(void* arg) { /*...*/ }"
  },
  {
    "title": "C Interfacing",
    "note": "C can interface with other languages through various mechanisms. For assembly, inline assembly (asm keyword) allows embedding assembly instructions directly in C code. For higher-level languages, C functions can be called from Python using ctypes or CFFI, from Java using JNI (Java Native Interface), and from .NET languages using P/Invoke. The extern keyword declares functions defined in other compilation units. Interfacing requires understanding calling conventions, data type mapping, and memory management across language boundaries. This is essential for performance-critical sections, hardware access, and leveraging existing libraries.",
    "code": "// Example: Calling assembly from C or vice versa"
  },
  {
    "title": "Embedded C",
    "note": "Embedded C programming involves writing C code for microcontrollers and resource-constrained systems. It typically requires direct hardware register manipulation, bit-level operations, and careful memory management. Key aspects include: volatile keyword for hardware registers, interrupt service routines, memory-mapped I/O, and low-power programming. Embedded C often uses compiler extensions and must account for hardware-specific constraints like limited RAM, flash memory, and processor architecture. Understanding datasheets, schematics, and hardware operation is crucial. Embedded C is used in automotive systems, IoT devices, consumer electronics, and industrial control systems.",
    "code": "// Direct register manipulation example for microcontrollers"
  },
  {
    "title": "C Optimization",
    "note": "C optimization techniques focus on improving performance and reducing memory usage. Key approaches include: algorithm optimization (choosing efficient algorithms), compiler optimization flags (-O2, -O3), loop optimization (unrolling, fusion), memory access patterns (cache-friendly code), function inlining, and register usage. Profiling tools like gprof help identify bottlenecks. Low-level optimizations include using restricted pointers, alignment directives, and architecture-specific intrinsics. However, optimization should follow the principle of 'make it right, then make it fast' and maintain code readability. Premature optimization should be avoided.",
    "code": "// Use compiler flags and optimize loops"
  },
  {
    "title": "C Security",
    "note": "Writing secure C code requires preventing common vulnerabilities: buffer overflows (use bounds-checked functions like strncpy() instead of strcpy()), integer overflows, format string vulnerabilities (avoid user-controlled format strings), and use-after-free errors. Security best practices include: validating all input, using safe string functions, avoiding dangerous functions (gets()), principle of least privilege, and static analysis tools. The CERT C Secure Coding Standard provides comprehensive guidelines. Security is particularly important in C due to its low-level nature and lack of built-in safety features found in higher-level languages.",
    "code": "// Use safe functions like strncpy instead of strcpy"
  },
  {
    "title": "C Design Patterns",
    "note": "While design patterns are often associated with object-oriented languages, many can be implemented in C using function pointers, structures, and careful design. Common patterns include: Factory (function returning structured data), Singleton (static variable with access function), Observer (callback functions), Strategy (function pointers in structures), and Iterator (structure with iteration state). C patterns typically emphasize composition over inheritance and use void pointers for polymorphism. Understanding these patterns helps create modular, maintainable C code despite the language's lack of built-in OOP features.",
    "code": "// Example: Singleton pattern implemented in C"
  },
  {
    "title": "C Build Systems",
    "note": "Build systems automate the compilation and linking process for C projects. Make is the most common build tool, using Makefiles that specify dependencies and build rules. Modern alternatives include CMake (cross-platform makefile generation), Meson, and Autotools. Build systems handle: dependency tracking, incremental builds, compiler flag management, and target generation (libraries, executables). Complex projects may involve multiple source directories, generated code, and conditional compilation. Understanding build systems is essential for managing large projects, ensuring reproducible builds, and integrating with continuous integration systems.",
    "code": "all:\n\tgcc main.c -o main"
  },
  {
    "title": "C Testing",
    "note": "C testing frameworks help ensure code quality through automated testing. Popular frameworks include: Unity (lightweight unit testing), CMock (mocking framework), Check (comprehensive testing), and CUnit (xUnit style). Testing in C presents challenges due to the lack of built-in reflection and object-oriented features. Techniques include: function pointer injection for mocking, conditional compilation for test code, and separate test executables. Test-driven development (TDD) in C involves writing tests before implementation. Automated testing is crucial for catching regressions, especially in safety-critical systems.",
    "code": "// Basic test case example using Unity"
  },
  {
    "title": "C GUI",
    "note": "Creating graphical user interfaces in C typically involves using external libraries since C has no built-in GUI support. Common options include: GTK (GIMP Toolkit) for cross-platform applications, WinAPI for Windows-specific programs, ncurses for terminal-based interfaces, and SDL for games and multimedia applications. GUI programming in C involves event-driven programming, callback functions, and managing widget hierarchies. While more verbose than higher-level languages, C GUI programming offers performance benefits and low-level control. Many GUI libraries provide C APIs even if implemented in other languages.",
    "code": "// GTK example: creating a simple window"
  }
]
],
Cplusplus :[
  {
    "title": "C++ Intro",
    "note": "C++ is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C language. It supports multiple programming paradigms including procedural, object-oriented, and generic programming. C++ is known for its high performance, efficiency, and fine-grained control over system resources. It is widely used in systems software, game development, embedded systems, high-performance applications, and large-scale software infrastructure. C++ maintains backward compatibility with C while adding features like classes, templates, exceptions, and the Standard Template Library (STL).",
    "code": "#include <iostream>\nint main() {\n    std::cout << \"Hello, C++!\" << std::endl;\n    return 0;\n}"
  },
  {
    "title": "C++ Get Started",
    "note": "To start programming in C++, you need a text editor and a C++ compiler like g++ (GNU C++ Compiler) or clang++. The basic workflow involves writing source code in .cpp files, compiling with a command like 'g++ main.cpp -o main', and executing the resulting binary. Modern C++ development often uses IDEs like Visual Studio, CLion, or Code::Blocks that provide integrated editing, compiling, and debugging. Understanding the compilation process (preprocessing, compilation, assembly, linking) is important for troubleshooting build issues.",
    "code": "// Save as main.cpp\n// Compile: g++ main.cpp -o main\n// Run: ./main"
  },
  {
    "title": "C++ Syntax",
    "note": "C++ syntax is based on C syntax but extends it with additional features. Key elements include: preprocessor directives, function definitions, variable declarations, control structures, and class definitions. C++ is case-sensitive and uses free-form formatting. The main() function is the program entry point. C++ introduces references, function overloading, default arguments, and other features not present in C. Understanding both C-like syntax and C++-specific constructs is essential for effective C++ programming.",
    "code": "int add(int a, int b) {\n    return a + b;\n}"
  },
  {
    "title": "C++ Output",
    "note": "C++ uses the iostream library for output, primarily through std::cout and the insertion operator (<<). std::endl is used to end lines and flush the output buffer. The iostream library provides type-safe output that automatically handles different data types. Output can be formatted using manipulators from <iomanip>. C++ output is generally more type-safe and extensible than C's printf, allowing custom types to define their own output behavior through operator overloading.",
    "code": "#include <iostream>\nstd::cout << \"Hello World!\" << std::endl;"
  },
  {
    "title": "C++ Comments",
    "note": "C++ supports two comment styles inherited from C: single-line comments starting with // and multi-line comments enclosed in /* ... */. Comments are ignored by the compiler and are essential for documentation. Good commenting practices include describing the purpose of functions, explaining complex algorithms, and providing header comments with metadata. Doxygen-style comments can be used to generate documentation automatically. Comments should be maintained alongside code changes to avoid becoming misleading.",
    "code": "// This is a single-line comment\n/* This is a\n   multi-line comment */"
  },
  {
    "title": "C++ Variables",
    "note": "Variables in C++ are declared with a specific type and can be initialized at declaration. C++ supports type inference with auto keyword (C++11). Variables have scope (local, class, namespace) and storage duration (automatic, static, dynamic). C++ introduces references as an alternative to pointers for aliasing variables. Variable declaration syntax allows more flexibility than C, with declarations possible anywhere in code (not just at block beginning). Understanding variable lifetime and scope is crucial for memory management and avoiding bugs.",
    "code": "int age = 30;\ndouble price = 99.99;"
  },
  {
    "title": "C++ User Input",
    "note": "C++ uses std::cin with the extraction operator (>>) for input. std::cin is type-safe but can leave the input stream in a bad state if input doesn't match the expected type. Robust input handling includes checking the stream state (fail(), eof()), clearing errors, and ignoring invalid input. The getline() function reads entire lines as strings, which can then be parsed. Input validation is important for security and correctness, especially when dealing with user-provided data.",
    "code": "int num;\nstd::cin >> num;"
  },
  {
    "title": "C++ Data Types",
    "note": "C++ includes all C data types (char, int, float, double, etc.) and adds bool and wchar_t. C++ provides more flexible type conversion through static_cast, dynamic_cast, const_cast, and reinterpret_cast. User-defined types (classes, structs, enums) are fundamental to C++ programming. C++11 introduced auto for type inference and nullptr for null pointers. Understanding type sizes, signedness, and conversion rules is essential for writing portable and correct code.",
    "code": "int a = 5;\ndouble b = 3.14;\nchar c = 'A';"
  },
  {
    "title": "C++ Operators",
    "note": "C++ supports all C operators and adds several new ones: new and delete for dynamic memory, scope resolution (::), member access operators (.*, ->*), and type identification (typeid). C++ allows operator overloading, enabling custom types to define their own operator behavior. Operators have precedence and associativity that determine evaluation order. Understanding operators is crucial for expressions, and operator overloading is a powerful feature for creating intuitive interfaces for custom types.",
    "code": "int sum = a + b;\nbool check = (a > b) && (b != 0);"
  },
  {
    "title": "C++ Strings",
    "note": "The std::string class (from <string> header) provides a convenient and safe way to handle strings in C++. std::string manages memory automatically, supports various operations (concatenation, substring, search, replace), and integrates well with I/O streams. C++ strings are not null-terminated internally, though c_str() provides access to a null-terminated C-style string. std::string is preferred over C-style char arrays for most applications due to its safety and convenience features.",
    "code": "#include <string>\nstd::string name = \"Alice\";"
  },
  {
    "title": "C++ Math",
    "note": "C++ provides mathematical functions through the <cmath> header, which includes functions from C's math.h with additional overloads for different types. Common functions include sqrt(), pow(), sin(), cos(), log(), and various rounding functions. The <complex> header provides complex number support. C++ also has numeric limits information in <limits> and <limits.h>. For most mathematical needs, <cmath> functions are sufficient, but third-party libraries like Boost.Math provide additional functionality.",
    "code": "#include <cmath>\ndouble result = std::sqrt(16.0);"
  },
  {
    "title": "C++ Booleans",
    "note": "C++ has a built-in bool type with values true and false (keywords introduced in C++). Boolean values are integral types (true converts to 1, false to 0) but are distinct from integers for overloading and template purposes. Logical operators (&&, ||, !) return bool results. The bool type improves code clarity and type safety compared to using integers for Boolean values. In conditions, any nonzero value is considered true, zero is false.",
    "code": "bool isReady = true;"
  },
  {
    "title": "C++ If...Else",
    "note": "C++ if statements work like C but can declare variables in the condition (C++17). if, else if, and else provide conditional execution based on Boolean expressions. Conditions can be any expression that can be contextually converted to bool. Curly braces are required for multi-statement blocks but optional for single statements (though recommended for clarity). if constexpr (C++17) provides compile-time conditional compilation for templates.",
    "code": "if (a > b) {\n    std::cout << \"a is greater\";\n} else {\n    std::cout << \"b is greater\";\n}"
  },
  {
    "title": "C++ Switch",
    "note": "The switch statement provides multi-way branching based on integral or enumeration values. case labels must be constant expressions. break prevents fall-through to subsequent cases; intentional fall-through should be documented. default handles unmatched values. C++17 added [[fallthrough]] attribute to document intentional fall-through. switch can declare variables in the condition (C++17). switch is more efficient than multiple if-else statements for integral comparisons.",
    "code": "switch(choice) {\n    case 1: //...\n    break;\n    default: //...\n}"
  },
  {
    "title": "C++ While Loop",
    "note": "while loops execute a statement or block while a condition remains true. The condition is evaluated before each iteration. do-while loops evaluate the condition after the loop body, ensuring at least one execution. while loops are ideal when the number of iterations is unknown beforehand. Proper loop design requires initializing loop variables, updating them within the loop, and ensuring the condition eventually becomes false to prevent infinite loops.",
    "code": "while(count < 10) {\n    count++;\n}"
  },
  {
    "title": "C++ For Loop",
    "note": "C++ for loops provide compact iteration syntax with initialization, condition, and increment expressions. C++11 added range-based for loops for iterating over containers and arrays. for loops are ideal when the number of iterations is known in advance. The loop variable can be declared in the initialization expression, limiting its scope to the loop. Empty expressions are allowed in any part of the for loop header.",
    "code": "for(int i = 0; i < 5; i++) {\n    std::cout << i << std::endl;\n}"
  },
  {
    "title": "C++ Break/Continue",
    "note": "break exits the innermost loop or switch statement. continue skips the remaining code in the current iteration and proceeds to the next iteration. Both statements alter normal loop flow and are typically used with conditional logic. break is useful for early termination when a condition is met. continue is useful for skipping certain elements in processing. In nested loops, these statements only affect the innermost loop.",
    "code": "for(int i=0; i<10; i++) {\n  if(i == 5) break;\n  if(i % 2 == 0) continue;\n}"
  },
  {
    "title": "C++ Arrays",
    "note": "C++ supports C-style arrays and provides std::array (C++11) as a safer alternative. C-style arrays are fixed-size, contiguous collections with zero-based indexing. Array size must be constant expressions. Arrays decay to pointers when passed to functions. std::array provides STL interface, bounds checking (with at()), and doesn't decay to pointers. For dynamic arrays, std::vector is preferred. Understanding array-pointer relationship and memory layout is important for low-level programming.",
    "code": "int arr[5] = {1, 2, 3, 4, 5};"
  },
  {
    "title": "C++ Structures",
    "note": "struct in C++ is similar to C but with additional features: members can have access specifiers (public, private, protected), can include member functions, constructors, destructors, and can participate in inheritance. struct members are public by default (unlike class). struct is typically used for passive data structures, while class is used for active objects with behavior. The distinction is mainly stylistic; technically they are almost identical.",
    "code": "struct Point {\n  int x;\n  int y;\n};"
  },
  {
    "title": "C++ Enums",
    "note": "C++ supports C-style enums and adds enum class (scoped enums) in C++11. C-style enums export their enumerators to the surrounding scope, while enum class keeps them scoped within the enum. enum class is strongly typed and doesn't implicitly convert to integers. Both can specify the underlying type. Enums are useful for representing fixed sets of named values, improving code readability and maintainability.",
    "code": "enum Color { RED, GREEN, BLUE };"
  },
  {
    "title": "C++ References",
    "note": "References are aliases for existing variables. They must be initialized when declared and cannot be rebound to refer to different variables. References are often used for function parameters to avoid copying and for return values. References are safer than pointers as they cannot be null and don't require dereferencing syntax. Understanding the difference between references and pointers, and when to use each, is important for effective C++ programming.",
    "code": "int a = 5;\nint& ref = a;"
  },
  {
    "title": "C++ Pointers",
    "note": "Pointers store memory addresses and are used for dynamic memory allocation, array manipulation, and implementing data structures. C++ pointers work like C pointers but with additional context from stronger type checking. Smart pointers (unique_ptr, shared_ptr, weak_ptr) introduced in C++11 automate memory management and help prevent leaks. Understanding pointer arithmetic, const correctness with pointers, and the relationship between pointers and arrays is crucial for low-level programming.",
    "code": "int* ptr = &a;"
  },
  {
    "title": "C++ Memory Management",
    "note": "C++ uses new and delete operators for dynamic memory allocation instead of malloc() and free(). new calls constructors, delete calls destructors. Arrays use new[] and delete[]. Manual memory management is error-prone; smart pointers and containers are preferred in modern C++. Understanding memory ownership, the rule of three/five/zero, and RAII (Resource Acquisition Is Initialization) is essential for correct memory management.",
    "code": "int* p = new int(10);\ndelete p;"
  },
  {
    "title": "C++ Functions",
    "note": "Functions are the basic building blocks of C++ programs. They can be overloaded (same name, different parameters), have default arguments, and can be inline (suggesting to compiler to insert code at call site). Functions can return references, pointers, or values. Function declarations (prototypes) allow separate compilation. Understanding function calling conventions, parameter passing (by value, reference, pointer), and return value optimization is important for performance and correctness.",
    "code": "int add(int x, int y) { return x + y; }"
  },
  {
    "title": "C++ Function Parameters",
    "note": "Function parameters can be passed by value (copy), by reference (avoid copy, can modify original), or by pointer (similar to reference but can be null). const references allow efficient passing without modification rights. C++ supports default arguments, variable templates (C++11), and parameter packs for variadic functions. Understanding parameter passing mechanisms is crucial for performance (avoiding unnecessary copies) and correctness (when modification is intended).",
    "code": "void greet(std::string name) { std::cout << \"Hello \" << name; }"
  },
  {
    "title": "C++ Function Overloading",
    "note": "Function overloading allows multiple functions with the same name but different parameter lists (different number, type, or order of parameters). The compiler determines which function to call based on the arguments provided. Overloading enables intuitive APIs for similar operations on different types. Overload resolution considers conversions and templates. Functions cannot be overloaded based solely on return type.",
    "code": "int add(int a, int b);\ndouble add(double a, double b);"
  },
  {
    "title": "C++ Scope",
    "note": "Scope defines where names are visible. C++ has block scope (variables declared inside {}), function scope (labels), class scope (members), namespace scope (global and named namespaces), and file scope (static members and functions). Names can be hidden by inner scopes. The scope resolution operator (::) accesses global and namespace scope. Understanding scope is crucial for name lookup, avoiding naming conflicts, and managing object lifetimes.",
    "code": "{ int x = 10; /* x is scoped here */ }"
  },
  {
    "title": "C++ Recursion",
    "note": "Recursive functions call themselves to solve problems by breaking them down into smaller subproblems. Each call creates a new stack frame. Recursive functions must have a base case to terminate recursion. Recursion is elegant for problems like tree traversals, mathematical sequences, and divide-and-conquer algorithms. However, recursion can cause stack overflow for deep recursion and may be less efficient than iterative solutions due to function call overhead.",
    "code": "int factorial(int n) { return (n <= 1) ? 1 : n * factorial(n-1); }"
  },
  {
    "title": "C++ Lambda",
    "note": "Lambda expressions (C++11) define anonymous function objects. They can capture variables from the surrounding scope by value or reference. Lambdas are useful for short functions passed as arguments to algorithms, event handlers, and concurrent programming. The syntax is: [capture](parameters) -> return_type { body }. Lambdas are implemented as function objects with operator() and are a cornerstone of modern C++ programming.",
    "code": "auto add = [](int a, int b) { return a + b; };"
  },
  {
    "title": "C++ Classes",
    "note": "Classes are the foundation of object-oriented programming in C++. They encapsulate data and behavior, providing abstraction, encapsulation, and information hiding. Classes can have members (data and functions), access specifiers (public, private, protected), constructors, destructors, and can participate in inheritance. Classes support operator overloading, allowing custom types to behave like built-in types. Understanding class design principles is essential for effective OOP in C++.",
    "code": "class Person {\n  public:\n    string name;\n    void greet() { std::cout << \"Hi \" << name; }\n};"
  },
  {
    "title": "C++ OOP",
    "note": "Object-Oriented Programming in C++ is based on four principles: encapsulation (bundling data and methods, controlling access), inheritance (creating new classes from existing ones), polymorphism (objects of different types responding to the same interface), and abstraction (hiding implementation details). C++ supports multiple inheritance, virtual functions for runtime polymorphism, and abstract classes. OOP helps manage complexity through modeling real-world entities and relationships.",
    "code": "// Example of inheritance\nclass Student : public Person { /*...*/ };"
  },
  {
    "title": "C++ Classes/Objects",
    "note": "Objects are instances of classes created in memory. They contain the data members and have access to member functions. Objects can be created on the stack (automatic storage) or heap (dynamic storage). Member access uses the dot operator (.) for objects and arrow operator (->) for pointers to objects. Understanding object lifetime, construction, destruction, and copying is crucial for correct resource management.",
    "code": "Person p;\np.name = \"Alice\";\np.greet();"
  },
  {
    "title": "C++ Class Methods",
    "note": "Class methods (member functions) operate on class objects. They have access to all class members (including private ones). Methods can be const (promising not to modify the object), static (associated with the class rather than instances), or virtual (supporting polymorphism). Methods can be defined inside the class (inline) or outside using the scope resolution operator. Understanding method signatures, overloading, and special member functions is key to class design.",
    "code": "void setName(std::string n) { name = n; }"
  },
  {
    "title": "C++ Constructors",
    "note": "Constructors are special member functions that initialize objects. They have the same name as the class and no return type. Constructors can be overloaded, have default arguments, and can be explicit (preventing implicit conversions). Initialization lists initialize members before the constructor body runs. Copy constructors and move constructors (C++11) handle object copying and moving. Understanding constructor delegation, conversion constructors, and the rule of three/five/zero is essential for correct object initialization.",
    "code": "Person(std::string n) { name = n; }"
  },
  {
    "title": "C++ Access Specifiers",
    "note": "Access specifiers control the visibility of class members: public (accessible anywhere), private (accessible only within the class), and protected (accessible within the class and derived classes). Access specifiers can appear multiple times in a class definition. The default access for class is private, for struct is public. Proper use of access specifiers is crucial for encapsulation and maintaining class invariants.",
    "code": "private:\n int age;"
  },
  {
    "title": "C++ Encapsulation",
    "note": "Encapsulation is the bundling of data and methods that operate on that data, and restricting direct access to some components. It is achieved through access specifiers (private, protected) and providing public interfaces (getters, setters, member functions). Encapsulation helps maintain class invariants, reduces coupling, and makes code more maintainable. It is a fundamental principle of object-oriented design.",
    "code": "class Person {\nprivate:\n string name;\npublic:\n void setName(string n) { name = n; }\n};"
  },
  {
    "title": "C++ Friend Functions",
    "note": "Friend functions are non-member functions that have access to the private and protected members of a class. Friendship is granted by the class, not taken by the function. Friend functions are useful for operators that need access to private data but shouldn't be member functions, and for providing specific external functions with special access. Friendship breaks encapsulation and should be used sparingly.",
    "code": "friend void showName(Person& p);"
  },
  {
    "title": "C++ Inheritance",
    "note": "Inheritance allows a class (derived) to inherit members from another class (base). C++ supports public, protected, and private inheritance, controlling the accessibility of inherited members. Multiple inheritance allows a class to have multiple base classes. Virtual inheritance solves the diamond problem. Understanding inheritance hierarchies, overriding, and the Liskov Substitution Principle is important for effective use of inheritance.",
    "code": "class Student : public Person { /*...*/ };"
  },
  {
    "title": "C++ Polymorphism",
    "note": "Polymorphism allows objects of different types to be treated through a common interface. Runtime polymorphism is achieved through virtual functions and pointers/references to base classes. Compile-time polymorphism is achieved through templates and function overloading. Virtual functions allow derived classes to override base class behavior. Pure virtual functions create abstract classes that cannot be instantiated. Polymorphism is key to writing flexible, extensible code.",
    "code": "virtual void speak() { std::cout << \"Hello\"; }"
  },
  {
    "title": "C++ Templates",
    "note": "Templates enable generic programming by allowing functions and classes to operate with generic types. Function templates generate functions for specific types when instantiated. Class templates generate classes. Templates support specialization for specific types. C++11 added variadic templates for functions taking arbitrary numbers of arguments. Templates are powerful but can lead to complex error messages and code bloat. They are the foundation of the STL.",
    "code": "template <typename T>\nT max(T a, T b) { return (a > b) ? a : b; }"
  },
  {
    "title": "C++ Files",
    "note": "File I/O in C++ uses the fstream library (ifstream for input, ofstream for output, fstream for both). Files are opened by constructing stream objects with filename and mode. I/O operations use the same operators as console I/O (<< for output, >> for input). Files should be closed explicitly or will be closed when the stream object is destroyed. Error checking should be performed after operations. File I/O is essential for data persistence and configuration.",
    "code": "#include <fstream>\nstd::ofstream file(\"data.txt\");\nfile << \"Hello C++!\";\nfile.close();"
  },
  {
    "title": "C++ Date",
    "note": "C++ provides date and time functionality through <ctime> (C compatibility) and <chrono> (C++11, modern time library). <ctime> provides time_t, tm structure, and functions like time(), localtime(), strftime(). <chrono> provides type-safe time points, durations, and clocks with various resolutions. The modern library avoids many pitfalls of the C time API and is preferred for new code. Understanding time representation and time zones is important for correct date/time handling.",
    "code": "#include <ctime>\ntime_t now = time(0);\nstd::cout << ctime(&now);"
  },
  {
    "title": "C++ Errors",
    "note": "C++ error handling uses exceptions for exceptional conditions and return codes for expected errors. The exception mechanism involves try blocks (code that might throw), catch blocks (handle specific exceptions), and throw statements (raise exceptions). The standard exception hierarchy (std::exception and derived classes) provides common exception types. Exception safety guarantees (basic, strong, no-throw) are important for robust code. Alternatives like std::optional (C++17) and expected (proposed) provide other error handling approaches.",
    "code": "try {\n // code\n} catch (std::exception& e) {\n std::cout << e.what();\n}"
  },
  {
    "title": "C++ Debugging",
    "note": "Debugging C++ involves identifying and fixing bugs using tools like GDB, IDE debuggers, static analyzers, and sanitizers (AddressSanitizer, UndefinedBehaviorSanitizer). Debug builds should include symbols (-g flag). Common techniques include: breakpoints, stepping through code, examining variables and memory, watchpoints, and core dump analysis. Understanding common C++ pitfalls (dangling references, memory leaks, undefined behavior) helps in effective debugging.",
    "code": "// Compile with -g flag and run gdb ./program"
  },
  {
    "title": "C++ Exceptions",
    "note": "Exceptions provide a mechanism for handling errors and exceptional conditions without cluttering normal code flow. Exceptions are thrown with throw and caught with catch. The exception hierarchy is rooted at std::exception. Exception specifications (noexcept) indicate whether functions can throw. Exception safety (basic, strong, no-throw guarantee) is important for resource management. Exceptions should be used for exceptional conditions, not for normal control flow.",
    "code": "throw std::runtime_error(\"Error occurred\");"
  },
  {
    "title": "C++ Input Validation",
    "note": "Input validation ensures that program input meets expected criteria before processing. This includes checking stream state after input operations, validating ranges and formats, and handling invalid input gracefully. Techniques include: checking fail() and eof() flags, using getline() for line-oriented input, parsing strings, and providing user feedback. Input validation prevents crashes, security vulnerabilities, and incorrect program behavior.",
    "code": "if(std::cin.fail()) { std::cin.clear(); std::cin.ignore(); }"
  },
  {
    "title": "C++ Data Structures & STL",
    "note": "The Standard Template Library (STL) provides containers (vector, list, map, set, etc.), algorithms (sort, find, transform, etc.), and iterators. Containers manage memory automatically and provide various guarantees and performance characteristics. Algorithms operate on ranges through iterators. The STL is generic, efficient, and extensively tested. Understanding container choices, iterator categories, and algorithm complexity is essential for effective use of the STL.",
    "code": "#include <vector>\nstd::vector<int> nums = {1, 2, 3};"
  },
  [
  {
    "title": "C++ Vectors",
    "note": "std::vector is a dynamic array container that provides automatic memory management, random access, and dynamic resizing. It stores elements contiguously in memory, providing excellent cache performance. Vectors support efficient insertion and deletion at the end (amortized constant time) but linear time for operations at the beginning or middle. Key operations include push_back(), pop_back(), insert(), erase(), and access via operator[] or at() (with bounds checking). Vectors manage their own memory, growing by a factor (usually 2x) when capacity is exceeded. They are the most commonly used container in C++ due to their flexibility and performance characteristics.",
    "code": "std::vector<int> v;\nv.push_back(10);"
  },
  {
    "title": "C++ List",
    "note": "std::list is a doubly-linked list container that provides efficient insertion and deletion at any position in constant time. Unlike vectors, lists do not provide random access (no operator[]), but support bidirectional iteration. Lists are implemented as node-based containers, with each element containing pointers to previous and next elements. This structure allows efficient splicing of elements between lists. Lists are useful when frequent insertions and deletions occur in the middle of the sequence, but have higher memory overhead per element due to pointer storage and poorer cache performance compared to vectors.",
    "code": "#include <list>\nstd::list<int> l;"
  },
  {
    "title": "C++ Stacks",
    "note": "std::stack is a container adapter that provides a LIFO (Last-In, First-Out) data structure. It is not a container itself but wraps an underlying container (default std::deque) and provides a restricted interface. Stack operations include push() (add element), pop() (remove top element), top() (access top element), and empty()/size() checks. stacks are useful for algorithms requiring LIFO order, such as depth-first search, expression evaluation, and undo functionality. The underlying container can be specified as a template parameter to use vector or list instead of deque.",
    "code": "#include <stack>\nstd::stack<int> s;"
  },
  {
    "title": "C++ Queues",
    "note": "std::queue is a container adapter that provides a FIFO (First-In, First-Out) data structure. It wraps an underlying container (default std::deque) and provides operations for enqueue (push()), dequeue (pop()), front access (front()), and back access (back()). Queues are essential for breadth-first search, task scheduling, buffering, and any scenario requiring processing in arrival order. Like stack, the underlying container can be customized. std::priority_queue is a variant that orders elements by priority rather than insertion order.",
    "code": "#include <queue>\nstd::queue<int> q;"
  },
  {
    "title": "C++ Deque",
    "note": "std::deque (double-ended queue) is a sequence container that supports efficient insertion and deletion at both ends. It provides random access like vector but with better performance for operations at the beginning. Deques are typically implemented as multiple fixed-size arrays, allowing growth in both directions without requiring reallocation of all elements. This structure provides constant time push_front() and push_back() operations. Deques have higher memory overhead than vectors but are more suitable for scenarios requiring frequent operations at both ends of the sequence.",
    "code": "#include <deque>\nstd::deque<int> d;"
  },
  {
    "title": "C++ Sets",
    "note": "std::set is an associative container that stores unique elements in sorted order. It is typically implemented as a balanced binary search tree (red-black tree), providing logarithmic time complexity for insertion, deletion, and search operations. Sets are useful for maintaining a sorted collection of unique items and for efficient membership testing. Elements are immutable once inserted (though they can be removed and reinserted). std::multiset allows duplicate elements. Sets support bidirectional iteration and various set operations like union, intersection, and difference.",
    "code": "#include <set>\nstd::set<int> s;"
  },
  {
    "title": "C++ Maps",
    "note": "std::map is an associative container that stores key-value pairs with unique keys, sorted by key. Like set, it is typically implemented as a balanced binary search tree, providing logarithmic time operations. Maps are useful for dictionaries, caches, and any scenario requiring efficient lookup by key. Elements are std::pair<const Key, Value> and are stored in sorted order. std::multimap allows duplicate keys. Maps support bidirectional iteration and various lookup operations (find(), lower_bound(), upper_bound()). C++17 added extract() and merge() operations for efficient node handling.",
    "code": "#include <map>\nstd::map<int, std::string> m;"
  },
  {
    "title": "C++ Iterators",
    "note": "Iterators are objects that provide a way to access elements in containers sequentially. They abstract the underlying container implementation, providing a uniform interface for traversal. Iterator categories include: input (read-only forward), output (write-only forward), forward (read/write forward), bidirectional (forward and backward), and random access (direct access to any element). Iterators are used with algorithms and range-based for loops. Iterator invalidation rules are crucial - some operations on containers may invalidate iterators, making them unsafe to use afterward.",
    "code": "for(auto it = v.begin(); it != v.end(); ++it) {\n    std::cout << *it << std::endl;\n}"
  },
  {
    "title": "C++ Algorithms",
    "note": "The <algorithm> header provides numerous generic algorithms that operate on ranges of elements through iterators. These include: non-modifying operations (find, count, equal), modifying operations (copy, transform, replace), sorting and related operations (sort, stable_sort, partial_sort), and numeric operations (accumulate, inner_product). Algorithms are generic and work with any container providing appropriate iterators. They often accept function objects (including lambdas) for customization. Understanding algorithm complexity and iterator requirements is essential for effective use.",
    "code": "#include <algorithm>\nsort(v.begin(), v.end());"
  },
  {
    "title": "C++ Namespaces",
    "note": "Namespaces are used to organize code into logical groups and prevent name collisions. The std namespace contains all standard library components. User-defined namespaces can nest and can be extended across multiple files. The using directive (using namespace) brings all names from a namespace into scope, while using declaration (using std::cout) brings specific names. Anonymous namespaces provide internal linkage within a translation unit. Namespaces are essential for large projects, library development, and avoiding conflicts with third-party code.",
    "code": "namespace MyNamespace {\n    void func() {}\n}"
  },
  {
    "title": "C++ Projects",
    "note": "C++ projects typically involve multiple source files, headers, and build configuration. Common project structures separate interface (.h/.hpp) from implementation (.cpp), with modules organized by functionality. Build systems like CMake, Make, or IDE projects manage compilation, dependencies, and linking. Large projects may use libraries (static or dynamic), generated code, and conditional compilation. Understanding separate compilation, header guards, and the one-definition rule is crucial for multi-file projects. Version control, testing, and documentation are important aspects of project maintenance.",
    "code": "// Organize code into files, classes, and modules"
  },
  {
    "title": "C++ Add Two Numbers",
    "note": "This simple example demonstrates basic C++ syntax, variable declaration, and output. It shows how to declare variables of fundamental types, perform arithmetic operations, and use the standard output stream. While trivial, this pattern is the foundation for more complex programs. The example can be extended to handle user input, different data types, error checking, and function encapsulation. Understanding basic operations like this is essential before progressing to more advanced C++ features.",
    "code": "int a = 5, b = 3;\nstd::cout << (a + b);"
  },
  {
    "title": "C++ Random Numbers",
    "note": "The <random> header (C++11) provides a modern, flexible framework for random number generation. It separates random number engines (generators) from distributions. std::random_device provides non-deterministic random numbers from hardware if available. std::mt19937 is a popular Mersenne Twister engine. Distributions like uniform_int_distribution shape the output range. This approach is superior to rand() as it provides better randomness, more control over distribution, and thread safety. Proper random number generation is important for simulations, games, cryptography, and randomized algorithms.",
    "code": "#include <random>\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dist(1, 100);\nint randomNum = dist(gen);"
  },
  {
    "title": "C++ Reference",
    "note": "C++ reference materials include the ISO C++ standard, cppreference.com (comprehensive online reference), and documentation for specific compilers and libraries. The C++ standard defines the language syntax, standard library components, and behavior. Reference materials are essential for understanding language features, library APIs, and subtle aspects of the language. Regular consultation with reference materials helps write correct, portable, and efficient code. The evolving nature of C++ (with new standards every 3 years) makes ongoing reference consultation important for staying current.",
    "code": "// Refer to cppreference.com or official docs"
  },
  {
    "title": "C++ Keywords",
    "note": "C++ has numerous keywords that have special meaning: basic types (int, char, bool), control flow (if, else, switch, case, default, for, while, do, break, continue, goto), functions (return, void), classes (class, struct, union, enum, public, private, protected, friend, virtual, override, final), templates (template, typename), memory (new, delete, sizeof), and others (auto, const, mutable, static, extern, volatile, using, namespace, typedef, typeid, dynamic_cast, static_cast, reinterpret_cast, const_cast, noexcept, nullptr, decltype). C++11/14/17/20 added additional keywords.",
    "code": "// Examples: int, class, virtual, template"
  },
  {
    "title": "C++ <iostream>",
    "note": "The <iostream> header defines the standard input/output stream objects: std::cin (standard input), std::cout (standard output), std::cerr (standard error unbuffered), std::clog (standard error buffered). It provides the basic framework for console I/O using the insertion (<<) and extraction (>>) operators. <iostream> also includes manipulators like std::endl and std::flush. The streams are synchronized with C stdio by default, which can impact performance. Understanding stream states, error handling, and formatting is essential for robust I/O operations.",
    "code": "#include <iostream>"
  },
  {
    "title": "C++ <fstream>",
    "note": "The <fstream> header provides file stream classes: std::ifstream (input file stream), std::ofstream (output file stream), and std::fstream (combined input/output). These classes inherit from the iostream hierarchy and provide file-specific operations like open(), close(), and file mode control. File streams support both text and binary modes. Understanding file modes (in, out, app, binary, etc.), file positioning, and error handling is crucial for reliable file operations. File streams automatically manage file opening and closing through RAII.",
    "code": "#include <fstream>"
  },
  {
    "title": "C++ <cmath>",
    "note": "The <cmath> header provides mathematical functions, including: trigonometric (sin, cos, tan, asin, acos, atan), hyperbolic (sinh, cosh, tanh), exponential and logarithmic (exp, log, log10), power (pow, sqrt), rounding and remainder (ceil, floor, fmod, trunc, round), and special functions (erf, gamma). Most functions have overloads for float, double, and long double. <cmath> functions are more type-safe than their C counterparts and may provide better performance through compiler intrinsics. Error handling is through errno and special floating-point values.",
    "code": "#include <cmath>"
  },
  {
    "title": "C++ <string>",
    "note": "The <string> header defines the std::string and std::wstring classes for manipulating sequences of characters. std::string provides extensive functionality: construction and destruction, assignment, access ([], at(), front(), back()), capacity (size(), empty(), reserve()), modifications (append(), insert(), erase(), replace()), string operations (substr(), compare(), find()), and support for string literals. Strings manage their own memory and grow as needed. Understanding string operations, iterator invalidation, and the small string optimization is important for efficient string handling.",
    "code": "#include <string>"
  },
  {
    "title": "C++ <cstring>",
    "note": "The <cstring> header provides C-style string functions from the C standard library, including: copying (strcpy, strncpy), concatenation (strcat, strncat), comparison (strcmp, strncmp), searching (strchr, strstr, strtok), and length (strlen). These functions operate on null-terminated character arrays and require careful use to avoid buffer overflows. While std::string is generally preferred, <cstring> functions are still needed for interoperability with C code, low-level string manipulation, and performance-critical sections where the overhead of std::string is unacceptable.",
    "code": "#include <cstring>"
  },
  {
    "title": "C++ <ctime>",
    "note": "The <ctime> header provides C-style date and time functions, including: time() (current calendar time), clock() (processor time used), difftime() (difference between two times), and functions for converting between time_t and tm structures (gmtime(), localtime(), mktime()). It also provides formatting functions (asctime(), ctime(), strftime()). While <chrono> (C++11) provides a more modern time library, <ctime> is still widely used for its simplicity and compatibility with C code. Understanding time representation and time zones is important for correct time handling.",
    "code": "#include <ctime>"
  },
  {
    "title": "C++ <vector>",
    "note": "The <vector> header defines the std::vector container, a dynamic array that provides automatic memory management and efficient random access. vector is one of the most commonly used containers due to its balance of performance and flexibility. Key features include: automatic resizing, contiguous storage (good cache performance), range checking with at(), and various constructors for initialization. Understanding vector's growth strategy, iterator invalidation rules, and when to use reserve() is important for efficient use. vector is the default choice for most sequence storage needs.",
    "code": "#include <vector>"
  },
  {
    "title": "C++ <algorithm>",
    "note": "The <algorithm> header contains a rich collection of generic algorithms that operate on ranges of elements. These include: non-modifying sequence operations (find, count, for_each), modifying sequence operations (copy, transform, fill), sorting and related operations (sort, stable_sort, nth_element), binary search (lower_bound, upper_bound, binary_search), and heap operations (make_heap, push_heap). Algorithms are template functions that work with iterators, making them container-agnostic. They often accept predicates or function objects for customization. Mastering the algorithms library is key to writing efficient, expressive C++ code.",
    "code": "#include <algorithm>"
  },
  {
    "title": "C++ Examples",
    "note": "C++ examples range from simple 'Hello World' programs to complex applications demonstrating advanced features. Common example categories include: basic syntax and control structures, function usage, class design and OOP, template programming, STL container and algorithm usage, file I/O, and concurrency. Examples help learners understand how language features work in practice and serve as templates for solving similar problems. Well-commented examples that demonstrate both usage and potential pitfalls are particularly valuable for learning.",
    "code": "// Examples to practice various concepts"
  },
  {
    "title": "C++ Real-Life Examples",
    "note": "Real-life C++ examples demonstrate practical applications in various domains: game development (game engines, physics simulation), systems programming (operating systems, device drivers), scientific computing (numerical analysis, simulations), financial systems (high-frequency trading, risk analysis), and embedded systems (IoT devices, automotive systems). These examples often involve complex architecture, performance optimization, integration with other languages and systems, and robust error handling. Studying real-life examples provides insight into professional C++ development practices and patterns.",
    "code": "// Examples like games, GUI apps, and more"
  },
  {
    "title": "C++ Compiler",
    "note": "C++ compilers translate source code into executable machine code. Popular compilers include GCC (GNU Compiler Collection), Clang, MSVC (Microsoft Visual C++), and ICC (Intel C++ Compiler). Compilers support various C++ standards (C++98, C++11, C++14, C++17, C++20) through flags like -std=c++17. Compilation involves preprocessing, compilation proper, optimization, assembly, and linking. Understanding compiler options, warnings, and error messages is essential for effective development. Modern compilers provide extensive optimization capabilities and static analysis features.",
    "code": "// g++ main.cpp -o main"
  },
  {
    "title": "C++ Exercises",
    "note": "C++ programming exercises help develop practical skills through problem-solving. Exercises range from basic syntax practice to advanced challenges involving templates, concurrency, and system programming. Common exercise categories include: algorithm implementation, data structure creation, memory management challenges, template metaprogramming puzzles, and STL usage problems. Platforms like LeetCode, HackerRank, and Codewars provide graded exercises with automated testing. Regular practice with diverse exercises builds problem-solving ability and deepens understanding of C++ concepts and idioms.",
    "code": "// Solve coding challenges"
  },
  {
    "title": "C++ Quiz",
    "note": "C++ quizzes test knowledge through multiple-choice questions, code interpretation problems, and debugging exercises. Topics include: language syntax and semantics, memory management, OOP concepts, template programming, STL usage, and modern C++ features. Quizzes help identify knowledge gaps, prepare for interviews, and reinforce learning through immediate feedback. Many online learning platforms, textbooks, and certification programs include quizzes with explanations to clarify tricky concepts and common misunderstandings in C++ programming.",
    "code": "// Multiple choice or coding quizzes"
  },
  {
    "title": "C++ Syllabus",
    "note": "A comprehensive C++ syllabus covers: C++ fundamentals (syntax, types, operators), functions and scope, classes and object-oriented programming, templates and generic programming, STL containers and algorithms, memory management, exception handling, and modern C++ features (C++11/14/17/20). The syllabus should progress from basic concepts to advanced topics, with practical programming assignments at each stage. A well-structured syllabus includes learning objectives, recommended resources, assessment methods, and timeline for completion. It serves as a roadmap for systematic C++ learning.",
    "code": "// Organized topics and lessons"
  },
  {
    "title": "C++ Study Plan",
    "note": "An effective C++ study plan typically spans 3-6 months for comprehensive coverage. Week 1-4: Fundamentals (syntax, functions, basic OOP). Week 5-8: Intermediate topics (templates, STL, memory management). Week 9-12: Advanced concepts (concurrency, modern C++ features, patterns). Week 13+: Project work and specialization. Daily study should include 2-3 hours of theoretical learning and 3-4 hours of hands-on coding. The plan should be adaptable based on progress and include regular review sessions. Consistency and practical application are key to mastery.",
    "code": "// Weekly or daily learning goals"
  },
  {
    "title": "C++ Certificate",
    "note": "C++ certifications validate professional competency and are offered by organizations like the C++ Institute (CPA, CPP, CPE certifications) and Microsoft (VC++ certification). These certifications typically involve exams testing knowledge of C++ syntax, OOP concepts, templates, STL, memory management, and modern features. Preparation requires months of study using official guides, practice tests, and extensive hands-on coding. Certifications can enhance job prospects, especially in industries requiring demonstrated C++ expertise like gaming, finance, and embedded systems. They provide structured learning paths and industry recognition.",
    "code": "// Information on exams and credentials"
  }
]
],
Csyarph: [
  {
    "title": "C# Intro",
    "note": "C# (pronounced 'C Sharp') is a modern, object-oriented programming language developed by Microsoft as part of its .NET initiative. Designed by Anders Hejlsberg, C# combines the power of C++ with the simplicity of Visual Basic. It features strong typing, automatic garbage collection, and support for component-oriented programming. C# is widely used for developing Windows applications, web services (ASP.NET), games (Unity), mobile apps (Xamarin), and enterprise software. The language continues to evolve with regular updates that add features like pattern matching, records, and enhanced async support.",
    "code": "using System;\nclass Program {\n    static void Main() {\n        Console.WriteLine(\"Hello, C#!\");\n    }\n}"
  },
  {
    "title": "C# Get Started",
    "note": "To start with C#, you need the .NET SDK installed on your system. You can use Visual Studio (Windows/Mac), Visual Studio Code with C# extension, or any text editor with the .NET CLI. The basic workflow involves creating a project (dotnet new console), writing code in .cs files, building (dotnet build), and running (dotnet run). The .NET ecosystem provides extensive libraries, tools, and frameworks for various application types. Understanding the project structure (csproj files), dependencies, and build process is essential for C# development.",
    "code": "// Create Program.cs, then use: dotnet run"
  },
  {
    "title": "C# Syntax",
    "note": "C# syntax is similar to other C-style languages but with additional features and improvements. It uses curly braces {} to define code blocks, semicolons to terminate statements, and follows a structured approach. Key syntax elements include: namespaces for organization, classes as blueprints for objects, methods containing executable code, and various statements (declaration, assignment, control flow). C# is case-sensitive and uses PascalCase for type names and camelCase for variables. The syntax is designed to be readable and expressive while maintaining consistency.",
    "code": "if (5 > 3) {\n    Console.WriteLine(\"Five is greater than three.\");\n}"
  },
  {
    "title": "C# Output",
    "note": "C# uses the Console class from the System namespace for basic console output. Console.WriteLine() outputs text followed by a newline, while Console.Write() outputs without a newline. Both methods support string formatting using composite formatting ({0}, {1}) or string interpolation ($ prefix). The Console class also provides methods for controlling cursor position, colors, and window properties. For more advanced output, C# can use various GUI frameworks or web output methods depending on the application type.",
    "code": "Console.WriteLine(\"Hello World!\");"
  },
  {
    "title": "C# Comments",
    "note": "C# supports three types of comments: single-line comments starting with //, multi-line comments enclosed in /* */, and XML documentation comments starting with ///. XML comments generate documentation and provide IntelliSense in IDEs. Comments are essential for code documentation, explaining complex logic, and temporarily disabling code. Best practices include writing meaningful comments that explain why rather than what, keeping comments updated with code changes, and using XML comments for public APIs to generate documentation automatically.",
    "code": "// This is a comment\n/* This is a\n   multi-line comment */"
  },
  {
    "title": "C# Variables",
    "note": "Variables in C# are strongly typed and must be declared before use. Declaration specifies the type and name: type variableName;. Variables can be initialized at declaration: type variableName = value;. C# supports type inference with the var keyword, where the compiler determines the type from the initialization expression. Variables have scope (where they are accessible) and lifetime (how long they exist). Understanding value types vs reference types, and the stack vs heap memory allocation is crucial for effective variable usage.",
    "code": "int age = 25;\nstring name = \"Alice\";"
  },
  {
    "title": "C# Data Types",
    "note": "C# has two main categories of data types: value types and reference types. Value types include built-in types (int, double, bool, char, decimal), enums, and structs. They store data directly and are allocated on the stack. Reference types (class, interface, delegate, array, string) store references to data allocated on the heap. C# also has pointer types for unsafe code. Each type has a default value (0 for numbers, false for bool, null for reference types). Understanding type characteristics is essential for memory management and performance.",
    "code": "double price = 19.99;\nbool isAvailable = true;"
  },
  {
    "title": "C# Type Casting",
    "note": "Type casting converts a value from one type to another. Implicit casting happens automatically when converting to a larger type (int to long). Explicit casting requires parentheses and may cause data loss (double to int). C# provides several casting methods: (type) operator for basic casts, as operator for safe reference type conversion (returns null if fails), is operator for type checking, and Convert class methods for various conversions. Understanding casting rules and potential exceptions is important for robust type handling.",
    "code": "int x = (int) 9.8;  // explicit cast"
  },
  {
    "title": "C# User Input",
    "note": "Reading user input is primarily done through Console.ReadLine() which returns a string. For different data types, the input string must be parsed using methods like int.Parse(), double.Parse(), or the safer TryParse() methods that avoid exceptions. Input validation is crucial to handle invalid user entries gracefully. The Console class also provides Read() for single character input and ReadKey() for reading key presses without waiting for Enter. Proper input handling includes clearing input buffers and providing user-friendly prompts.",
    "code": "string input = Console.ReadLine();"
  },
  {
    "title": "C# Operators",
    "note": "C# provides a comprehensive set of operators: arithmetic (+, -, *, /, %), relational (==, !=, <, >, <=, >=), logical (&&, ||, !), bitwise (&, |, ^, ~, <<, >>), assignment (=, +=, -=, etc.), conditional (?:), null-coalescing (??), and more. Operators have precedence that determines evaluation order. C# allows operator overloading for custom types. Understanding operator behavior, especially with null values (null-conditional operator ?.) and with different data types, is essential for writing correct expressions.",
    "code": "int sum = 5 + 3;\nbool isEqual = (a == b);"
  },
  {
    "title": "C# Math",
    "note": "The Math class in System namespace provides constants (PI, E) and static methods for mathematical operations: basic (Abs, Sign, Max, Min), exponential (Pow, Exp, Log, Log10), trigonometric (Sin, Cos, Tan, Asin, Acos, Atan), rounding (Round, Ceiling, Floor, Truncate), and other functions (Sqrt, DivRem). Math methods work with double precision; for decimal precision, use decimal type with its own methods. For complex mathematics, the System.Numerics namespace provides types like Complex and BigInteger.",
    "code": "double root = Math.Sqrt(16);"
  },
  {
    "title": "C# Strings",
    "note": "Strings in C# are immutable sequences of characters represented by the string type (alias for System.String). Strings support various operations: length (Length property), concatenation (+ operator or Concat method), comparison (Compare, Equals), searching (Contains, IndexOf, LastIndexOf), manipulation (Substring, Replace, Remove, Insert), and formatting (Format, ToLower, ToUpper). String interpolation ($) provides convenient inline formatting. For mutable strings, use StringBuilder. Understanding string immutability and performance implications is important for efficient string handling.",
    "code": "string greeting = \"Hello\";\nint length = greeting.Length;"
  },
  {
    "title": "C# Booleans",
    "note": "The bool type represents Boolean values true and false. Boolean values are results of comparison and logical operations. C# uses short-circuit evaluation in logical operators (&&, ||) where the right operand is evaluated only if needed. Boolean expressions are used in control statements (if, while, for) and conditional operators. Unlike some languages, C# doesn't allow implicit conversion between bool and other types; explicit comparison is required. Understanding truth tables and operator precedence is essential for correct Boolean logic.",
    "code": "bool isReady = true;"
  },
  {
    "title": "C# If...Else",
    "note": "The if statement executes code conditionally based on Boolean expressions. if evaluates a condition and executes the following block if true. else provides alternative execution when the condition is false. else if allows multiple conditions to be checked in sequence. Conditions can be any Boolean expression. Curly braces are required for multi-statement blocks but optional for single statements (though recommended for clarity). Proper indentation and formatting make if-else structures readable. if statements are fundamental for decision-making in programs.",
    "code": "if (age >= 18) {\n    Console.WriteLine(\"Adult\");\n} else {\n    Console.WriteLine(\"Minor\");\n}"
  },
  {
    "title": "C# Switch",
    "note": "The switch statement provides multi-way branching based on a pattern match. Traditional switch works with integral types, strings, and enums. C# 7.0+ enhanced switch with pattern matching, allowing type patterns, when clauses for additional conditions, and discard patterns. switch expressions (C# 8.0) provide a more concise syntax. Each case must end with break (or other jump statement) unless it's an empty case. default handles unmatched values. switch is cleaner than multiple if-else statements for multiple constant comparisons.",
    "code": "switch(day) {\n    case 1:\n        Console.WriteLine(\"Monday\");\n        break;\n    default:\n        Console.WriteLine(\"Other day\");\n        break;\n}"
  },
  {
    "title": "C# While Loop",
    "note": "The while loop repeats a statement or block while a condition remains true. The condition is evaluated before each iteration; if false initially, the loop body never executes. while loops are ideal when the number of iterations is unknown beforehand but depends on a changing condition. Proper loop design requires initializing loop variables, updating them within the loop, and ensuring the condition eventually becomes false to prevent infinite loops. do-while loops evaluate the condition after the loop body, ensuring at least one execution.",
    "code": "int i = 0;\nwhile (i < 5) {\n    Console.WriteLine(i);\n    i++;\n}"
  },
  {
    "title": "C# For Loop",
    "note": "The for loop provides compact syntax for iteration with initialization, condition, and increment expressions. It's ideal when the number of iterations is known in advance. The initialization executes once, the condition is checked before each iteration, and the increment executes after each iteration. Any of the three expressions can be omitted. for loops are commonly used for array traversal, counting, and fixed-number iterations. The loop variable is typically declared within the for statement, limiting its scope to the loop.",
    "code": "for (int i = 0; i < 5; i++) {\n    Console.WriteLine(i);\n}"
  },
  {
    "title": "C# Break/Continue",
    "note": "break exits the innermost loop or switch statement immediately. continue skips the remaining code in the current iteration and proceeds to the next iteration. Both statements alter normal loop flow and are typically used with conditional logic. break is useful for early termination when a condition is met or an error occurs. continue is useful for skipping certain elements in processing. These statements should be used judiciously to maintain code clarity. In nested loops, they only affect the innermost loop.",
    "code": "for (int i = 0; i < 10; i++) {\n    if (i == 5) break;\n    if (i % 2 == 0) continue;\n    Console.WriteLine(i);\n}"
  },
  {
    "title": "C# Arrays",
    "note": "Arrays are fixed-size collections of elements of the same type. Arrays can be single-dimensional, multidimensional, or jagged (arrays of arrays). Arrays are zero-indexed and declared with square brackets. Array initialization can be done with explicit size or with initial values. Arrays implement IEnumerable, so they can be used with foreach loops. The Array class provides methods for sorting, searching, and other operations. For dynamic collections, List<T> is generally preferred over arrays. Understanding array bounds and memory layout is important for performance.",
    "code": "int[] numbers = {1, 2, 3, 4};"
  },
  {
    "title": "C# Methods",
    "note": "Methods are blocks of code that perform specific tasks and can be called by name. Methods can have parameters, return values, and can be overloaded. Method signatures include the name, parameter types, and return type. Methods can be instance methods (called on objects) or static methods (called on the class). Methods support optional parameters, parameter arrays (params), and named arguments. Understanding method design principles (single responsibility, appropriate parameter count) is important for creating maintainable code.",
    "code": "public int Add(int a, int b) {\n    return a + b;\n}"
  },
  {
    "title": "C# Method Parameters",
    "note": "Method parameters allow data to be passed into methods. Parameters can be passed by value (default), by reference (ref keyword), as output parameters (out), or as parameter arrays (params). Value parameters receive copies of the arguments, while ref and out parameters work with the original variables. out parameters must be assigned before the method returns. Understanding parameter passing mechanisms is crucial for methods that need to modify arguments or return multiple values.",
    "code": "void Greet(string name) {\n    Console.WriteLine(\"Hello, \" + name);\n}"
  },
  {
    "title": "C# Method Overloading",
    "note": "Method overloading allows multiple methods with the same name but different parameter lists (different number, type, or order of parameters). The compiler determines which method to call based on the arguments provided. Overloading enables intuitive APIs for similar operations on different types. Overload resolution considers implicit conversions and optional parameters. Methods cannot be overloaded based solely on return type. Overloading is different from overriding, which is related to inheritance and polymorphism.",
    "code": "int Add(int a, int b) { return a + b; }\ndouble Add(double a, double b) { return a + b; }"
  },
  {
    "title": "C# Classes",
    "note": "Classes are blueprints for creating objects. They encapsulate data (fields) and behavior (methods) into a single unit. Classes can contain constructors for initialization, destructors for cleanup, properties for controlled access to fields, events for notifications, and nested types. Classes support inheritance, polymorphism, and abstraction. Understanding class design principles (encapsulation, cohesion, low coupling) is essential for object-oriented programming in C#.",
    "code": "public class Person {\n    public string Name { get; set; }\n    public void Greet() {\n        Console.WriteLine(\"Hi, \" + Name);\n    }\n}"
  },
  {
    "title": "C# OOP",
    "note": "Object-Oriented Programming in C# is based on four principles: encapsulation (bundling data and methods, controlling access), inheritance (creating new classes from existing ones), polymorphism (objects of different types responding to the same interface), and abstraction (hiding implementation details). C# supports these through classes, interfaces, inheritance, virtual methods, and abstract classes. OOP helps manage complexity by modeling real-world entities and their relationships, leading to more maintainable and extensible code.",
    "code": "// Example: inheritance\nclass Student : Person { }"
  },
  {
    "title": "C# Classes/Objects",
    "note": "Objects are instances of classes created using the new operator. Objects contain the data (field values) and have access to the behavior (methods) defined in their class. Each object has its own set of data members but shares method implementations. Objects are reference types and are allocated on the heap. Understanding object creation, initialization, and garbage collection is important for memory management. Objects can be compared for equality (reference equality by default, or value equality if overridden).",
    "code": "Person p = new Person();\np.Name = \"Alice\";\np.Greet();"
  },
  {
    "title": "C# Class Members",
    "note": "Class members include fields (data storage), methods (behavior), properties (controlled access to fields), events (notifications), indexers (array-like access), operators (custom operator behavior), and nested types. Members can have different access levels (public, private, protected, internal, protected internal). Static members belong to the class rather than instances. Instance members operate on specific object instances. Understanding member types and their appropriate usage is key to effective class design.",
    "code": "public int Age { get; set; }"
  },
  {
    "title": "C# Constructors",
    "note": "Constructors are special methods that initialize objects when they are created. They have the same name as the class and no return type. Constructors can be overloaded, can have parameters, and can call other constructors using this(). Static constructors initialize static members. If no constructor is defined, a default parameterless constructor is provided. Constructors ensure objects start in a valid state. Understanding constructor chaining, initialization order, and exception handling in constructors is important for robust object creation.",
    "code": "public Person(string name) {\n    Name = name;\n}"
  },
  {
    "title": "C# Access Modifiers",
    "note": "Access modifiers control the visibility and accessibility of types and members: public (accessible anywhere), private (accessible only within the containing type), protected (accessible within the containing type and derived types), internal (accessible within the same assembly), and protected internal (accessible within the same assembly or derived types). Proper use of access modifiers enforces encapsulation, prevents unauthorized access, and defines clear APIs. Access modifiers are essential for information hiding and maintaining class invariants.",
    "code": "private int id;"
  },
  {
    "title": "C# Properties",
    "note": "Properties provide controlled access to class fields. They can have get accessors (read), set accessors (write), or both. Properties can be auto-implemented (public string Name { get; set; }) or have custom logic in accessors. Properties can have different accessibility for get and set. Properties are preferred over public fields as they allow validation, computation, and change notification. Indexers are properties that allow array-like access to objects. Understanding property design is key to creating robust class interfaces.",
    "code": "public string Name { get; set; }"
  },
  {
    "title": "C# Inheritance",
    "note": "Inheritance allows a class (derived) to inherit members from another class (base). C# supports single inheritance for classes (a class can inherit from one base class) but multiple interface implementation. Inheritance enables code reuse and polymorphism. The base keyword accesses base class members. Constructors are not inherited; derived classes must call base constructors. Understanding inheritance hierarchies, the is-a relationship, and when to use composition instead of inheritance is important for good OOP design.",
    "code": "class Student : Person { }"
  },
  {
    "title": "C# Polymorphism",
    "note": "Polymorphism allows objects of different types to be treated through a common interface. Runtime polymorphism is achieved through virtual methods and overriding. The virtual keyword allows a method to be overridden in derived classes. The override keyword provides a new implementation. The base keyword calls the base class implementation. Compile-time polymorphism is achieved through method overloading and generics. Polymorphism enables writing flexible, extensible code that works with objects of various types through a uniform interface.",
    "code": "public virtual void Speak() {\n    Console.WriteLine(\"Hello\");\n}"
  },
  {
    "title": "C# Abstraction",
    "note": "Abstraction focuses on essential qualities rather than concrete details. In C#, abstraction is achieved through abstract classes and interfaces. Abstract classes cannot be instantiated and may contain abstract methods (without implementation) that must be implemented by derived classes. Interfaces define contracts that implementing classes must fulfill. Abstraction helps manage complexity by hiding implementation details and exposing only necessary functionality. It enables programming to interfaces rather than implementations, facilitating flexibility and maintainability.",
    "code": "abstract class Animal {\n    public abstract void MakeSound();\n}"
  },
  {
    "title": "C# Interface",
    "note": "Interfaces define contracts that classes can implement. They contain method, property, event, and indexer signatures without implementations. Classes can implement multiple interfaces. Interfaces enable polymorphism without the single inheritance limitation. C# 8.0 added default interface methods allowing interfaces to provide implementations. Interfaces are used for dependency injection, testing, and creating plug-in architectures. Understanding interface design principles (focused, cohesive) is important for creating flexible and testable code.",
    "code": "interface IWalkable {\n    void Walk();\n}"
  },
  {
    "title": "C# Enums",
    "note": "Enums are value types that define a set of named constants. They make code more readable and maintainable by replacing magic numbers with meaningful names. Enums can have an underlying type (byte, int, etc.) and explicit values. Enums support bit flags with the [Flags] attribute for combinations of values. Enum values can be converted to/from strings and integers. Enums are useful for representing fixed sets of options, states, or categories. Understanding enum best practices improves code clarity and type safety.",
    "code": "enum Days { Sunday, Monday, Tuesday }"
  },
  {
    "title": "C# Files",
    "note": "File I/O in C# is handled through the System.IO namespace. The File class provides static methods for file operations (Create, Delete, ReadAllText, WriteAllText). FileStream provides low-level file access. StreamReader and StreamWriter handle text files with encoding support. File operations can be synchronous or asynchronous. Proper file handling includes exception handling for I/O errors, using statements for resource cleanup, and considering file locking and sharing issues. Understanding file paths, permissions, and encoding is crucial for robust file operations.",
    "code": "using System.IO;\nFile.WriteAllText(\"file.txt\", \"Hello World!\");"
  },
  {
    "title": "C# Exceptions",
    "note": "Exceptions handle runtime errors in a structured way. try blocks contain code that might throw exceptions. catch blocks handle specific exception types. finally blocks execute regardless of exceptions, typically for cleanup. Exception filters (when clause) add conditions to catch blocks. Custom exception classes should derive from Exception. Exception handling should be specific (catch specific exceptions rather than general Exception), and exceptions should be thrown for exceptional conditions, not for normal control flow.",
    "code": "try {\n    // code\n} catch (Exception ex) {\n    Console.WriteLine(ex.Message);\n}"
  },
  {
    "title": "C# Add Two Numbers",
    "note": "This simple example demonstrates basic C# syntax, variable declaration, arithmetic operations, and output. It shows how to declare variables of primitive types, perform addition, and display the result. While elementary, this pattern is fundamental to understanding how C# programs are structured and executed. The example can be extended to include user input, error handling, and function encapsulation, forming the basis for more complex programs and algorithms.",
    "code": "int a = 5, b = 3;\nConsole.WriteLine(a + b);"
  },
  {
    "title": "C# Examples",
    "note": "C# examples range from basic syntax demonstrations to complete application patterns. Common examples include: console applications showing language features, Windows Forms or WPF applications demonstrating GUI programming, ASP.NET examples for web development, and Unity examples for game development. Examples help learners understand how to apply C# concepts in practice, see common patterns and idioms, and avoid typical pitfalls. Well-commented examples that explain both the how and why are particularly valuable for learning.",
    "code": "// Example code snippets"
  },
  {
    "title": "C# Compiler",
    "note": "The C# compiler (csc.exe or dotnet build) translates C# source code into Intermediate Language (IL) for execution by the .NET runtime. The compiler performs syntax checking, type inference, optimization, and generates metadata. Compiler options control target framework, output type, warnings, and optimizations. The Roslyn compiler platform provides APIs for code analysis and compilation as a service. Understanding compiler errors and warnings, and how to configure compilation, is essential for C# development.",
    "code": "// dotnet build and dotnet run commands"
  },
  {
    "title": "C# Exercises",
    "note": "C# programming exercises provide practical problems to develop coding skills. Exercises range from basic syntax practice to advanced challenges involving algorithms, data structures, OOP design, and async programming. Common exercise categories include: string manipulation, collection handling, file I/O, LINQ queries, and exception handling. Platforms like Exercism, LeetCode, and HackerRank offer graded C# exercises. Regular practice with diverse problems builds problem-solving ability and deepens understanding of C# features and the .NET ecosystem.",
    "code": "// Solve coding challenges"
  },
  {
    "title": "C# Quiz",
    "note": "C# quizzes test knowledge through multiple-choice questions, code interpretation problems, and debugging exercises. Topics include: language syntax, OOP concepts, .NET framework features, exception handling, and modern C# features. Quizzes help identify knowledge gaps, prepare for job interviews, and reinforce learning through immediate feedback. Many online learning platforms, certification programs, and educational resources include C# quizzes with explanations to clarify complex concepts and common misunderstandings.",
    "code": "// Multiple choice or coding quizzes"
  },
  {
    "title": "C# Server",
    "note": "C# is widely used for server-side programming through ASP.NET for web applications, web APIs, and microservices. Server applications handle HTTP requests, process business logic, access databases, and return responses. ASP.NET provides frameworks like MVC, Web API, Razor Pages, and Blazor. Server applications typically involve dependency injection, middleware, configuration, logging, and security considerations. Understanding HTTP, REST, authentication, and deployment is essential for C# server development.",
    "code": "// Host web applications"
  },
  {
    "title": "C# Syllabus",
    "note": "A comprehensive C# syllabus covers: C# fundamentals (syntax, types, operators), control structures, methods, classes and OOP, exception handling, collections and generics, file I/O, LINQ, async programming, and .NET framework features. The syllabus should progress from basic concepts to advanced topics, with practical projects at each stage. A well-structured syllabus includes learning objectives, recommended resources, assessment methods, and timeline. It serves as a roadmap for systematic C# learning, ensuring coverage of essential topics and skills.",
    "code": "// Detailed topic list"
  },
  {
    "title": "C# Study Plan",
    "note": "An effective C# study plan typically spans 2-4 months for comprehensive coverage. Week 1-4: Fundamentals (syntax, types, control flow). Week 5-8: OOP and advanced features (classes, inheritance, exceptions). Week 9-12: .NET ecosystem (collections, LINQ, file I/O, async). Week 13+: Specialization (ASP.NET, Unity, etc.). Daily study should include both theoretical learning and hands-on coding, with weekly projects to reinforce concepts. The plan should be adaptable and include regular review sessions. Consistency and practical application are key to mastery.",
    "code": "// Weekly/daily plan"
  },
  {
    "title": "C# Certificate",
    "note": "C# certifications validate professional competency and are offered by Microsoft (MTA, MCSD) and other organizations. These certifications typically involve exams testing knowledge of C# language features, .NET framework, and application development. Preparation requires months of study using official guides, practice tests, and hands-on coding experience. Certifications can enhance job prospects, especially in enterprises using Microsoft technologies. They provide structured learning paths and industry recognition of C# programming skills.",
    "code": "// Information on certification exams"
  }

],
 MySQL: [

  {
    "title": "MySQL Intro",
    "note": "MySQL is an open-source relational database management system (RDBMS) that uses Structured Query Language (SQL) for managing and manipulating data. Developed by MySQL AB (now owned by Oracle), it is widely used for web applications, data warehousing, and embedded databases. MySQL supports ACID compliance (with InnoDB), transactions, foreign keys, and replication. It is known for its reliability, performance, and ease of use. MySQL runs on various platforms and is a core component of the LAMP (Linux, Apache, MySQL, PHP/Python/Perl) stack.",
    "code": "-- Connect to MySQL server and manage databases"
  },
  {
    "title": "MySQL RDBMS",
    "note": "A Relational Database Management System (RDBMS) organizes data into tables (relations) consisting of rows and columns. Tables are linked through relationships defined by foreign keys. MySQL implements the relational model with support for SQL standards, ensuring data integrity through constraints, transactions, and normalization. Key concepts include: entities (tables), attributes (columns), tuples (rows), and relationships (one-to-one, one-to-many, many-to-many). Understanding the relational model is fundamental to effective database design and querying.",
    "code": "-- Tables, keys, and relationships form the core of RDBMS"
  },
  {
    "title": "MySQL SELECT",
    "note": "The SELECT statement retrieves data from one or more tables. It is the most commonly used SQL command. The basic syntax specifies columns to retrieve (or * for all columns), the table name, and optional clauses for filtering, sorting, and grouping. SELECT can be used with expressions, functions, and joins to transform and combine data. Understanding SELECT is essential for querying databases effectively. Proper use of SELECT includes specifying only needed columns for performance and using WHERE to limit results.",
    "code": "SELECT * FROM users;"
  },
  {
    "title": "MySQL WHERE",
    "note": "The WHERE clause filters records based on specified conditions. It is used with SELECT, UPDATE, and DELETE statements to restrict which rows are affected. Conditions can use comparison operators (=, <>, <, >, <=, >=), logical operators (AND, OR, NOT), and other predicates (IN, BETWEEN, LIKE, IS NULL). WHERE conditions are evaluated for each row, and only rows meeting the condition are included in the result. Proper indexing of columns used in WHERE clauses is crucial for performance.",
    "code": "SELECT * FROM users WHERE age > 30;"
  },
  {
    "title": "MySQL AND, OR, NOT",
    "note": "Logical operators combine multiple conditions in WHERE clauses. AND requires all conditions to be true. OR requires at least one condition to be true. NOT negates a condition. Parentheses can be used to control evaluation order. Understanding operator precedence (NOT, AND, OR) and using parentheses for complex logic is important for correct filtering. These operators enable sophisticated filtering criteria for precise data retrieval.",
    "code": "SELECT * FROM users WHERE age > 30 AND status = 'active';"
  },
  {
    "title": "MySQL ORDER BY",
    "note": "The ORDER BY clause sorts the result set by one or more columns in ascending (ASC) or descending (DESC) order. Multiple columns can be specified for secondary sorting. ORDER BY can use column names, aliases, or ordinal positions. Sorting text data considers collation settings. ORDER BY is often used with LIMIT for pagination. For large result sets, sorting can be performance-intensive; proper indexing can help. Understanding sorting NULL values (which are considered lowest) is important for predictable results.",
    "code": "SELECT * FROM users ORDER BY created_at DESC;"
  },
  {
    "title": "MySQL INSERT INTO",
    "note": "The INSERT statement adds new rows to a table. The basic form specifies the table name, column names (optional if inserting all columns), and values to insert. Multiple rows can be inserted with a single statement using multiple value tuples. INSERT can also insert data from a SELECT query. Auto-increment columns are automatically populated. Proper use includes validating data before insertion and handling potential errors (duplicate keys, constraint violations).",
    "code": "INSERT INTO users (name, age) VALUES ('Alice', 28);"
  },
  {
    "title": "MySQL NULL Values",
    "note": "NULL represents missing or unknown data. It is different from empty string or zero. Comparisons with NULL using = or <> always return NULL (unknown). Use IS NULL or IS NOT NULL to check for NULL values. Functions like IFNULL(), COALESCE(), and NULLIF() help handle NULL values in queries. Understanding three-valued logic (true, false, unknown) in SQL is crucial for correct query results when NULLs are involved.",
    "code": "SELECT * FROM users WHERE middle_name IS NULL;"
  },
  {
    "title": "MySQL UPDATE",
    "note": "The UPDATE statement modifies existing data in a table. It specifies the table to update, the columns and new values to set, and an optional WHERE clause to determine which rows are updated. Without WHERE, all rows are updated. UPDATE can use expressions and functions in SET clauses. Proper use includes testing with SELECT first, using transactions for multiple related updates, and ensuring adequate indexing for WHERE clauses to avoid table scans.",
    "code": "UPDATE users SET status = 'inactive' WHERE last_login < '2023-01-01';"
  },
  {
    "title": "MySQL DELETE",
    "note": "The DELETE statement removes rows from a table. It can include a WHERE clause to specify which rows to delete. Without WHERE, all rows are deleted (truncating the table, but unlike TRUNCATE TABLE, it logs individual row deletions). DELETE operations can be rolled back if within a transaction. Proper use includes caution with WHERE clauses to avoid accidental data loss, and using transactions for critical deletions.",
    "code": "DELETE FROM users WHERE id = 10;"
  },
  {
    "title": "MySQL LIMIT",
    "note": "The LIMIT clause restricts the number of rows returned by a query. It is often used with ORDER BY for top-N queries or pagination. LIMIT takes one or two parameters: LIMIT row_count or LIMIT offset, row_count. For large offsets, this can be inefficient; alternative pagination techniques may be better. LIMIT is MySQL-specific syntax; other databases use different approaches like TOP or ROWNUM.",
    "code": "SELECT * FROM users LIMIT 5;"
  },
  {
    "title": "MySQL MIN and MAX",
    "note": "The MIN() and MAX() aggregate functions return the minimum and maximum values in a column. They work with numeric, date, and string data types. When used with GROUP BY, they return min/max per group. These functions ignore NULL values. Understanding their behavior with different data types and in combination with other clauses is important for statistical queries and data analysis.",
    "code": "SELECT MIN(age), MAX(age) FROM users;"
  },
  {
    "title": "MySQL COUNT, AVG, SUM",
    "note": "Aggregate functions perform calculations on sets of values: COUNT() returns the number of rows, AVG() returns the average of values, SUM() returns the sum of values. They are often used with GROUP BY to aggregate data by groups. COUNT(*) counts all rows including NULLs, COUNT(column) counts non-NULL values. These functions ignore NULL values in calculations. Understanding their behavior is essential for reporting and data analysis.",
    "code": "SELECT COUNT(*), AVG(age), SUM(salary) FROM employees;"
  },
  {
    "title": "MySQL LIKE",
    "note": "The LIKE operator is used in WHERE clauses to search for a specified pattern in a column. It supports two wildcards: % (matches zero or more characters) and _ (matches exactly one character). LIKE is case-insensitive by default in MySQL (depending on collation). For pattern matching, LIKE is essential for text search operations. For more complex patterns, regular expressions (REGEXP) can be used.",
    "code": "SELECT * FROM users WHERE name LIKE 'A%';"
  },
  {
    "title": "MySQL Wildcards",
    "note": "Wildcards are used with LIKE for pattern matching: % matches any sequence of characters (including none), _ matches any single character. Wildcards can be used at the beginning, middle, or end of patterns. To match literal % or _, escape them with \\ (or specify another escape character with ESCAPE). Understanding wildcard usage is important for flexible text searching, though it may impact performance without proper indexing.",
    "code": "SELECT * FROM products WHERE code LIKE '_123%';"
  },
  {
    "title": "MySQL IN",
    "note": "The IN operator allows specifying multiple values in a WHERE clause. It is a shorthand for multiple OR conditions. IN can be used with a list of literal values or a subquery. NOT IN excludes the specified values. When using subqueries, ensure they return appropriate results. IN is useful for filtering against fixed value sets or correlated data from other tables.",
    "code": "SELECT * FROM users WHERE country IN ('USA', 'Canada');"
  },
  {
    "title": "MySQL BETWEEN",
    "note": "The BETWEEN operator selects values within a range (inclusive). It can be used with numbers, dates, and strings. BETWEEN is equivalent to value >= low AND value <= high. NOT BETWEEN excludes the range. For date ranges, be mindful of time components. BETWEEN is useful for range queries but should be used with understanding of inclusive boundaries.",
    "code": "SELECT * FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-01-31';"
  },
  {
    "title": "MySQL Aliases",
    "note": "Aliases provide temporary names for columns or tables. Column aliases make output more readable or are required for derived columns. Table aliases shorten table names in queries, especially with joins. Aliases are defined with AS keyword (which is optional). Aliases exist only for the duration of the query and don't affect the actual database structure.",
    "code": "SELECT name AS username FROM users;"
  },
  {
    "title": "MySQL Joins",
    "note": "Joins combine rows from two or more tables based on related columns. The main types are INNER JOIN (returns matching rows), LEFT JOIN (all left rows + matching right rows), RIGHT JOIN (all right rows + matching left rows), and FULL JOIN (all rows when there is a match in either table). Joins are fundamental for relational database querying, allowing data from multiple related tables to be retrieved in a single query.",
    "code": "SELECT u.name, o.amount FROM users u INNER JOIN orders o ON u.id = o.user_id;"
  },
  {
    "title": "MySQL INNER JOIN",
    "note": "INNER JOIN returns only the rows that have matching values in both tables. It is the most common type of join. If no match is found, the row is excluded from the result. Multiple INNER JOINs can be chained to combine data from several tables. Understanding join conditions and the relationships between tables is crucial for correct INNER JOIN usage.",
    "code": "SELECT * FROM A INNER JOIN B ON A.id = B.a_id;"
  },
  {
    "title": "MySQL LEFT JOIN",
    "note": "LEFT JOIN returns all rows from the left table, and the matched rows from the right table. If no match is found, NULL values are returned for right table columns. LEFT JOIN is useful for finding records that may not have related data in another table (e.g., users with no orders). Understanding when to use LEFT JOIN vs INNER JOIN is important for accurate query results.",
    "code": "SELECT * FROM A LEFT JOIN B ON A.id = B.a_id;"
  },
  {
    "title": "MySQL RIGHT JOIN",
    "note": "RIGHT JOIN returns all rows from the right table, and the matched rows from the left table. If no match is found, NULL values are returned for left table columns. RIGHT JOIN is less commonly used than LEFT JOIN, as the same result can usually be achieved by swapping tables and using LEFT JOIN. It's included for completeness in the SQL standard.",
    "code": "SELECT * FROM A RIGHT JOIN B ON A.id = B.a_id;"
  },
  {
    "title": "MySQL CROSS JOIN",
    "note": "CROSS JOIN returns the Cartesian product of the two tables - every row from the first table combined with every row from the second table. The result set size is the product of the row counts of both tables. CROSS JOIN can be useful for generating combinations or when no specific relationship exists between tables, but should be used cautiously with large tables due to the potential for huge result sets.",
    "code": "SELECT * FROM A CROSS JOIN B;"
  },
  {
    "title": "MySQL Self Join",
    "note": "A self join is a regular join where a table is joined with itself. This is useful for comparing rows within the same table or querying hierarchical data (e.g., employee-manager relationships). Different aliases must be used for the two instances of the table. Self joins are conceptually similar to joining two copies of the same table.",
    "code": "SELECT A.name, B.name FROM employees A, employees B WHERE A.manager_id = B.id;"
  },
  {
    "title": "MySQL UNION",
    "note": "UNION combines the result sets of two or more SELECT statements into a single result set. It removes duplicate rows between the various SELECT statements. All SELECT statements must have the same number of columns with compatible data types. UNION is useful for combining data from similar tables or different queries on the same table.",
    "code": "SELECT city FROM customers UNION SELECT city FROM suppliers;"
  },
  {
    "title": "MySQL UNION ALL",
    "note": "UNION ALL combines result sets like UNION but does not remove duplicates. It is faster than UNION since it doesn't need to check for duplicates. Use UNION ALL when duplicates are acceptable or when you know there are no duplicates between the result sets. Understanding the difference between UNION and UNION ALL is important for performance and correct results.",
    "code": "SELECT city FROM customers UNION ALL SELECT city FROM suppliers;"
  },
  {
    "title": "MySQL GROUP BY",
    "note": "GROUP BY groups rows that have the same values in specified columns into summary rows. It is used with aggregate functions (COUNT, MAX, MIN, SUM, AVG) to perform calculations on each group. GROUP BY can group by multiple columns. Understanding GROUP BY is essential for summary reports and data analysis. Columns in SELECT that are not aggregated must appear in GROUP BY.",
    "code": "SELECT country, COUNT(*) FROM users GROUP BY country;"
  },
  {
    "title": "MySQL HAVING",
    "note": "HAVING filters groups based on aggregate conditions, similar to how WHERE filters rows. HAVING is applied after GROUP BY, while WHERE is applied before. HAVING can use aggregate functions in conditions, which WHERE cannot. HAVING is essential for filtering grouped data (e.g., finding countries with more than 100 users).",
    "code": "SELECT country, COUNT(*) FROM users GROUP BY country HAVING COUNT(*) > 10;"
  },
  {
    "title": "MySQL EXISTS",
    "note": "EXISTS is used in WHERE clauses to test for the existence of any rows in a subquery. It returns true if the subquery returns one or more rows. EXISTS is often used with correlated subqueries (subqueries that reference outer query columns). It can be more efficient than IN for large datasets, as it can stop processing once a match is found.",
    "code": "SELECT * FROM customers WHERE EXISTS (SELECT * FROM orders WHERE orders.customer_id = customers.id);"
  },
  {
    "title": "MySQL ANY, ALL",
    "note": "ANY and ALL are used with subqueries to compare a value to a set of values. ANY returns true if the comparison is true for any of the subquery values. ALL returns true if the comparison is true for all subquery values. These operators are useful for complex comparisons against result sets from subqueries.",
    "code": "SELECT * FROM products WHERE price > ANY (SELECT price FROM sales);"
  },
  {
    "title": "MySQL INSERT SELECT",
    "note": "INSERT SELECT inserts rows selected from one or more tables into another table. The SELECT query must return columns compatible with the target table. This is useful for copying data between tables, archiving data, or transforming data during insertion. It can be more efficient than multiple INSERT statements for large data transfers.",
    "code": "INSERT INTO archive_orders SELECT * FROM orders WHERE order_date < '2022-01-01';"
  },
  {
    "title": "MySQL CASE",
    "note": "The CASE expression provides conditional logic within SQL queries. It can be used in SELECT, WHERE, and ORDER BY clauses. CASE has two forms: simple CASE (compares a value to multiple possibilities) and searched CASE (evaluates multiple conditions). CASE is essential for transforming data, creating derived columns, and implementing complex business logic in queries.",
    "code": "SELECT name, CASE WHEN age < 18 THEN 'Minor' ELSE 'Adult' END AS status FROM users;"
  },
  {
    "title": "MySQL Null Functions",
    "note": "MySQL provides functions to handle NULL values: IFNULL() returns a specified value if the expression is NULL, COALESCE() returns the first non-NULL value in a list, NULLIF() returns NULL if two expressions are equal. These functions are essential for dealing with missing data and providing default values in query results.",
    "code": "SELECT IFNULL(middle_name, 'N/A') FROM users;"
  },
  {
    "title": "MySQL Comments",
    "note": "Comments in SQL scripts help document code and can be used to temporarily disable parts of queries. Single-line comments start with -- (followed by a space) or #. Multi-line comments are enclosed in /* */. Comments are ignored by the MySQL parser. Good commenting practices improve code maintainability and help other developers understand complex queries.",
    "code": "-- This is a single-line comment\n/* This is a\nmulti-line comment */"
  },
  {
    "title": "MySQL Operators",
    "note": "MySQL supports various operators: arithmetic (+, -, *, /, %), comparison (=, <>, <, >, <=, >=), logical (AND, OR, NOT, XOR), bitwise (&, |, ^, ~, <<, >>), and pattern matching (LIKE, REGEXP). Understanding operator precedence and behavior with different data types is crucial for writing correct expressions and conditions.",
    "code": "SELECT * FROM table WHERE price > 100 AND stock < 50;"
  },
  {
    "title": "MySQL Create DB",
    "note": "CREATE DATABASE creates a new database. The database name must be unique within the MySQL server instance. Optional clauses can specify character set and collation. Creating a database typically requires appropriate privileges. Databases are containers for tables, views, procedures, and other database objects.",
    "code": "CREATE DATABASE mydb;"
  },
  {
    "title": "MySQL Drop DB",
    "note": "DROP DATABASE deletes an entire database and all its objects (tables, views, etc.). This operation cannot be undone and should be used with extreme caution. It typically requires appropriate privileges. DROP DATABASE is irreversible and will result in permanent data loss.",
    "code": "DROP DATABASE mydb;"
  },
  {
    "title": "MySQL Create Table",
    "note": "CREATE TABLE defines a new table and its columns. Each column definition includes a name, data type, and optional constraints. Tables can have primary keys, foreign keys, indexes, and other constraints. Proper table design involves choosing appropriate data types, defining constraints for data integrity, and considering normalization principles.",
    "code": "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(50));"
  },
  {
    "title": "MySQL Drop Table",
    "note": "DROP TABLE removes a table and all its data from the database. This operation is irreversible and should be used carefully. If the table has foreign key relationships, you may need to drop those constraints first or use CASCADE (if supported). DROP TABLE requires appropriate privileges.",
    "code": "DROP TABLE users;"
  },
  {
    "title": "MySQL Alter Table",
    "note": "ALTER TABLE modifies an existing table's structure. It can add, modify, or drop columns; add or drop constraints; change data types; rename columns or tables; and manage indexes. ALTER TABLE is essential for database schema evolution. Some alterations may require table rebuilding and can be time-consuming for large tables.",
    "code": "ALTER TABLE users ADD COLUMN email VARCHAR(100);"
  },
  {
    "title": "MySQL Constraints",
    "note": "Constraints enforce rules on data in tables to maintain integrity: NOT NULL ensures a column cannot have NULL values, UNIQUE ensures all values in a column are different, PRIMARY KEY uniquely identifies each row, FOREIGN KEY enforces relationships between tables, CHECK ensures column values meet specific conditions. Constraints are fundamental for data quality and relational integrity.",
    "code": "CREATE TABLE users (id INT PRIMARY KEY, email VARCHAR(100) UNIQUE NOT NULL);"
  },
  {
    "title": "MySQL Not Null",
    "note": "The NOT NULL constraint ensures that a column cannot contain NULL values. It is applied at the column level and prevents insertion or update of rows with NULL in that column. NOT NULL is essential for columns that must always have a value. It simplifies queries by eliminating the need to check for NULL in application logic.",
    "code": "ALTER TABLE users MODIFY email VARCHAR(100) NOT NULL;"
  },
  {
    "title": "MySQL Unique",
    "note": "The UNIQUE constraint ensures that all values in a column (or combination of columns) are different. Unlike PRIMARY KEY, a table can have multiple UNIQUE constraints, and UNIQUE columns can contain NULL values (though only one NULL if the column is NOT NULL). UNIQUE constraints are implemented using unique indexes.",
    "code": "CREATE UNIQUE INDEX idx_email ON users(email);"
  },
  {
    "title": "MySQL Primary Key",
    "note": "A PRIMARY KEY uniquely identifies each row in a table. It must contain unique values and cannot contain NULL values. A table can have only one primary key, which can consist of single or multiple columns. Primary keys are automatically indexed. They are essential for table relationships and often used as the clustering key for physical storage organization.",
    "code": "ALTER TABLE users ADD PRIMARY KEY (id);"
  },
  {
    "title": "MySQL Foreign Key",
    "note": "A FOREIGN KEY creates a relationship between two tables. It ensures referential integrity by requiring that values in the foreign key column match values in the referenced table's primary key. Foreign keys can enforce cascading actions (DELETE CASCADE, UPDATE CASCADE) or prevent actions that would break relationships (RESTRICT). They are fundamental for maintaining relational integrity.",
    "code": "ALTER TABLE orders ADD FOREIGN KEY (user_id) REFERENCES users(id);"
  },
  {
    "title": "MySQL Check",
    "note": "The CHECK constraint limits the values that can be placed in a column. It specifies a condition that must be true for each row. CHECK constraints can reference multiple columns. While part of the SQL standard, MySQL historically parsed but ignored CHECK constraints (until recent versions where they are enforced with InnoDB). They are useful for domain integrity validation.",
    "code": "ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age >= 18);"
  },
  {
    "title": "MySQL Default",
    "note": "The DEFAULT constraint provides a default value for a column when no value is specified during insertion. Default values can be constants, expressions, or functions (like CURRENT_TIMESTAMP). DEFAULT is useful for columns that commonly have a specific value, reducing the need to explicitly specify values in INSERT statements.",
    "code": "ALTER TABLE users ALTER COLUMN status SET DEFAULT 'active';"
  },
  {
    "title": "MySQL Create Index",
    "note": "CREATE INDEX creates an index on one or more columns to improve query performance. Indexes allow faster data retrieval but slow down data modification (INSERT, UPDATE, DELETE). Different index types include B-tree (default), hash, and full-text. Proper index design involves analyzing query patterns and creating indexes on frequently searched columns.",
    "code": "CREATE INDEX idx_name ON users(name);"
  },
  {
    "title": "MySQL Auto Increment",
    "note": "AUTO_INCREMENT automatically generates a unique number for a column when a new row is inserted. It is typically used for primary key columns. Each table can have only one AUTO_INCREMENT column, which must be indexed. The value increases by 1 for each new record (by default), but the increment can be changed. AUTO_INCREMENT simplifies the creation of unique identifiers.",
    "code": "CREATE TABLE users (id INT AUTO_INCREMENT PRIMARY KEY);"
  },
  {
    "title": "MySQL Dates",
    "note": "MySQL supports various date and time data types: DATE (YYYY-MM-DD), TIME (HH:MM:SS), DATETIME (YYYY-MM-DD HH:MM:SS), TIMESTAMP (similar to DATETIME but with timezone support), and YEAR. Date functions include NOW(), CURDATE(), DATE_ADD(), DATEDIFF(), and formatting functions like DATE_FORMAT(). Proper handling of dates is crucial for temporal data management.",
    "code": "SELECT * FROM events WHERE event_date > '2024-01-01';"
  },
  {
    "title": "MySQL Views",
    "note": "A VIEW is a virtual table based on the result of a SELECT query. Views can simplify complex queries, provide a level of abstraction, and enhance security by restricting access to specific columns or rows. Views can be updatable under certain conditions. They are stored in the database and can be queried like regular tables.",
    "code": "CREATE VIEW active_users AS SELECT * FROM users WHERE status = 'active';"
  },
  {
    "title": "MySQL Data Types",
    "note": "MySQL supports various data types: numeric (INT, DECIMAL, FLOAT), string (CHAR, VARCHAR, TEXT), date and time (DATE, DATETIME, TIMESTAMP), and special types (ENUM, SET, JSON). Choosing appropriate data types affects storage efficiency, performance, and data integrity. Understanding type characteristics, storage requirements, and appropriate usage is fundamental to good database design.",
    "code": "CREATE TABLE sample (id INT, name VARCHAR(50), created_at DATE);"
  },
  {
    "title": "MySQL Functions",
    "note": "MySQL provides built-in functions for various operations: string functions (CONCAT, SUBSTRING, LENGTH), numeric functions (ROUND, ABS, MOD), date functions (NOW, DATE_ADD, DATEDIFF), aggregate functions (COUNT, SUM, AVG), and control flow functions (IF, CASE). Functions can be used in SELECT, WHERE, and other clauses to transform and manipulate data.",
    "code": "SELECT UPPER(name), NOW() FROM users;"
  },
  {
    "title": "MySQL Examples",
    "note": "Practical examples help learners understand how to apply MySQL concepts. Examples range from basic CRUD operations to complex queries involving multiple tables, subqueries, and advanced features. Studying examples demonstrates real-world usage patterns, common pitfalls, and best practices. Examples should be tested and modified to deepen understanding.",
    "code": "-- Example queries for learning"
  },
  {
    "title": "MySQL Editor",
    "note": "MySQL can be managed through various tools: command-line client (mysql), graphical tools like MySQL Workbench (official GUI), phpMyAdmin (web-based), and IDE integrations. These tools provide interfaces for writing queries, managing databases, visualizing data, and administering MySQL servers. Choosing appropriate tools depends on the task and user preference.",
    "code": "-- Tools: MySQL Workbench, phpMyAdmin"
  },
  {
    "title": "MySQL Quiz",
    "note": "Quizzes test MySQL knowledge through multiple-choice questions, query writing exercises, and problem-solving scenarios. Topics include SQL syntax, database design, query optimization, and administration. Quizzes help identify knowledge gaps, prepare for certifications, and reinforce learning. Regular self-testing improves retention and understanding of MySQL concepts.",
    "code": "-- Sample multiple choice questions"
  },
  {
    "title": "MySQL Exercises",
    "note": "Hands-on exercises provide practical experience with MySQL. Exercises range from writing basic queries to designing database schemas, optimizing performance, and solving real-world data problems. Practicing with diverse exercises builds confidence and proficiency. Many online platforms offer graded exercises with automated testing and solutions.",
    "code": "-- Write and run SQL queries"
  },
  {
    "title": "MySQL Syllabus",
    "note": "A structured syllabus outlines the learning path for MySQL, covering: database fundamentals, SQL syntax, data definition and manipulation, advanced querying, database design, normalization, transactions, and administration. A good syllabus progresses from basic to advanced topics, includes practical projects, and recommends resources. It serves as a roadmap for comprehensive MySQL learning.",
    "code": "-- List of topics and objectives"
  },
  {
    "title": "MySQL Study Plan",
    "note": "A study plan organizes MySQL learning into manageable segments. A typical plan might include: Week 1-2: SQL basics and simple queries, Week 3-4: Joins and advanced queries, Week 5-6: Database design and normalization, Week 7-8: Performance optimization and administration. The plan should balance theoretical learning with hands-on practice and include time for review and projects.",
    "code": "-- Daily/weekly study goals"
  },
  {
    "title": "MySQL Certificate",
    "note": "MySQL certifications validate expertise and are offered by Oracle (MySQL Database Administrator, MySQL Developer). Certifications typically involve exams testing installation, configuration, SQL proficiency, security, backup/recovery, and performance tuning. Preparation requires hands-on experience, study of official documentation, and practice tests. Certifications can enhance career opportunities and demonstrate professional competence.",
    "code": "-- Information about exams and credentials"
  }
],
Django: [ 
  {
    "title": "Django Home",
    "note": "Django is a high-level Python web framework that enables rapid development of secure and maintainable websites. It follows the Model-Template-View (MTV) architectural pattern, which is similar to MVC. Django includes an ORM for database interactions, an automatic admin interface, robust URL routing, a template system, and built-in security features. It emphasizes reusability, pluggability, and the 'don't repeat yourself' (DRY) principle. Django is suitable for everything from simple websites to complex, data-driven applications.",
    "code": "# Official docs: https://www.djangoproject.com/"
  },
  {
    "title": "Django Intro",
    "note": "Django follows the MTV (Model-Template-View) architecture: Models define the data structure and handle database interactions, Templates control the presentation layer (HTML with Django template language), and Views contain the business logic that processes requests and returns responses. This separation of concerns makes Django applications organized, maintainable, and scalable. Django also includes middleware, forms, authentication, and internationalization support out of the box.",
    "code": "# Model, Template, View architecture overview"
  },
  {
    "title": "Django Get Started",
    "note": "To start with Django, first set up a Python virtual environment to isolate dependencies, then install Django using pip. After installation, you can create a new project using django-admin startproject, which generates the basic project structure. The development server can be run with python manage.py runserver to test the setup. Understanding the project structure (settings.py, urls.py, wsgi.py) is crucial for Django development.",
    "code": "python -m venv env\nsource env/bin/activate\npip install django"
  },
  {
    "title": "Create Virtual Environment",
    "note": "Virtual environments isolate Python dependencies for different projects, preventing version conflicts. Use python -m venv env to create a virtual environment named 'env', then activate it using source env/bin/activate (Linux/Mac) or env\\Scripts\\activate (Windows). The virtual environment should be activated before installing Django or any other project-specific packages. This practice ensures consistent environments across development, testing, and production.",
    "code": "python -m venv env\nsource env/bin/activate"
  },
  {
    "title": "Install Django",
    "note": "Django is installed using Python's package manager, pip. With your virtual environment activated, run pip install django to install the latest version of Django. You can specify a particular version with pip install django==version. The installation includes the Django framework, command-line tools (django-admin), and required dependencies. Verify the installation with python -m django --version.",
    "code": "pip install django"
  },
  {
    "title": "Django Create Project",
    "note": "A Django project is a collection of settings and configurations for a specific website. Use django-admin startproject myproject to create a new project named 'myproject'. This command creates a directory with the project name containing manage.py (a command-line utility) and a subdirectory with the same name containing settings.py, urls.py, wsgi.py, and asgi.py. The project structure organizes settings, URL configurations, and deployment configurations.",
    "code": "django-admin startproject myproject"
  },
  {
    "title": "Django Create App",
    "note": "Django apps are modular components that handle specific functionality within a project. Use python manage.py startapp myapp to create a new app. Each app should focus on a specific piece of functionality (e.g., blog, users, products). Apps include models.py (database models), views.py (request handlers), admin.py (admin configuration), and tests.py (unit tests). Apps are registered in the project's settings.py under INSTALLED_APPS.",
    "code": "python manage.py startapp myapp"
  },
  {
    "title": "Django Views",
    "note": "Views are Python functions or classes that handle web requests and return responses. They contain the business logic of your application. Function-based views take a request object and return a response, while class-based views provide reusable patterns for common tasks. Views can render templates, return JSON data, redirect users, or perform other actions. They are mapped to URLs through URL configurations.",
    "code": "def home(request):\n    return HttpResponse('Hello, Django!')"
  },
  {
    "title": "Django URLs",
    "note": "URL patterns map specific URLs to views using regular expressions or path converters. The URL configuration (URLconf) is defined in urls.py files. path() function is used for simple routes, while re_path() allows regex patterns. URL patterns can include parameters that are passed to views. Include() is used to include other URLconfs, enabling modular URL design. Named URLs allow reverse URL lookups in templates and code.",
    "code": "path('', views.home, name='home')"
  },
  {
    "title": "Django Templates",
    "note": "Templates are HTML files with Django Template Language (DTL) syntax for dynamic content. They support variables ({{ variable }}), tags ({% tag %}), filters ({{ value|filter }}), and inheritance. Template inheritance allows creating a base template with blocks that child templates can override. Templates are rendered by views using the render() function, which combines the template with context data.",
    "code": "{% block content %}Hello, {{ user }}!{% endblock %}"
  },
  {
    "title": "Django Models",
    "note": "Models define the structure of your database tables as Python classes. Each model class corresponds to a database table, and each attribute represents a database field. Django's ORM handles database operations, allowing you to work with Python objects instead of SQL. Models support various field types (CharField, IntegerField, DateTimeField, etc.), relationships (ForeignKey, ManyToManyField), and metadata options. Models are defined in models.py and require migrations to create database tables.",
    "code": "class Member(models.Model):\n    name = models.CharField(max_length=100)"
  },
  {
    "title": "Django Insert Data",
    "note": "Data is inserted into the database by creating model instances and calling save(). The create() method can also be used to create and save an object in one step. Model instances represent database rows, and their attributes correspond to column values. After modifying instances, save() must be called to persist changes to the database. Bulk operations are available for efficient multiple inserts.",
    "code": "member = Member(name='Alice')\nmember.save()"
  },
  {
    "title": "Django Update Data",
    "note": "Existing records are updated by modifying model instance attributes and calling save(). The update() method can update multiple objects in a single query without loading them into Python memory. update() is more efficient for bulk updates but doesn't trigger model save() methods or signals. For individual objects, modifying attributes and saving is the standard approach.",
    "code": "member.name = 'Bob'\nmember.save()"
  },
  {
    "title": "Django Delete Data",
    "note": "Records are deleted by calling delete() on model instances or querysets. delete() immediately removes the object from the database. It returns the number of objects deleted and a dictionary with the number of deletions per object type. delete() triggers pre_delete and post_delete signals. For bulk deletion, use queryset.delete() which is more efficient but doesn't call individual model delete() methods.",
    "code": "member.delete()"
  },
  {
    "title": "Django Update Model",
    "note": "When model definitions change, migrations are created and applied to update the database schema. makemigrations creates migration files based on model changes. migrate applies pending migrations to the database. Migrations are version control for your database schema, allowing safe evolution of the database structure over time. They can be rolled back if needed.",
    "code": "python manage.py makemigrations\npython manage.py migrate"
  },
  {
    "title": "Display Data",
    "note": "Data is displayed in templates by passing a context dictionary from views to the render() function. The context contains variables that become available in the template. QuerySets can be passed to templates and iterated over using for loops. Template filters can format or transform data for display. The template language provides safe output escaping to prevent XSS attacks.",
    "code": "return render(request, 'index.html', {'members': members})"
  },
  {
    "title": "Prep Template and View",
    "note": "Preparing templates and views involves creating a view function that retrieves data and a template to display it. The view typically queries the database using the model's manager (e.g., objects.all()), then passes the data to the template via the context. The template uses Django template language to render the data. URL configuration connects the view to a specific URL pattern.",
    "code": "def member_list(request):\n    members = Member.objects.all()\n    return render(request, 'members.html', {'members': members})"
  },
  {
    "title": "Add Link to Details",
    "note": "Detail page links are created using the url template tag with the name of the URL pattern and any required parameters. This generates the correct URL without hardcoding it. The url tag uses reverse URL lookup, making links maintainable even if URL patterns change. Detail links typically include a primary key or slug to identify the specific object.",
    "code": "<a href=\"{% url 'member_detail' member.id %}\">Details</a>"
  },
  {
    "title": "Add Master Template",
    "note": "A master template (base template) provides the common structure for multiple pages, using template inheritance. It defines blocks that child templates can override. Common elements like navigation, headers, footers, and CSS/JS includes are placed in the master template. Child templates extend the master template and fill in the content blocks. This promotes DRY principles and consistent layout across pages.",
    "code": "{% block content %}{% endblock %}"
  },
  {
    "title": "Add Main Index Page",
    "note": "The main index page is typically the homepage of the site. It's handled by a view that renders an index template. The index page often provides an overview of the site's content and navigation to other sections. It can display featured content, recent activity, or other summary information. The index URL is usually mapped to the root path ('/').",
    "code": "def index(request):\n    return render(request, 'index.html')"
  },
  {
    "title": "Django 404 Template",
    "note": "A custom 404 template is displayed when a page is not found. Create a 404.html template in your templates directory. Django will use this template instead of the default 404 page when DEBUG is False. The template can be styled to match your site's design and provide helpful navigation options. For development (DEBUG=True), Django shows detailed error pages instead.",
    "code": "404.html template in templates folder"
  },
  {
    "title": "Add Test View",
    "note": "A test view is a simple view used to verify that Django is working correctly. It typically returns a basic HttpResponse with a success message. Test views are useful during development to check URL configurations, view functionality, and basic setup. They can be removed or replaced with actual functionality once development progresses.",
    "code": "def test(request):\n    return HttpResponse('Test Successful')"
  },
  {
    "title": "Django Admin",
    "note": "Django's admin interface is a powerful built-in feature for managing database content. It provides a web-based interface for CRUD operations on models. The admin is highly customizable through ModelAdmin classes. It includes authentication, permissions, and auditing features. The admin is intended for site administrators, not end users.",
    "code": "python manage.py createsuperuser"
  },
  {
    "title": "Create User",
    "note": "Users can be created programmatically using User.objects.create_user() or through the admin interface. create_user() handles password hashing and validation. User creation typically includes username, email, and password. Additional user profile information can be stored in a related model. The admin interface provides forms for user creation and management.",
    "code": "User.objects.create_user('username', 'email', 'password')"
  },
  {
    "title": "Include Models",
    "note": "Models must be registered with the admin site to appear in the admin interface. This is done in admin.py using admin.site.register(Model). For more control, create a ModelAdmin class and register it with admin.site.register(Model, ModelAdmin). Registration makes the model available for CRUD operations in the admin.",
    "code": "admin.site.register(Member)"
  },
  {
    "title": "Set List Display",
    "note": "list_display in ModelAdmin controls which fields are shown in the admin list view. It can include model fields, methods, or even fields from related models. list_display improves usability by showing relevant information without needing to open each record. It can be combined with list_display_links to make fields clickable for editing.",
    "code": "class MemberAdmin(admin.ModelAdmin):\n    list_display = ('name', 'email')"
  },
  {
    "title": "Update Members",
    "note": "Members can be updated through the admin interface by clicking on a member in the list view and editing the form. Changes are saved when the form is submitted. Programmatic updates use model instance modification and save(). Bulk updates can be done using queryset.update() for efficiency. Admin actions can be defined for custom bulk operations.",
    "code": "Edit directly in Django admin UI"
  },
  {
    "title": "Add Members",
    "note": "New members can be added through the admin 'Add' button or programmatically using Model.objects.create() or instance.save(). The admin provides forms with validation based on model field definitions. Programmatic creation is useful for imports, migrations, or automated processes. Forms can be customized for specific creation workflows.",
    "code": "Forms or admin panel input"
  },
  {
    "title": "Delete Members",
    "note": "Members can be deleted through the admin interface using the delete action or programmatically using instance.delete() or queryset.delete(). Admin deletions show a confirmation page and can handle related objects. Programmatic deletion immediately removes records. Soft delete patterns (using a is_active field) are often preferred over physical deletion.",
    "code": "member.delete()"
  },
  {
    "title": "Django Syntax",
    "note": "Django template syntax includes variables {{ var }}, tags {% tag %}, and filters {{ var|filter }}. Variables output values, tags control logic and flow, and filters transform variables. The syntax is designed to be simple for designers while powerful for developers. It automatically escapes HTML for security unless explicitly marked as safe.",
    "code": "{% if user.is_authenticated %}Welcome, {{ user.username }}{% endif %}"
  },
  {
    "title": "Django Variables",
    "note": "Template variables are surrounded by double braces {{ variable }}. They output the value of variables from the context. Variables can be attributes ({{ user.username }}) or dictionary lookups ({{ dict.key }}). If a variable doesn't exist, it outputs nothing (or the TEMPLATE_STRING_IF_INVALID setting). Variables are automatically HTML-escaped for security.",
    "code": "{{ variable_name }}"
  },
  {
    "title": "Django Tags",
    "note": "Template tags are surrounded by {% tag %} and control template logic. They can create variables, perform loops, conditionals, and include other templates. Tags can take parameters. Common tags include {% for %}, {% if %}, {% block %}, {% extends %}, {% include %}, and {% url %}. Custom tags can be created for reusable functionality.",
    "code": "{% for item in list %}{{ item }}{% endfor %}"
  },
  {
    "title": "Django If Else",
    "note": "The {% if %} tag evaluates a condition and outputs content if true. {% elif %} and {% else %} provide alternative conditions. Conditions can use comparison operators (==, !=, <, >, <=, >=), logical operators (and, or, not), and filters. {% if %} tags can be nested. The condition syntax is similar to Python but without parentheses for complex expressions.",
    "code": "{% if user.is_staff %}Admin{% else %}User{% endif %}"
  },
  {
    "title": "Django For Loop",
    "note": "The {% for %} tag iterates over items in a sequence. It exposes loop variables like forloop.counter, forloop.first, forloop.last. {% empty %} provides content when the sequence is empty. The loop variable changes scope within the loop. for tags can be nested. Reverse iteration is possible with the reversed modifier.",
    "code": "{% for member in members %}{{ member.name }}{% endfor %}"
  },
  {
    "title": "Django Comment",
    "note": "Template comments are surrounded by {# #} and are not included in the output. They are useful for documentation or temporarily disabling template code. Comments can span multiple lines. Unlike HTML comments, Django comments are completely removed during template rendering and are not visible in the page source.",
    "code": "{# This is a comment #}"
  },
  {
    "title": "Django Include",
    "note": "The {% include %} tag inserts another template's content into the current template. It's useful for reusable components like headers, footers, or navigation. The included template has access to the current context. Variables can be passed to the included template with the with keyword. include is simpler than inheritance for reusable snippets.",
    "code": "{% include 'navbar.html' %}"
  },
  {
    "title": "QuerySet Introduction",
    "note": "A QuerySet represents a collection of objects from the database. It's lazy (not evaluated until needed) and chainable. QuerySets are created from model managers (e.g., Model.objects.all()) and can be filtered, ordered, and sliced. They translate to SQL queries and provide a Pythonic interface to database operations. Understanding QuerySets is key to efficient database access in Django.",
    "code": "members = Member.objects.all()"
  },
  {
    "title": "QuerySet Get",
    "note": "get() returns a single object matching the given lookup parameters. It raises Model.DoesNotExist if no object is found and Model.MultipleObjectsReturned if more than one matches. get() is used when you expect exactly one result. It immediately executes the database query. get() is not chainable like filter() - it returns an object, not a QuerySet.",
    "code": "member = Member.objects.get(id=1)"
  },
  {
    "title": "QuerySet Filter",
    "note": "filter() returns a QuerySet containing objects that match the given lookup parameters. Multiple parameters are joined with AND. filter() is chainable and lazy. Field lookups (e.g., field__exact, field__contains, field__gte) provide powerful filtering. exclude() is the opposite of filter(). Complex queries can use Q objects for OR conditions.",
    "code": "members = Member.objects.filter(age__gte=18)"
  },
  {
    "title": "QuerySet Order By",
    "note": "order_by() returns a QuerySet ordered by the specified fields. Fields can be prefixed with - for descending order. Multiple fields can be specified for secondary ordering. order_by() affects the SQL ORDER BY clause. The default ordering can be set in the model's Meta class. order_by() is chainable and can be called multiple times to change ordering.",
    "code": "members = Member.objects.order_by('name')"
  },
  {
    "title": "Static Files",
    "note": "Static files are CSS, JavaScript, images, and other non-dynamic files. Django collects static files from apps into a single location for serving. The STATIC_URL setting defines the base URL for static files. During development, Django can serve static files; in production, a web server or CDN should serve them. WhiteNoise is a popular option for serving static files in production.",
    "code": "STATIC_URL = '/static/'"
  },
  {
    "title": "Add Static Files",
    "note": "Static files are placed in a static/ directory within each app. They can be organized into subdirectories like css/, js/, img/. The collectstatic command gathers all static files into STATIC_ROOT. In templates, use the {% static %} tag to generate URLs for static files. App-specific static files help keep assets organized with their respective functionality.",
    "code": "Place files in static/ directory"
  },
  {
    "title": "Install WhiteNoise",
    "note": "WhiteNoise allows Django to serve static files in production efficiently. Install it with pip install whitenoise. Add WhiteNoise to MIDDLEWARE in settings.py. WhiteNoise compresses files and sets caching headers automatically. It's a simple solution for serving static files without configuring a separate web server, though for high-traffic sites, a CDN is still recommended.",
    "code": "pip install whitenoise"
  },
  {
    "title": "Collect Static Files",
    "note": "The collectstatic management command copies all static files from app static/ directories and any other locations specified in STATICFILES_DIRS to STATIC_ROOT. This is necessary for production deployment to gather all static files in one place. collectstatic should be run after any static file changes. The --noinput option prevents prompts during deployment.",
    "code": "python manage.py collectstatic"
  },
  {
    "title": "Add Global Static Files",
    "note": "Global static files (used across multiple apps) can be placed in directories listed in STATICFILES_DIRS. These are collected into STATIC_ROOT along with app static files. In templates, use {% static 'path/to/file' %} to reference static files. The static template tag generates the correct URL based on STATIC_URL setting.",
    "code": "<link rel=\"stylesheet\" href=\"{% static 'css/style.css' %}\">"
  },
  {
    "title": "Add Styles to the Project",
    "note": "CSS styles are added by creating CSS files in static/css/ directories and linking them in templates using the {% static %} tag. Styles can be app-specific or global. CSS frameworks like Bootstrap can be included for responsive design. Django's template inheritance makes it easy to maintain consistent styles across pages through base templates.",
    "code": "Use CSS files linked in templates"
  },
  {
    "title": "PostgreSQL Intro",
    "note": "PostgreSQL is a powerful open-source relational database that can be used as Django's backend. It offers advanced features like JSON support, full-text search, and geographic objects. To use PostgreSQL, install psycopg2 (pip install psycopg2-binary) and configure DATABASES in settings.py with PostgreSQL connection parameters. PostgreSQL is often preferred for production Django deployments due to its robustness and feature set.",
    "code": "Set DATABASES in settings.py for PostgreSQL"
  },
  {
    "title": "Create AWS Account",
    "note": "AWS (Amazon Web Services) provides cloud computing services. Creating an AWS account is the first step to using services like RDS (Relational Database Service), EC2 (Elastic Compute Cloud), and Elastic Beanstalk. The account requires a credit card but offers a free tier for new users. AWS provides a web console and CLI for managing resources.",
    "code": "# Use AWS console to create account"
  },
  {
    "title": "Create Database in RDS",
    "note": "Amazon RDS provides managed database services. To create a PostgreSQL database, use the AWS RDS console: choose PostgreSQL engine, specify instance size, storage, and credentials. RDS handles backups, patches, and failures. The database endpoint and connection details are provided after creation. Security groups must be configured to allow connections from your application.",
    "code": "# Use AWS RDS dashboard"
  },
  {
    "title": "Connect to Database",
    "note": "To connect Django to PostgreSQL, set the DATABASES setting with the PostgreSQL backend engine and connection parameters (NAME, USER, PASSWORD, HOST, PORT). For RDS, use the provided endpoint as HOST. Ensure network connectivity (security groups) and that the database user has appropriate privileges. Test the connection with python manage.py check --database default.",
    "code": "DATABASES = {... 'ENGINE': 'django.db.backends.postgresql', ...}"
  },
  {
    "title": "Add Members",
    "note": "After setting up the database, you can add member data through Django's ORM. Use Model.objects.create() or instance.save() to insert records. Data can be added programmatically, through the admin interface, or via management commands. Initial data can be loaded using fixtures or data migrations. Ensure the database user has INSERT privileges.",
    "code": "Member.objects.create(name='Alice')"
  },
  {
    "title": "Deploy Django",
    "note": "Deploying Django involves moving your application to a production environment. This typically includes setting up a production database, configuring static file serving, setting DEBUG=False, configuring allowed hosts, and using a production WSGI server like Gunicorn. Deployment options include platforms like Heroku, AWS Elastic Beanstalk, or manual server setup. Each environment has specific configuration requirements.",
    "code": "Use Elastic Beanstalk or other platforms"
  },
  {
    "title": "Elastic Beanstalk (EB)",
    "note": "AWS Elastic Beanstalk is a platform-as-a-service that simplifies Django deployment. It automatically handles capacity provisioning, load balancing, scaling, and application health monitoring. Use the EB CLI (pip install awsebcli) to create environments, deploy updates, and manage your application. EB supports configuration files (.ebextensions) for custom setup.",
    "code": "# eb init\n# eb create\n# eb deploy"
  },
  {
    "title": "Create requirements.txt",
    "note": "requirements.txt lists all Python dependencies for your project. Generate it with pip freeze > requirements.txt. Elastic Beanstalk uses this file to install dependencies during deployment. Keep requirements.txt updated as you add packages. For production, consider using pip-compile from pip-tools to generate pinned versions for reproducibility.",
    "code": "pip freeze > requirements.txt"
  },
  {
    "title": "Create django.config",
    "note": "Elastic Beanstalk uses .config files in the .ebextensions directory for configuration. These YAML files can set environment variables, run commands, and configure the environment. For Django, you might need to set DJANGO_SETTINGS_MODULE, run collectstatic, or set up database connections. .config files are applied during environment creation and updates.",
    "code": "# Configuration files inside .ebextensions"
  },
  {
    "title": "Create .zip File",
    "note": "For Elastic Beanstalk deployment, your application code needs to be packaged into a .zip file. The zip should include all source code, requirements.txt, and any necessary configuration files. Exclude virtual environment, __pycache__, and other unnecessary files. The EB CLI can handle packaging automatically when using eb deploy.",
    "code": "zip -r project.zip myproject/"
  },
  {
    "title": "Deploy with EB",
    "note": "Deploy to Elastic Beanstalk using the EB CLI: eb deploy. This packages your application, uploads it to AWS, and deploys it to your environment. EB handles the deployment process, including updating instances and health checks. View deployment logs with eb logs. The environment URL is shown with eb status.",
    "code": "eb deploy"
  },
  {
    "title": "Update Project",
    "note": "To update your deployed application, make changes to your code, test locally, then run eb deploy again. Elastic Beanstalk performs a rolling update by default to minimize downtime. For database schema changes, you may need to run migrations separately (e.g., using eb ssh to access instances and run manage.py migrate).",
    "code": "Edit code, then eb deploy again"
  },
  {
    "title": "Add Slug Field",
    "note": "Slug fields store URL-friendly versions of strings, typically using lowercase letters, numbers, and hyphens. They are useful for SEO-friendly URLs. Django's SlugField validates that the value contains only letters, numbers, underscores, or hyphens. Slugs are often automatically generated from another field (e.g., title) using prepopulated_fields in admin or signals. Unique slugs ensure each URL is distinct.",
    "code": "slug = models.SlugField(unique=True)"
  },
  {
    "title": "Add Bootstrap 5",
    "note": "Bootstrap 5 is a popular CSS framework for responsive design. Include it in your templates by adding the Bootstrap CSS and JS CDN links or by downloading the files to your static directory. Bootstrap provides a grid system, components, and utilities for building modern web interfaces. Django templates can use Bootstrap classes alongside Django template logic.",
    "code": "Include Bootstrap CSS & JS in templates"
  },
  {
    "title": "Template Tag Reference",
    "note": "Django provides numerous built-in template tags for control flow, template inheritance, internationalization, and more. Common tags include {% block %}, {% extends %}, {% include %}, {% for %}, {% if %}, {% url %}, {% with %}, and {% load %}. The full reference is in Django documentation, showing syntax, parameters, and examples for each tag.",
    "code": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/"
  },
  {
    "title": "Filter Reference",
    "note": "Template filters transform variables in templates. Built-in filters include date (format dates), length (get length), lower (convert to lowercase), truncatewords (shorten text), and many more. Filters are applied with | syntax: {{ value|filter }}. Filters can take arguments: {{ value|filter:arg }}. Custom filters can be created for project-specific transformations.",
    "code": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/"
  },
  {
    "title": "Field lookups Reference",
    "note": "Field lookups are used in QuerySet filters to specify how fields should be matched. Common lookups include exact, iexact (case-insensitive), contains, icontains, in, gt (greater than), gte (greater than or equal), lt (less than), lte, startswith, istartswith, endswith, iendswith, range, isnull, and regex. Lookups are used with double underscore syntax: field__lookup.",
    "code": "https://docs.djangoproject.com/en/stable/ref/models/querysets/#field-lookups"
  },
  {
    "title": "Django Exercises",
    "note": "Practice exercises help solidify Django concepts. Exercises might include creating models for specific domains, building CRUD interfaces, implementing user authentication, creating REST APIs with Django REST framework, or optimizing database queries. Practical projects like a blog, todo app, or e-commerce site provide comprehensive learning experiences.",
    "code": "# Write apps, views, and templates"
  },
  {
    "title": "Django Compiler",
    "note": "The Django shell (python manage.py shell) is an interactive Python environment with Django settings configured. It's useful for testing code snippets, exploring the ORM, and debugging. IPython or bpython can be used for enhanced shell experiences. The shell automatically imports django.setup() and provides access to your models and other Django utilities.",
    "code": "python manage.py shell"
  },
  {
    "title": "Django Quiz",
    "note": "Quizzes test understanding of Django concepts like MTV architecture, ORM, templates, forms, and security. They can include multiple-choice questions, code analysis, and problem-solving scenarios. Regular quizzing helps identify knowledge gaps and reinforce learning. Many online tutorials and courses include quizzes as part of their curriculum.",
    "code": "# Sample questions on Django concepts"
  },
  {
    "title": "Django Syllabus",
    "note": "A structured syllabus outlines the learning path for Django, typically covering: setup and project structure, models and database, views and URLs, templates and static files, forms and validation, user authentication, admin interface, deployment, and advanced topics like REST APIs, caching, and performance optimization. A good syllabus progresses from fundamentals to complex applications.",
    "code": "# Topics and goals"
  },
  {
    "title": "Django Study Plan",
    "note": "A study plan organizes Django learning into manageable segments. A typical plan might allocate: 1-2 weeks for fundamentals (models, views, templates), 1 week for forms and admin, 1 week for user authentication, 1-2 weeks for deployment and advanced topics, and 2-3 weeks for a capstone project. The plan should balance theory with hands-on coding and include time for review and practice.",
    "code": "# Daily/weekly study tasks"
  },
  {
    "title": "Django Server",
    "note": "The Django development server (python manage.py runserver) runs a lightweight web server for development and testing. It automatically reloads on code changes, making development efficient. The server is not suitable for production due to performance and security limitations. It runs on http://127.0.0.1:8000 by default, but the host and port can be specified.",
    "code": "python manage.py runserver"
  },
  {
    "title": "Django Certificate",
    "note": "Django certifications validate expertise in Django development. While Django itself doesn't offer official certifications, various online platforms and training providers offer certificates for completing Django courses. These can demonstrate proficiency to employers. Building a portfolio of Django projects is often more valuable than certificates for showing practical skills.",
    "code": "# Info about certifications"
  }

],
typescript: 
  [

  {
    "title": "TS HOME",
    "note": "TypeScript is an open-source programming language developed by Microsoft that builds on JavaScript by adding static type definitions. It is a superset of JavaScript, meaning any valid JavaScript code is also valid TypeScript code. TypeScript compiles to plain JavaScript and can be used to develop large-scale applications with better tooling, error checking, and maintainability. It introduces features like interfaces, generics, and enums, which are not present in JavaScript, making it especially valuable for enterprise-level projects and teams.",
    "code": "// Official site: https://www.typescriptlang.org/"
  },
  {
    "title": "TS Introduction",
    "note": "TypeScript enhances JavaScript by adding static types, which help catch errors during development rather than at runtime. Key benefits include improved code quality and readability, better IDE support with autocompletion and refactoring tools, and easier maintenance of large codebases. TypeScript's type system is optional, allowing developers to gradually adopt types in existing JavaScript projects. It supports modern ECMAScript features and compiles to clean, readable JavaScript that works across all browsers and platforms.",
    "code": "let message: string = 'Hello, TypeScript!';"
  },
  {
    "title": "TS Get Started",
    "note": "To start using TypeScript, install it globally via npm with `npm install -g typescript`. Create a `.ts` file and write TypeScript code. Compile it to JavaScript using the TypeScript compiler (`tsc filename.ts`), which generates a `.js` file. For larger projects, create a `tsconfig.json` file to configure compiler options. Most modern code editors like VS Code provide excellent TypeScript support out of the box, including real-time error checking and IntelliSense.",
    "code": "npm install -g typescript\ntsc hello.ts"
  },
  {
    "title": "TS Simple Types",
    "note": "TypeScript provides basic primitive types that correspond to JavaScript primitives: `string` for textual data, `number` for both integers and floating-point values, `boolean` for true/false values, and `void` to indicate the absence of a value (commonly used as a function return type). Type annotations are added using a colon followed by the type. These simple types help prevent common errors like assigning wrong value types to variables.",
    "code": "let isDone: boolean = false;\nlet count: number = 10;\nlet name: string = 'Alice';"
  },
  {
    "title": "TS Special Types",
    "note": "TypeScript includes several special types: `any` disables type checking, allowing values of any type; `unknown` is a type-safe alternative to `any` that requires type checks before use; `never` represents values that never occur (e.g., functions that always throw an error or never return); `void` indicates a function doesn't return a value. These types provide flexibility in specific scenarios while maintaining type safety where possible.",
    "code": "let value: any = 5;\nfunction error(message: string): never {\n  throw new Error(message);\n}"
  },
  {
    "title": "TS Arrays",
    "note": "Arrays in TypeScript can be typed in two ways: using the element type followed by square brackets (`number[]`) or using the generic array type (`Array<number>`). Both syntaxes ensure all array elements are of the specified type. Typed arrays prevent adding incorrect types to the array and provide better IntelliSense for array methods. TypeScript also supports read-only arrays using the `ReadonlyArray<T>` type or `readonly` modifier.",
    "code": "let list: number[] = [1, 2, 3];"
  },
  {
    "title": "TS Tuples",
    "note": "Tuples allow you to express an array with a fixed number of elements where each element has a known and specific type. The types of elements are known and don't have to be the same. Tuples are useful when you need to work with a fixed structure of multiple values, such as representing a key-value pair or coordinates. TypeScript enforces the length and type of each position in the tuple at compile time.",
    "code": "let tuple: [string, number] = ['hello', 10];"
  },
  {
    "title": "TS Object Types",
    "note": "TypeScript allows you to define the shape of objects using type annotations. You can specify the names and types of an object's properties using inline type annotations or separate interface/type definitions. Object types enforce that objects have the specified properties with the correct types. Optional properties can be marked with `?`, and readonly properties can be marked with `readonly`. This helps catch typos and type mismatches in object structures.",
    "code": "let person: { name: string; age: number } = { name: 'Bob', age: 25 };"
  },
  {
    "title": "TS Enums",
    "note": "Enums allow you to define a set of named constants. TypeScript provides both numeric and string-based enums. Numeric enums auto-increment their values, while string enums must be initialized with string values. Enums make code more readable by giving meaningful names to sets of numeric or string values. They compile to JavaScript objects and can be used to create bidirectional mappings between enum names and values.",
    "code": "enum Color { Red, Green, Blue }\nlet c: Color = Color.Green;"
  },
  {
    "title": "TS Aliases & Interfaces",
    "note": "Type aliases (`type`) and interfaces (`interface`) are two ways to name object types or other types. Interfaces are primarily used for object shapes and can be extended or implemented by classes. Type aliases can represent not only object types but also unions, tuples, and primitives. Both can describe functions and use generics. Interfaces are generally preferred for object shapes as they are more extensible, while type aliases are more flexible for complex type compositions.",
    "code": "type Point = { x: number; y: number };\ninterface User { id: number; name: string; }"
  },
  {
    "title": "TS Union Types",
    "note": "Union types allow a variable to hold values of multiple types. They are specified using the `|` operator between types. TypeScript will only allow operations that are valid for every type in the union unless you use type guards to narrow the type. Union types are useful for functions that can accept multiple types of parameters or variables that can hold different types of values at different times. They provide flexibility while maintaining type safety.",
    "code": "let value: string | number = 5;\nvalue = 'hello';"
  },
  {
    "title": "TS Functions",
    "note": "TypeScript allows you to add type annotations to function parameters and return types. This helps ensure functions are called with the correct argument types and return the expected type. Function types can be described using call signatures. TypeScript supports optional parameters, default parameters, and rest parameters with type checking. Function overloading is also supported by providing multiple function signatures followed by a single implementation.",
    "code": "function add(x: number, y: number): number {\n  return x + y;\n}"
  },
  {
    "title": "TS Casting",
    "note": "Type casting (also called type assertion) tells the TypeScript compiler to treat a value as a specific type. This is useful when you know more about the type of a value than TypeScript can infer. There are two syntaxes: angle-bracket syntax (`<string>value`) and `as` syntax (`value as string`). Type assertions are a way to override the compiler's type system and should be used carefully, as incorrect assertions can lead to runtime errors.",
    "code": "let someValue: any = 'this is a string';\nlet strLength: number = (someValue as string).length;"
  },
  {
    "title": "TS Classes",
    "note": "TypeScript enhances JavaScript classes with type annotations for properties, method parameters, and return types. Classes can implement interfaces to ensure they meet specific contracts. TypeScript adds access modifiers (`public`, `private`, `protected`) to control property visibility, `readonly` modifier for immutable properties, and abstract classes for defining base classes that can't be instantiated. These features make object-oriented programming in TypeScript more robust and maintainable.",
    "code": "class Person {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}"
  },
  {
    "title": "TS Basic Generics",
    "note": "Generics allow you to create reusable components that can work with multiple types while maintaining type safety. They enable you to parameterize types, making components flexible without sacrificing type checking. Generic functions, interfaces, and classes can work with any type while preserving information about the relationships between input and output types. Generics are widely used in TypeScript for collections, utility functions, and React components.",
    "code": "function identity<T>(arg: T): T {\n  return arg;\n}"
  },
  {
    "title": "TS Utility Types",
    "note": "TypeScript provides several built-in utility types that facilitate common type transformations. `Partial<T>` makes all properties of T optional, `Readonly<T>` makes all properties readonly, `Pick<T, K>` selects a subset of properties from T, and `Record<K, T>` creates an object type with properties of type T. These utility types help manipulate existing types to create new types without redeclaring them, reducing code duplication and improving maintainability.",
    "code": "type PartialUser = Partial<User>;"
  },
  {
    "title": "TS Keyof",
    "note": "The `keyof` operator takes an object type and produces a union of its keys. This is useful for creating type-safe functions that operate on object properties. Combined with indexed access types (`T[K]`), it allows you to express relationships between object keys and their value types. `keyof` is commonly used in generic constraints, mapped types, and when writing utility functions that need to work with object properties in a type-safe manner.",
    "code": "type UserKeys = keyof User; // 'id' | 'name'"
  },
  {
    "title": "TS Null",
    "note": "TypeScript has two special types, `null` and `undefined`, that represent the absence of a value. With strict null checks enabled (recommended), you must explicitly handle null and undefined values. Union types are used to indicate that a value might be null or undefined (e.g., `string | null`). Optional chaining (`?.`) and nullish coalescing (`??`) operators help safely work with potentially null/undefined values. This prevents common null reference errors.",
    "code": "let name: string | null = null;"
  },
  {
    "title": "TS Definitely Typed",
    "note": "Definitely Typed is a repository of high-quality TypeScript type definitions for thousands of JavaScript libraries. These type definitions allow you to use popular JavaScript libraries in TypeScript projects with full type safety and IntelliSense support. Type definitions are installed using npm with the `@types/` prefix (e.g., `@types/lodash`). Definitely Typed is community-maintained and provides type definitions for most major JavaScript libraries.",
    "code": "npm install --save-dev @types/lodash"
  },
  {
    "title": "TS 5 Updates",
    "note": "TypeScript 5 introduced several significant improvements: the new `moduleResolution: 'bundler'` option for better compatibility with modern bundlers, `const` type parameters for more precise inference, `--verbatimModuleSyntax` for cleaner imports and exports, support for ECMAScript decorators, and performance improvements. Each TypeScript release brings new features, optimizations, and better developer experience while maintaining backward compatibility.",
    "code": "// See release notes at https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html"
  },
  {
    "title": "TS Editor",
    "note": "Visual Studio Code is the recommended editor for TypeScript development, as it provides excellent built-in support. Key features include real-time error checking, IntelliSense (autocompletion, parameter info, quick info), refactoring tools, go-to definition, and find all references. The TypeScript extension can be configured with specific version settings and offers powerful debugging capabilities. Other editors like WebStorm also provide strong TypeScript support.",
    "code": "// Enable TypeScript extension in VSCode for autocompletion and error checking."
  },
  {
    "title": "TS Exercises",
    "note": "Practice is essential for mastering TypeScript. Exercises should cover: basic type annotations, function typing, interface and type alias creation, working with arrays and tuples, using generics, and applying advanced types. Building small projects like a todo app, calculator, or data processing utilities helps reinforce concepts. Many online platforms offer TypeScript coding challenges and interactive exercises.",
    "code": "// Build functions, classes, and interfaces with proper typings."
  },
  {
    "title": "TS Quiz",
    "note": "Quizzes help test your understanding of TypeScript concepts including type inference, type compatibility, generics, utility types, and advanced type manipulation. They can include multiple-choice questions, code analysis exercises, and type prediction challenges. Regular quizzing identifies knowledge gaps and reinforces learning. Many TypeScript tutorials and courses include quizzes as part of their curriculum.",
    "code": "// Multiple choice questions on types, interfaces, generics, and more."
  },
  {
    "title": "TS Syllabus",
    "note": "A comprehensive TypeScript syllabus should cover: basic types and type annotations, functions and function types, interfaces and type aliases, classes and OOP features, generics, modules and namespaces, type manipulation (utility types, conditional types, mapped types), compiler configuration, and integration with JavaScript libraries. The syllabus should progress from fundamentals to advanced topics with practical projects.",
    "code": "// Plan includes all core concepts and practice projects."
  },
  {
    "title": "TS Study Plan",
    "note": "An effective TypeScript study plan typically spans 4-8 weeks: Week 1-2: Fundamentals (types, functions, basic interfaces), Week 3-4: Intermediate topics (classes, generics, modules), Week 5-6: Advanced types (utility types, conditional types, type guards), Week 7-8: Practical application (projects, testing, build tools). Daily practice should include both learning concepts and hands-on coding. The plan should be adaptable based on progress.",
    "code": "// Daily and weekly goals for effective learning."
  },
  {
    "title": "TS Certificate",
    "note": "While there are no official TypeScript certifications from Microsoft, several online platforms offer TypeScript certificates for completing their courses. These certificates demonstrate proficiency in TypeScript development and can be valuable for career advancement. However, practical experience and a portfolio of TypeScript projects are often more important to employers than certificates. Popular learning platforms like Coursera, Udemy, and freeCodeCamp offer TypeScript courses with certificates.",
    "code": "// Info about online courses and exams."
  }

],
AngularJS: 
  [
  
  {
    "title": "AngularJS HOME",
    "note": "AngularJS is a structural framework for building dynamic web applications, developed and maintained by Google. It extends HTML's syntax to express application components clearly and succinctly, using the Model-View-Controller (MVC) architecture. AngularJS simplifies both development and testing by providing framework for client-side model–view–controller (MVC) and model–view–viewmodel (MVVM) architectures. Though largely superseded by newer Angular versions, AngularJS remains important for maintaining legacy applications.",
    "code": "// Official site: https://angularjs.org/"
  },
  {
    "title": "AngularJS Intro",
    "note": "AngularJS introduces several key concepts: two-way data binding automatically synchronizes data between model and view, dependency injection manages component dependencies, directives extend HTML with custom behavior, and MVC architecture separates concerns. The framework is designed to make front-end development more structured and testable. AngularJS applications are declared using the ng-app directive and typically consist of modules, controllers, and templates that work together.",
    "code": "<div ng-app=\"\" ng-init=\"name='AngularJS'\">{{name}}</div>"
  },
  {
    "title": "AngularJS Expressions",
    "note": "AngularJS expressions are JavaScript-like code snippets enclosed in double curly braces {{ }} that are evaluated against the current scope. They can contain literals, variables, and operators, but unlike JavaScript expressions, they are forgiving of undefined and null values. Expressions are used to bind application data to HTML and can include filters to format the output. They are re-evaluated whenever the underlying data changes, enabling dynamic updates.",
    "code": "{{ 5 + 5 }} <!-- Outputs: 10 -->"
  },
  {
    "title": "AngularJS Modules",
    "note": "Modules are containers for different parts of an AngularJS application, helping to organize code into cohesive blocks of functionality. A module defines an application and can depend on other modules. The angular.module() function is used to create or retrieve modules. Modules help in managing dependencies, making code more testable and maintainable. All controllers, services, directives, and filters must belong to a module.",
    "code": "var app = angular.module('myApp', []);"
  },
  {
    "title": "AngularJS Directives",
    "note": "Directives are markers on DOM elements that tell AngularJS's HTML compiler to attach specified behavior to that element or transform the DOM. Built-in directives include ng-model for two-way binding, ng-repeat for looping, ng-show/ng-hide for conditional display, and ng-click for event handling. Custom directives can be created to extend HTML vocabulary, encapsulating complex DOM manipulation and behavior into reusable components.",
    "code": "<div ng-show=\"isVisible\">This is visible</div>"
  },
  {
    "title": "AngularJS Model",
    "note": "The ng-model directive binds the value of HTML controls (input, select, textarea) to application data, providing two-way data binding. When the user changes the value in the control, the model updates, and vice versa. ng-model also provides validation and state management (pristine, dirty, valid, invalid) for form controls. It's one of the most important directives for creating interactive forms and user inputs.",
    "code": "<input ng-model=\"username\"> Hello, {{username}}"
  },
  {
    "title": "AngularJS Data Binding",
    "note": "Two-way data binding is a core feature of AngularJS that automatically synchronizes data between the model and view components. When data in the model changes, the view reflects the change, and when data in the view changes (through user input), the model is updated. This eliminates much of the boilerplate code needed to manually update the DOM or listen for DOM events, making applications more responsive and easier to develop.",
    "code": "<input ng-model=\"age\"> Age is {{age}}"
  },
  {
    "title": "AngularJS Controllers",
    "note": "Controllers are JavaScript functions that provide the business logic for AngularJS applications. They are responsible for setting up the initial state of the $scope object and adding behavior to it. Controllers are attached to the DOM via the ng-controller directive. They should contain only business logic, not DOM manipulation, which should be handled by directives. Controllers are instantiated for each occurrence in the DOM.",
    "code": "app.controller('MyCtrl', function($scope) { $scope.greet = 'Hello'; });"
  },
  {
    "title": "AngularJS Scopes",
    "note": "Scopes are JavaScript objects that serve as the glue between controllers and views. They provide the execution context for expressions and act as data models. Scopes are arranged in a hierarchical structure that mirrors the DOM hierarchy, supporting inheritance. The $rootScope is the top-most scope, with child scopes created for controllers and some directives. Scopes propagate events and watch for expressions changes.",
    "code": "$scope.message = 'Welcome!';"
  },
  {
    "title": "AngularJS Filters",
    "note": "Filters format the value of expressions for display to the user. They can be used in templates, controllers, or services. Built-in filters include currency, date, filter (for arrays), json, limitTo, lowercase, number, orderBy, and uppercase. Filters can be chained and can take arguments. Custom filters can be created for application-specific formatting needs.",
    "code": "{{ amount | currency }}"
  },
  {
    "title": "AngularJS Services",
    "note": "Services are singleton objects that carry out specific tasks common to web applications. AngularJS provides built-in services like $http for server communication, $route for routing, and $location for URL handling. Custom services can be created using service, factory, or provider methods. Services are injected into controllers, filters, directives, and other services using dependency injection, promoting reusability and testability.",
    "code": "app.service('myService', function() { this.data = 'Service Data'; });"
  },
  {
    "title": "AngularJS Http",
    "note": "The $http service is AngularJS's core service for communicating with remote HTTP servers. It supports all HTTP methods (GET, POST, PUT, DELETE, etc.) and returns promises that are resolved with the response data or rejected with error information. $http provides request and response transformation, authentication, and request cancellation. It simplifies AJAX calls and integrates with AngularJS's digest cycle for automatic UI updates.",
    "code": "$http.get('/api/data').then(response => { $scope.data = response.data; });"
  },
  {
    "title": "AngularJS Tables",
    "note": "AngularJS makes displaying data in tables dynamic and interactive. The ng-repeat directive is used to generate table rows for each item in a collection. Additional features like sorting (using orderBy filter), filtering (using filter filter), and pagination can be easily added. Table rows can respond to user interactions through event directives, making complex data tables manageable with minimal code.",
    "code": "<tr ng-repeat=\"item in items\"><td>{{item.name}}</td></tr>"
  },
  {
    "title": "AngularJS Select",
    "note": "The select element is enhanced in AngularJS through the ng-options directive, which provides a powerful way to generate options from an array or object. ng-options offers better performance and more features than ng-repeat with option elements. It supports option groups, tracking by object identity (to avoid unnecessary DOM updates), and proper handling of non-primitive values. ng-model binds the selected value to the model.",
    "code": "<select ng-model=\"selected\" ng-options=\"item for item in items\"></select>"
  },
  {
    "title": "AngularJS SQL",
    "note": "While AngularJS itself doesn't directly interact with SQL databases (as it's a client-side framework), it commonly works with server-side APIs that perform SQL operations. The $http service is used to send requests to these APIs, which then execute SQL queries and return results. AngularJS applications typically follow this pattern to maintain separation of concerns and security (preventing direct database access from the client).",
    "code": "// Typically handled via HTTP requests to server-side SQL APIs."
  },
  {
    "title": "AngularJS DOM",
    "note": "AngularJS provides a declarative approach to DOM manipulation through directives rather than imperative JavaScript. Directives like ng-show, ng-hide, ng-class, and ng-style manipulate DOM elements based on model state. For complex DOM manipulation, custom directives should be created. This approach keeps DOM manipulation code encapsulated and testable, separate from application logic in controllers.",
    "code": "ng-click=\"doSomething()\""
  },
  {
    "title": "AngularJS Events",
    "note": "AngularJS provides directives to handle various DOM events such as clicks, mouse movements, key presses, and form events. These include ng-click, ng-dblclick, ng-mouseenter, ng-keypress, and many others. Event directives can call controller functions and pass parameters. The $event object is available in event handlers, providing access to the original DOM event. Events are integrated with AngularJS's digest cycle for automatic updates.",
    "code": "<button ng-click=\"alert('Clicked!')\">Click me</button>"
  },
  {
    "title": "AngularJS Forms",
    "note": "AngularJS enhances HTML forms with powerful features including data binding, validation, and state tracking. The ng-model directive binds form controls to model properties. Forms and controls have properties that reflect their state (pristine, dirty, valid, invalid, etc.). AngularJS provides CSS classes corresponding to these states for styling. Forms can be named and referenced in the scope for validation purposes.",
    "code": "<form name=\"myForm\"><input ng-model=\"user.name\" required></form>"
  },
  {
    "title": "AngularJS Validation",
    "note": "AngularJS provides built-in validation for form inputs, leveraging HTML5 validation attributes like required, minlength, maxlength, and pattern. Custom validation can be implemented using directives. Validation state is exposed through form and control properties ($valid, $invalid, $error, etc.) and corresponding CSS classes. Error messages can be displayed conditionally based on validation state, providing user feedback.",
    "code": "<span ng-show=\"myForm.name.$error.required\">Name is required</span>"
  },
  {
    "title": "AngularJS API",
    "note": "AngularJS provides a comprehensive API for extending and customizing framework behavior. Key APIs include the directive API for creating custom directives, the service API for creating services, the filter API for creating filters, and the compile service for manual DOM compilation. The dependency injection API manages component dependencies. Understanding these APIs is essential for advanced AngularJS development and creating reusable components.",
    "code": "// Refer to AngularJS documentation for available APIs."
  },
  {
    "title": "AngularJS W3.CSS",
    "note": "W3.CSS is a modern CSS framework that can be easily integrated with AngularJS applications. It provides responsive design, attractive UI components, and consistent styling across browsers. To use W3.CSS with AngularJS, include the CSS file in your HTML and apply W3.CSS classes to your AngularJS templates. The combination allows for creating stylish, responsive web applications with AngularJS's dynamic capabilities.",
    "code": "<link rel=\"stylesheet\" href=\"https://www.w3schools.com/w3css/4/w3.css\">"
  },
  {
    "title": "AngularJS Includes",
    "note": "The ng-include directive allows including external HTML fragments into templates, promoting code reuse and modularity. It fetches, compiles, and includes the external HTML. The included content has its own scope, which prototypically inherits from the parent scope. ng-include is useful for breaking large templates into manageable pieces, creating reusable components, and dynamically loading content based on application state.",
    "code": "<div ng-include=\"'header.html'\"></div>"
  },
  {
    "title": "AngularJS Animations",
    "note": "The ngAnimate module provides hooks for CSS and JavaScript animations on common directives like ng-repeat, ng-show, ng-hide, and ng-view. Animations are triggered when elements are added, removed, or have their classes changed. CSS transitions, CSS animations, or JavaScript callbacks can be used to create smooth visual effects. ngAnimate simplifies adding animations without complex JavaScript code.",
    "code": "app.animation('.my-animation', function() { /* animation code */ });"
  },
  {
    "title": "AngularJS Routing",
    "note": "The ngRoute module (or more powerful third-party routers like ui-router) enables building single-page applications with multiple views. Routing maps URLs to templates and controllers, allowing navigation without full page reloads. Routes can have parameters, and templates can be loaded asynchronously. Routing helps organize large applications into logical sections and maintains browser history for proper navigation.",
    "code": "app.config(function($routeProvider) { $routeProvider.when('/home', { templateUrl: 'home.html' }); });"
  },
  {
    "title": "AngularJS Application",
    "note": "A complete AngularJS application typically consists of: a main module that depends on feature modules, multiple controllers for different views, services for business logic and data access, directives for reusable components, filters for data formatting, and routing for navigation. The application follows MVC architecture, with clear separation of concerns. Properly structured applications are modular, testable, and maintainable.",
    "code": "// Use modules, controllers, services, and views together."
  },
  {
    "title": "AngularJS Examples",
    "note": "Learning AngularJS is best done through practical examples. Common example projects include: todo applications demonstrating CRUD operations, customer management systems showing form handling and validation, product catalogs with filtering and sorting, and dashboard applications with multiple views and data visualization. These examples illustrate key AngularJS concepts in real-world contexts.",
    "code": "// See official tutorials and GitHub repos."
  },
  {
    "title": "AngularJS Syllabus",
    "note": "A comprehensive AngularJS learning path should cover: fundamentals (expressions, directives, data binding), core concepts (modules, controllers, scopes, dependency injection), built-in services ($http, $route, $filter), forms and validation, custom directives and services, routing, testing, and best practices. The syllabus should progress from simple to complex concepts with hands-on projects at each stage.",
    "code": "// Follow tutorials progressively from basics to advanced."
  },
  {
    "title": "AngularJS Study Plan",
    "note": "An effective AngularJS study plan might allocate: 1 week for fundamentals and basic directives, 1 week for controllers and services, 1 week for forms and validation, 1 week for custom directives, 1 week for routing and advanced topics, and 2 weeks for building a complete application. Daily practice should include both learning concepts and coding exercises. The plan should be flexible based on prior JavaScript experience.",
    "code": "// Plan daily or weekly milestones."
  },
  {
    "title": "AngularJS Certificate",
    "note": "While AngularJS is a legacy framework, some certification programs still validate proficiency in it. Certifications typically cover core concepts, directives, services, testing, and best practices. However, given that AngularJS has reached end-of-life, newer Angular versions are more relevant for current certifications. Practical experience maintaining AngularJS applications may be more valuable than formal certification for most roles.",
    "code": "// Look for online courses and exams."
  },
  {
    "title": "AngularJS Reference",
    "note": "The AngularJS API reference provides detailed documentation for all directives, services, filters, and methods. It includes usage examples, parameters, return values, and related components. The reference is essential for understanding advanced features and edge cases. Despite AngularJS's end-of-life, the documentation remains available for maintaining existing applications. Key sections include directive reference, service reference, and type reference.",
    "code": "// Official docs: https://docs.angularjs.org/api"
  }
],
Git:
[
[
  {
    "title": "Git HOME",
    "note": "Git is a distributed version control system designed to handle everything from small to very large projects with speed and efficiency. It allows multiple developers to work on the same codebase simultaneously without interfering with each other's work. Git tracks changes to files, enables branching and merging, and supports collaborative workflows. Created by Linus Torvalds in 2005 for Linux kernel development, Git has become the standard version control system for software development worldwide.",
    "code": "// Official site: https://git-scm.com/"
  },
  {
    "title": "Git Intro",
    "note": "Git operates through a series of snapshots called commits that record the state of your project at specific points in time. Key concepts include: repositories (storage for project history), commits (snapshots of changes), branches (parallel lines of development), and remotes (remote repositories for collaboration). Git's distributed nature means every developer has a complete copy of the repository, enabling offline work and redundant backup of the project history.",
    "code": "git init"
  },
  {
    "title": "Git Install",
    "note": "Git can be installed on various operating systems: Windows (download from git-scm.com or use Git for Windows), macOS (use Homebrew: brew install git or Xcode Command Line Tools), and Linux (use package managers: apt-get install git for Debian/Ubuntu, yum install git for Red Hat/CentOS). After installation, verify with git --version. GUI tools like GitHub Desktop or GitKraken can also be installed for visual interaction with Git.",
    "code": "// Download from https://git-scm.com/downloads"
  },
  {
    "title": "Git Config",
    "note": "Git configuration is stored at three levels: system (affects all users), global (affects all repositories for current user), and local (affects only the current repository). Common configurations include user identity (name and email), default editor, color output, and alias creation. Configuration is essential for personalizing Git behavior and ensuring proper attribution of commits. Use git config --list to view current settings.",
    "code": "git config --global user.name \"Your Name\"\ngit config --global user.email you@example.com"
  },
  {
    "title": "Git Get Started",
    "note": "To start using Git, initialize a repository with git init in your project directory. Add files to the staging area with git add, then commit them with git commit. The staging area allows you to review changes before committing. Initial commits typically include project structure, README, and basic configuration files. This workflow forms the foundation of all Git operations.",
    "code": "git init\ngit add .\ngit commit -m \"Initial commit\""
  },
  {
    "title": "Git New Files",
    "note": "New files are not tracked by Git until explicitly added. Use git add filename to stage a specific file for the next commit. Files can be added individually or in groups using patterns. The staging area allows you to selectively include changes, enabling partial commits and careful review before creating permanent history. Untracked files remain invisible to Git until added.",
    "code": "git add filename.txt"
  },
  {
    "title": "Git Staging",
    "note": "The staging area (also called index) is where you prepare changes for committing. git add moves changes from the working directory to the staging area. This allows you to craft precise commits by selecting specific changes rather than committing all modifications at once. The staging area can be reviewed with git status and git diff --staged before committing.",
    "code": "git add file1.txt file2.txt"
  },
  {
    "title": "Git Commit",
    "note": "Commits create permanent snapshots of the staged changes. Each commit has a unique hash, author information, timestamp, and descriptive message. Commit messages should be clear and concise, explaining what changed and why. Good commit practices include atomic commits (one logical change per commit), meaningful messages, and regular committing to create a detailed history. Commits are local until pushed to a remote.",
    "code": "git commit -m \"Describe your changes\""
  },
  {
    "title": "Git Tagging",
    "note": "Tags mark specific points in history as important, typically for releases. Lightweight tags are simple pointers to commits, while annotated tags store additional metadata like tagger name, email, date, and message. Tags are useful for versioning, release management, and identifying significant milestones. They are not automatically pushed to remotes; use git push --tags to share them.",
    "code": "git tag v1.0"
  },
  {
    "title": "Git Stash",
    "note": "Stashing temporarily shelves changes, allowing you to work on something else without committing incomplete work. git stash saves modifications to a stack of stashes. git stash list shows all stashes, git stash apply restores the most recent stash, and git stash pop applies and removes the stash. Stashing is useful for quickly switching contexts or cleaning the working directory.",
    "code": "git stash\n// To apply stash later: git stash apply"
  },
  {
    "title": "Git History",
    "note": "git log displays the commit history in reverse chronological order. Various options customize the output: --oneline for compact view, --graph for branch visualization, --stat for change statistics, -p for patch content, and --since/--until for time-based filtering. Understanding history helps track changes, identify when bugs were introduced, and comprehend project evolution.",
    "code": "git log"
  },
  {
    "title": "Git Help",
    "note": "Git provides comprehensive help through multiple channels: git help command shows manual pages, git command --help provides command-specific help, and online documentation offers detailed guides. Many commands have --help options for quick reference. The help system covers usage, options, examples, and related commands, making it an essential resource for learning and troubleshooting.",
    "code": "git help commit\n// or\nman git-commit"
  },
  {
    "title": "Git Branch",
    "note": "Branches are pointers to commits that allow parallel development. git branch lists branches, git branch name creates a new branch, and git checkout name switches branches. Branches are lightweight and inexpensive, encouraging feature-based development. The default branch is typically called main or master. Branching enables isolated work on features, bug fixes, or experiments without affecting the main codebase.",
    "code": "git branch feature-branch\ngit checkout feature-branch"
  },
  {
    "title": "Git Merge",
    "note": "Merging combines changes from different branches. git merge branch integrates the specified branch into the current branch. Fast-forward merges move the branch pointer when possible; three-way merges create merge commits when histories diverge. Merge conflicts occur when changes overlap and require manual resolution. Merging is fundamental for integrating completed work back into main branches.",
    "code": "git checkout main\ngit merge feature-branch"
  },
  {
    "title": "Git Workflow",
    "note": "Common Git workflows include: Centralized Workflow (single central repository), Feature Branch Workflow (each feature in its own branch), Gitflow Workflow (structured with develop, feature, release, and hotfix branches), and Forking Workflow (each contributor has a personal fork). Workflows define branching strategies, release processes, and collaboration patterns suited to different team sizes and project needs.",
    "code": "// Example: Feature branching and pull requests"
  },
  {
    "title": "Git Best Practices",
    "note": "Effective Git usage involves: writing clear, descriptive commit messages; making small, atomic commits; branching strategically for features and fixes; regularly pulling from shared repositories; reviewing changes before pushing; and using .gitignore to exclude unnecessary files. These practices maintain a clean history, facilitate collaboration, and simplify debugging and code reviews.",
    "code": "// Commit early, commit often; use meaningful messages."
  },
  {
    "title": "Git Glossary",
    "note": "Key Git terms include: Blob (binary large object storing file data), Commit (snapshot of the repository), HEAD (pointer to the current branch or commit), Index (staging area), Merge (combining histories), Rebase (reapplying commits), Remote (remote repository reference), and Tag (marker for significant points). Understanding this vocabulary is essential for effective communication about Git operations.",
    "code": "// Reference terms in Git docs."
  },
  {
    "title": "GitHub Get Started",
    "note": "GitHub is a platform for hosting Git repositories and collaborating on code. To begin, create an account at github.com, set up your profile, and configure SSH keys for secure authentication. GitHub provides web-based repository management, issue tracking, pull requests, and project management tools. It's widely used for open-source projects and private team collaboration.",
    "code": "// Sign up at https://github.com"
  },
  {
    "title": "Git What is SSH?",
    "note": "SSH (Secure Shell) provides encrypted communication between your computer and GitHub. SSH keys are used for authentication instead of passwords. Generate a key pair with ssh-keygen: a private key (kept secure on your machine) and a public key (shared with GitHub). SSH enables secure Git operations (push, pull, clone) without repeatedly entering credentials.",
    "code": "ssh-keygen -t rsa -b 4096 -C \"you@example.com\""
  },
  {
    "title": "GitHub Add SSH",
    "note": "After generating an SSH key pair, add the public key to your GitHub account. Copy the contents of ~/.ssh/id_rsa.pub (or your chosen key file) and paste it in GitHub's SSH keys settings (Settings → SSH and GPG keys → New SSH key). This allows GitHub to authenticate you based on your private key, enabling password-less secure access to your repositories.",
    "code": "// Copy key: cat ~/.ssh/id_rsa.pub"
  },
  {
    "title": "GitHub Set Remote",
    "note": "Remotes are references to remote repositories. git remote add origin url creates a remote named 'origin' pointing to your GitHub repository. 'origin' is the conventional name for the primary remote. After setting a remote, you can push local commits to GitHub and pull changes from it. Multiple remotes can be configured for complex workflows involving different collaboration points.",
    "code": "git remote add origin git@github.com:user/repo.git"
  },
  {
    "title": "GitHub Edit Code",
    "note": "GitHub's web interface includes an editor for quick changes directly in the browser. You can create, edit, rename, and delete files through the web UI. Changes made online are committed directly to the repository. This is useful for quick fixes, documentation updates, or when you don't have access to your local development environment. The web editor supports syntax highlighting and basic editing features.",
    "code": "// Use GitHub's online editor."
  },
  {
    "title": "Pull from GitHub",
    "note": "git pull fetches changes from a remote repository and merges them into the current branch. It's equivalent to git fetch followed by git merge. Pulling regularly keeps your local repository synchronized with the remote, reducing merge conflicts. For complex integration, consider git fetch followed by manual inspection and merging instead of direct pulling.",
    "code": "git pull origin main"
  },
  {
    "title": "Push to GitHub",
    "note": "git push uploads local commits to a remote repository. git push origin main pushes the local 'main' branch to the 'origin' remote. The first push may require setting the upstream branch with -u flag. Pushing shares your work with collaborators and backs up your commits to the remote server. Only fast-forward pushes are allowed by default; use --force with caution to overwrite history.",
    "code": "git push origin main"
  },
  {
    "title": "GitHub Branch",
    "note": "GitHub provides web-based branch management: create new branches, switch between branches, compare branches, and delete branches through the UI. Branch protection rules can be set to require reviews, status checks, or prevent force pushes. The branch dropdown and branch overview page help visualize and manage the branching structure of the repository.",
    "code": "// Create, switch, or delete branches on GitHub UI"
  },
  {
    "title": "Pull Branch from GitHub",
    "note": "To work with a branch that exists on GitHub but not locally, use git fetch to retrieve all remote branches, then git checkout branch-name to create a local tracking branch. git checkout -t origin/branch-name does both steps. Local branches that track remote branches will automatically synchronize with push/pull operations, maintaining the relationship between local and remote work.",
    "code": "git fetch\ngit checkout feature-branch"
  },
  {
    "title": "Push Branch to GitHub",
    "note": "When pushing a new local branch to GitHub, use git push -u origin branch-name to push the branch and set up tracking. Subsequent pushes can use just git push. Pushing branches enables collaboration on features before they're merged into main branches. GitHub will show pushed branches in the web interface, where they can be reviewed and prepared for merging via pull requests.",
    "code": "git push origin feature-branch"
  },
  {
    "title": "GitHub Flow",
    "note": "GitHub Flow is a lightweight branching workflow: create feature branches from main, make commits on the feature branch, open a pull request for discussion and review, deploy and test the feature branch, then merge into main after approval. This simple workflow emphasizes continuous delivery, pull-based collaboration, and keeping the main branch deployable at all times.",
    "code": "// Feature branches, pull requests, and code reviews"
  },
  {
    "title": "GitHub Pages",
    "note": "GitHub Pages provides free static website hosting directly from a GitHub repository. Enable it in repository settings, then serve content from the main branch, a docs folder, or a special gh-pages branch. GitHub Pages supports custom domains, HTTPS, and Jekyll for static site generation. It's ideal for project documentation, personal portfolios, or any static web content.",
    "code": "// Enable Pages from repo settings"
  },
  {
    "title": "Git GUI Clients",
    "note": "Graphical Git clients provide visual interfaces for common Git operations. Popular options include: GitHub Desktop (user-friendly, integrates with GitHub), Sourcetree (feature-rich, supports advanced workflows), GitKraken (cross-platform with integrated CI/CD), and built-in IDE integrations (VS Code, IntelliJ). GUI clients can lower the learning curve and provide visualization of complex repository states.",
    "code": "// Examples: GitHub Desktop, Sourcetree, GitKraken"
  },
  {
    "title": "GitHub Fork",
    "note": "Forking creates a personal copy of someone else's repository on GitHub. Forks enable you to freely experiment with changes without affecting the original project. To contribute back, make changes in your fork, then open a pull request to the original repository. Forking is fundamental to open-source collaboration on GitHub, allowing anyone to propose changes to projects they don't have direct write access to.",
    "code": "// Use GitHub's Fork button"
  },
  {
    "title": "Git Clone from GitHub",
    "note": "Cloning downloads a complete copy of a GitHub repository to your local machine, including all history, branches, and tags. git clone url creates a new directory with the repository contents and sets up the 'origin' remote pointing to the source. Cloning is the first step to contributing to a project or working with an existing codebase. Use SSH URLs for authenticated access or HTTPS for anonymous access.",
    "code": "git clone git@github.com:user/repo.git"
  },
  {
    "title": "GitHub Send Pull Request",
    "note": "Pull requests propose changes from one branch (often in a fork) to another. They provide a mechanism for code review, discussion, and testing before merging. Create pull requests through GitHub's web interface by comparing branches and describing the changes. Pull requests can include multiple commits and support review comments, requested changes, status checks, and automated integrations.",
    "code": "// Use GitHub UI to create a pull request"
  },
  {
    "title": "Git Revert",
    "note": "Reverting creates a new commit that undoes the changes from a previous commit. git revert commit-hash is safe for public history as it doesn't rewrite existing commits. Revert is the preferred way to undo changes that have already been shared with others, as it maintains a transparent history of what was done and undone. Multiple commits can be reverted in sequence.",
    "code": "git revert <commit-hash>"
  },
  {
    "title": "Git Reset",
    "note": "Reset moves the current branch pointer to a different commit, optionally modifying the working directory and staging area. Modes include: --soft (keep changes staged), --mixed (keep changes unstaged, default), and --hard (discard all changes). Reset rewrites history and should be used cautiously, especially for commits that have been pushed and shared with others.",
    "code": "git reset --hard <commit-hash>"
  },
  {
    "title": "Git Amend",
    "note": "Amending modifies the most recent commit. git commit --amend allows you to change the commit message, add forgotten files, or modify the commit content. Amending rewrites history by replacing the previous commit with a new one. It should only be used for commits that haven't been pushed to shared repositories, as it can cause synchronization issues for collaborators.",
    "code": "git commit --amend -m \"New commit message\""
  },
  {
    "title": "Git Rebase",
    "note": "Rebase reapplies commits from one branch onto another, creating a linear history. git rebase base-branch moves the current branch's commits to the tip of the base branch. Interactive rebase (git rebase -i) allows squashing, editing, or reordering commits. Rebasing creates cleaner histories but rewrites commit hashes, so it should be used carefully on shared branches.",
    "code": "git rebase main"
  },
  {
    "title": "Git Reflog",
    "note": "The reference log (reflog) records when branch tips and other references were updated in the local repository. git reflog shows the history of HEAD movements, including commits that are no longer referenced by any branch. Reflog is invaluable for recovering lost work, such as after accidental resets or deleted branches. Entries expire after 90 days by default.",
    "code": "git reflog"
  },
  {
    "title": "Git Recovery",
    "note": "Git provides multiple recovery mechanisms: use git reflog to find lost commits, git fsck to find dangling objects, and git cherry-pick to reapply specific commits. For deleted branches, find the last commit hash in reflog and create a new branch pointing to it. Regular pushing to remotes provides an additional backup of your work, protecting against local data loss.",
    "code": "// Use reflog and reset"
  },
  {
    "title": "Git .gitignore",
    "note": "The .gitignore file specifies patterns for files and directories that Git should ignore. Common exclusions include: build artifacts, dependency directories, editor temporary files, and environment configuration. .gitignore patterns use glob syntax and can be repository-specific or global (configured via git config). Proper .gitignore setup keeps repositories clean and prevents accidental committing of sensitive or generated files.",
    "code": "*.log\nnode_modules/"
  },
  {
    "title": "Git .gitattributes",
    "note": "The .gitattributes file controls how Git handles specific files. It can specify: line ending conversion (CRLF/LF), diff and merge strategies, export filters, and linguist attributes for language detection. .gitattributes ensures consistent behavior across different development environments and can optimize handling of binary files or language-specific processing.",
    "code": "*.txt text eol=lf"
  },
  {
    "title": "Git Large File Storage (LFS)",
    "note": "Git LFS replaces large files (binaries, media, datasets) with text pointers in the repository, storing the actual content on a separate server. This prevents repository bloat while maintaining versioning of large files. Install Git LFS, then use git lfs track to specify file patterns to manage. LFS is essential for projects dealing with large assets that would otherwise slow down Git operations.",
    "code": "git lfs track \"*.psd\""
  },
  {
    "title": "Git Signing Commits/Tags",
    "note": "Commit and tag signing uses GPG or SSH keys to cryptographically verify that changes were made by a specific person. Signed commits show a 'Verified' badge on GitHub. Configure signing with git config commit.gpgsign true for automatic signing, or use -S flag for individual signed commits. Signing provides authenticity and integrity assurance, important for security-critical projects.",
    "code": "git commit -S -m \"Signed commit\""
  },
  {
    "title": "Git Cherrypick & Patch",
    "note": "Cherry-picking applies the changes from a specific commit to the current branch. git cherry-pick commit-hash is useful for porting individual fixes or features between branches without merging entire histories. Patch files (git format-patch and git am) provide another way to share and apply changes, particularly useful for email-based code review workflows.",
    "code": "git cherry-pick <commit-hash>"
  },
  {
    "title": "Git Merge Conflicts",
    "note": "Merge conflicts occur when Git cannot automatically reconcile changes from different branches. Conflicted files contain conflict markers (<<<<<<<, =======, >>>>>>>) showing the competing changes. Resolve conflicts by manually editing the files to the desired state, then git add the resolved files and complete the merge. Tools like diff3 and various merge tools can help visualize and resolve conflicts.",
    "code": "// Manually edit conflicted files, then git add and commit"
  },
  {
    "title": "Git CI/CD",
    "note": "Continuous Integration and Delivery pipelines automatically build, test, and deploy code in response to Git events. GitHub Actions, GitLab CI, Jenkins, and other tools integrate with Git repositories to run workflows on push, pull request, or other triggers. CI/CD ensures code quality, prevents integration issues, and automates deployment processes based on Git operations.",
    "code": "// Configure with tools like Jenkins, GitHub Actions"
  },
  {
    "title": "Git Hooks",
    "note": "Git hooks are scripts that run automatically before or after specific Git events (commit, push, etc.). Hooks are stored in .git/hooks/ and can be written in any scripting language. Common hooks include: pre-commit (run linters), commit-msg (enforce message format), pre-push (run tests). Hooks enforce project policies and automate development workflows, though they are local to each repository clone.",
    "code": ".git/hooks/pre-commit"
  },
  {
    "title": "Git Submodules",
    "note": "Submodules allow including other Git repositories as subdirectories within a parent repository. git submodule add adds a submodule, which is tracked by commit hash rather than branch. Submodules are useful for managing dependencies or component-based architectures. However, they add complexity to the workflow and require careful management of updates and compatibility between parent and submodule versions.",
    "code": "git submodule add https://github.com/example/repo.git"
  },
  {
    "title": "Git Remote Advanced",
    "note": "Advanced remote management includes: multiple remotes for different collaboration points (origin, upstream), remote URL changes, remote branch management, and pruning stale references. git remote -v lists remotes, git remote set-url changes URLs, and git fetch --prune removes remote-tracking branches that no longer exist on the remote. Advanced remote configuration supports complex workflows involving multiple repositories.",
    "code": "git remote set-url origin new_url"
  },
  {
    "title": "Git Exercises",
    "note": "Practical exercises are essential for mastering Git. Practice scenarios should include: creating repositories and making commits, branching and merging, resolving conflicts, rewriting history (rebase, amend), recovering lost work, and collaborating via remotes. Real-world projects and contribution to open-source provide the best practice opportunities for comprehensive Git proficiency.",
    "code": "// Try branching, merging, and resolving conflicts"
  },
  {
    "title": "Git Quiz",
    "note": "Quizzes test understanding of Git concepts, commands, and workflows. They can include multiple-choice questions about Git internals, command syntax, branching strategies, and conflict resolution. Regular quizzing helps identify knowledge gaps and reinforce learning. Many Git tutorials and learning platforms include quizzes as part of their educational content.",
    "code": "// Use online Git quiz platforms"
  },
  {
    "title": "Git Syllabus",
    "note": "A comprehensive Git learning path covers: basic concepts and setup, daily workflow (add, commit, push), branching and merging, collaboration (remotes, pull requests), advanced topics (rebasing, submodules, hooks), and best practices. The syllabus should progress from fundamental operations to complex workflows, with practical projects at each stage to reinforce learning.",
    "code": "// Follow tutorials from beginner to advanced"
  },
  {
    "title": "Git Study Plan",
    "note": "An effective Git study plan might allocate: 1 week for basics and daily workflow, 1 week for branching and merging, 1 week for collaboration and remote workflows, 1 week for advanced topics and troubleshooting, and ongoing practice through real projects. Daily study should combine conceptual learning with hands-on command practice. The plan should adapt based on prior experience and specific project needs.",
    "code": "// Plan daily topics and exercises"
  },
  {
    "title": "Git Certificate",
    "note": "Git certifications validate proficiency in version control with Git. Options include: GitHub certifications (GitHub Actions, GitHub Administration), various platform-specific certifications, and general Git proficiency certificates from training providers. While certifications can demonstrate knowledge, practical experience and a portfolio of Git-based projects are often more valuable to employers. Certifications are most useful when they align with specific tooling used in target workplaces.",
    "code": "// Explore certificates from platforms like GitHub, Coursera"
  }
]
],
PostgrlSQL:[
  
  {
    "title": "PostgreSQL Home",
    "note": "PostgreSQL is a powerful, open-source object-relational database system known for its reliability, feature robustness, and performance. It has been actively developed for over 30 years and supports advanced data types, sophisticated indexing, and complex queries. PostgreSQL is highly extensible, allowing users to define their own data types, operators, and functions. It is ACID-compliant and supports foreign keys, joins, views, triggers, and stored procedures, making it suitable for a wide range of applications from small projects to large enterprise systems.",
    "code": "// Official site: https://www.postgresql.org/"
  },
  {
    "title": "PostgreSQL Intro",
    "note": "PostgreSQL (often called Postgres) is an advanced, enterprise-class relational database that emphasizes standards compliance and extensibility. It supports both SQL (relational) and JSON (non-relational) querying, making it versatile for various use cases. Key features include: multi-version concurrency control (MVCC), point-in-time recovery, tablespaces, asynchronous replication, and nested transactions. PostgreSQL's architecture includes a process-per-connection model and a shared buffer cache for efficient memory management.",
    "code": "// PostgreSQL supports advanced SQL features and extensibility."
  },
  {
    "title": "PostgreSQL Install",
    "note": "PostgreSQL can be installed on various operating systems: Windows (using the interactive installer from postgresql.org), macOS (using Homebrew: brew install postgresql or the EnterpriseDB installer), Linux (using package managers: apt-get install postgresql for Ubuntu/Debian, yum install postgresql for Red Hat/CentOS). The installation typically includes the PostgreSQL server, client utilities, and pgAdmin. After installation, the service starts automatically and creates a default 'postgres' user and database.",
    "code": "// Download installer from https://www.postgresql.org/download/"
  },
  {
    "title": "PostgreSQL Get Started",
    "note": "To start using PostgreSQL, connect to the database using the psql command-line interface or a graphical tool like pgAdmin. The basic connection command requires specifying a username and database. Once connected, you can execute SQL commands, manage databases, and query data. The initial setup typically involves creating a dedicated user and database for your application rather than using the default postgres superuser for security reasons.",
    "code": "psql -U username -d database_name"
  },
  {
    "title": "PostgreSQL pgAdmin 4",
    "note": "pgAdmin is the most popular open-source administration and development platform for PostgreSQL. It provides a graphical interface for managing databases, writing queries, monitoring server activity, and designing database schemas. Key features include: visual query builder, server status dashboard, backup and restore tools, and role management. pgAdmin is available as a desktop application or web-based interface, making it accessible from various environments.",
    "code": "// Download and install pgAdmin from https://www.pgadmin.org/"
  },
  {
    "title": "PostgreSQL CREATE TABLE",
    "note": "The CREATE TABLE statement defines a new table and its columns, including data types, constraints, and default values. PostgreSQL supports various data types including numeric, string, boolean, date/time, arrays, JSON, and custom types. Table constraints ensure data integrity through primary keys, foreign keys, unique constraints, and check constraints. Tables can be organized in schemas for better namespace management.",
    "code": "CREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(50));"
  },
  {
    "title": "PostgreSQL INSERT INTO",
    "note": "The INSERT statement adds new rows to a table. You can insert single or multiple rows in one statement. The RETURNING clause can return the inserted values, which is useful for obtaining automatically generated values like serial IDs. PostgreSQL also supports INSERT ... ON CONFLICT for handling duplicate key violations, allowing updates or skipping of conflicting rows.",
    "code": "INSERT INTO users (name) VALUES ('Alice');"
  },
  {
    "title": "PostgreSQL Fetch Data",
    "note": "The SELECT statement retrieves data from one or more tables. It can include column selection, filtering, sorting, grouping, and joining. PostgreSQL supports advanced features like window functions, common table expressions (CTEs), and various aggregate functions. The SELECT * syntax retrieves all columns, while explicit column lists improve readability and performance by fetching only needed data.",
    "code": "SELECT * FROM users;"
  },
  {
    "title": "PostgreSQL ADD COLUMN",
    "note": "The ALTER TABLE ... ADD COLUMN statement adds a new column to an existing table. You can specify the data type, constraints, and default value. Adding columns with defaults on large tables can be expensive as it requires updating every row. PostgreSQL 11+ supports faster ADD COLUMN with default values for better performance on large tables.",
    "code": "ALTER TABLE users ADD COLUMN email VARCHAR(100);"
  },
  {
    "title": "PostgreSQL UPDATE",
    "note": "The UPDATE statement modifies existing rows in a table. It typically includes a SET clause to specify new values and a WHERE clause to identify which rows to update. Without a WHERE clause, all rows are updated. PostgreSQL supports updating from other tables using FROM clauses and conditional updates with CASE expressions. Returning modified rows is possible with the RETURNING clause.",
    "code": "UPDATE users SET email = 'alice@example.com' WHERE id = 1;"
  },
  {
    "title": "PostgreSQL ALTER COLUMN",
    "note": "The ALTER TABLE ... ALTER COLUMN statement modifies column properties. It can change data types (if compatible), set or drop defaults, change nullability, or rename columns. Changing data types may require data conversion and can fail if existing data isn't compatible with the new type. PostgreSQL provides extensive ALTER COLUMN capabilities for schema evolution.",
    "code": "ALTER TABLE users ALTER COLUMN email TYPE TEXT;"
  },
  {
    "title": "PostgreSQL DROP COLUMN",
    "note": "The ALTER TABLE ... DROP COLUMN statement removes a column from a table. By default, it will fail if the column has dependent objects. The CASCADE option automatically drops dependent objects. Dropping columns physically removes the data, so it should be done cautiously. PostgreSQL also supports marking columns as unused for safer removal in later maintenance windows.",
    "code": "ALTER TABLE users DROP COLUMN email;"
  },
  {
    "title": "PostgreSQL DELETE",
    "note": "The DELETE statement removes rows from a table. Always use a WHERE clause to specify which rows to delete; without it, all rows are removed. DELETE operations can be large and may require vacuuming to reclaim space. For deleting all rows, TRUNCATE is faster as it doesn't scan the table and immediately reclaims disk space. DELETE returns the number of rows deleted.",
    "code": "DELETE FROM users WHERE id = 1;"
  },
  {
    "title": "PostgreSQL DROP TABLE",
    "note": "The DROP TABLE statement removes a table and all its data from the database. It will fail if the table has dependent objects unless CASCADE is specified. DROP TABLE is irreversible and should be used with caution. For temporary removal, consider renaming the table or moving it to a different schema instead of dropping it entirely.",
    "code": "DROP TABLE users;"
  },
  {
    "title": "Create Demo Database",
    "note": "Creating a demo database is useful for practice and testing without affecting production data. Use CREATE DATABASE with a descriptive name. You can then create sample tables, insert test data, and experiment with queries. Demo databases should be regularly maintained or dropped when no longer needed to avoid clutter. Template databases can be used to quickly create standardized demo environments.",
    "code": "CREATE DATABASE demo_db;"
  },
  {
    "title": "PostgreSQL Syntax",
    "note": "PostgreSQL follows SQL standards with some extensions. Key syntax rules include: SQL keywords are case-insensitive (SELECT, select, Select are equivalent), identifiers (table/column names) are case-insensitive unless quoted, statements are terminated with semicolons, and string literals use single quotes. PostgreSQL extends standard SQL with additional data types, functions, and syntax features like array constructors and JSON operators.",
    "code": "// SQL keywords are case-insensitive."
  },
  {
    "title": "PostgreSQL Operators",
    "note": "PostgreSQL supports a comprehensive set of operators: arithmetic (+, -, *, /, %), comparison (=, <>, <, >, <=, >=), logical (AND, OR, NOT), string concatenation (||), pattern matching (LIKE, ILIKE, SIMILAR TO), and specialized operators for arrays, JSON, and geometric types. Operators can be overloaded for custom data types, and new operators can be defined for specialized functionality.",
    "code": "SELECT * FROM users WHERE age > 18 AND active = TRUE;"
  },
  {
    "title": "PostgreSQL SELECT",
    "note": "The SELECT statement is the primary way to retrieve data. It can include: column selection (specific columns or expressions), table references (FROM clause), filtering (WHERE clause), sorting (ORDER BY), grouping (GROUP BY), and limiting (LIMIT). PostgreSQL supports advanced SELECT features like DISTINCT ON (unique per group), window functions, and common table expressions for complex queries.",
    "code": "SELECT name, age FROM users;"
  },
  {
    "title": "PostgreSQL SELECT DISTINCT",
    "note": "The DISTINCT clause eliminates duplicate rows from the result set. It can be applied to all selected columns or specific expressions. DISTINCT ON provides more control by specifying which columns to consider for uniqueness while allowing other columns to vary. This is useful for getting the first row per group when combined with ORDER BY.",
    "code": "SELECT DISTINCT city FROM users;"
  },
  {
    "title": "PostgreSQL WHERE",
    "note": "The WHERE clause filters rows based on specified conditions before they are processed by grouping or sorting. Conditions can use comparison operators, logical operators, pattern matching, and subqueries. PostgreSQL supports advanced filtering with array operators, JSON path expressions, and full-text search. Proper indexing of WHERE clause columns is crucial for query performance.",
    "code": "SELECT * FROM users WHERE active = TRUE;"
  },
  {
    "title": "PostgreSQL ORDER BY",
    "note": "The ORDER BY clause sorts the result set by one or more columns in ascending (ASC) or descending (DESC) order. NULLS FIRST or NULLS LAST controls the position of null values. Ordering can use expressions, not just column names. For large result sets, ensure appropriate indexes exist to avoid expensive sort operations. ORDER BY is evaluated after WHERE and GROUP BY.",
    "code": "SELECT * FROM users ORDER BY age DESC;"
  },
  {
    "title": "PostgreSQL LIMIT",
    "note": "The LIMIT clause restricts the number of rows returned by a query. It's often used with ORDER BY to get the top N rows. OFFSET skips a specified number of rows before returning results, useful for pagination. However, large OFFSET values can be inefficient; keyset pagination using WHERE conditions is often better for performance with large datasets.",
    "code": "SELECT * FROM users LIMIT 10;"
  },
  {
    "title": "PostgreSQL MIN and MAX",
    "note": "The MIN() and MAX() aggregate functions return the smallest and largest values in a column. They work with various data types including numbers, strings, and dates. These functions ignore NULL values. When used with GROUP BY, they return the min/max per group. For large tables, proper indexing significantly improves the performance of MIN/MAX queries.",
    "code": "SELECT MIN(age), MAX(age) FROM users;"
  },
  {
    "title": "PostgreSQL COUNT",
    "note": "The COUNT() aggregate function returns the number of rows matching the query. COUNT(*) counts all rows, COUNT(column) counts non-null values in a specific column, and COUNT(DISTINCT column) counts distinct non-null values. COUNT is often used with GROUP BY for aggregate reporting. For approximate counts on large tables, consider using the pg_stat_user_tables system view.",
    "code": "SELECT COUNT(*) FROM users WHERE active = TRUE;"
  },
  {
    "title": "PostgreSQL SUM",
    "note": "The SUM() aggregate function calculates the total sum of a numeric column. It returns NULL if no rows are selected or all values are NULL. SUM can be used with DISTINCT to sum unique values. For large summations, be mindful of data type limits (integer overflow) and consider using numeric or bigint types for large numbers.",
    "code": "SELECT SUM(salary) FROM employees;"
  },
  {
    "title": "PostgreSQL AVG",
    "note": "The AVG() aggregate function calculates the average (arithmetic mean) of a numeric column. It returns the sum divided by the count of non-null values. AVG returns NULL if no rows are selected or all values are NULL. For precise calculations, especially with money, consider using appropriate data types and be aware of integer division behavior.",
    "code": "SELECT AVG(age) FROM users;"
  },
  {
    "title": "PostgreSQL LIKE",
    "note": "The LIKE operator performs pattern matching on strings using wildcards: % matches any sequence of characters, _ matches any single character. ILIKE provides case-insensitive matching. For more complex patterns, SIMILAR TO (SQL standard regex) or regular expression operators (~, ~*) can be used. Pattern matching can be expensive; consider full-text search for advanced text search requirements.",
    "code": "SELECT * FROM users WHERE name LIKE 'A%';"
  },
  {
    "title": "PostgreSQL IN",
    "note": "The IN operator checks if a value matches any value in a list. The list can be specified as literal values (IN (1, 2, 3)) or as a subquery (IN (SELECT id FROM table)). NOT IN does the inverse. For large lists, JOIN operations often perform better than IN with subqueries. NULL values in IN lists require careful handling as NULL IN (...) returns NULL, not true or false.",
    "code": "SELECT * FROM users WHERE city IN ('New York', 'Los Angeles');"
  },
  {
    "title": "PostgreSQL BETWEEN",
    "note": "The BETWEEN operator checks if a value is within a range (inclusive). It's equivalent to value >= low AND value <= high. NOT BETWEEN does the inverse. BETWEEN works with various data types including numbers, dates, and strings. For date ranges, be mindful of time components and consider using date_trunc() or casting to date for exact date comparisons.",
    "code": "SELECT * FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-01-31';"
  },
  {
    "title": "PostgreSQL AS",
    "note": "The AS keyword assigns aliases to columns or tables in queries. Column aliases make results more readable or are required for derived columns. Table aliases shorten table names in joins or subqueries. AS is optional in most cases (you can use column alias directly), but including it improves readability. Aliases are especially useful with functions, expressions, and when joining the same table multiple times.",
    "code": "SELECT name AS username FROM users;"
  },
  {
    "title": "PostgreSQL Joins",
    "note": "Joins combine rows from two or more tables based on related columns. PostgreSQL supports INNER JOIN (matching rows only), LEFT JOIN (all left rows + matching right rows), RIGHT JOIN (all right rows + matching left rows), FULL JOIN (all rows from both tables), and CROSS JOIN (Cartesian product). Join conditions are specified with ON clauses. Proper indexing of join columns is essential for performance.",
    "code": "// INNER JOIN, LEFT JOIN, RIGHT JOIN examples"
  },
  {
    "title": "PostgreSQL INNER JOIN",
    "note": "INNER JOIN returns only the rows that have matching values in both tables. It's the most common type of join. If the join condition matches multiple rows in either table, the result will have multiple rows (Cartesian product of matches). INNER JOIN is commutative (A JOIN B equals B JOIN A) and associative. Use WHERE conditions for additional filtering after the join.",
    "code": "SELECT * FROM orders INNER JOIN customers ON orders.customer_id = customers.id;"
  },
  {
    "title": "PostgreSQL LEFT JOIN",
    "note": "LEFT JOIN returns all rows from the left table and the matched rows from the right table. If no match is found, NULL values are returned for right table columns. LEFT JOIN is useful for finding records that may not have related data in another table. Multiple LEFT JOINs can be chained to include data from several related tables while preserving all left table rows.",
    "code": "SELECT * FROM customers LEFT JOIN orders ON customers.id = orders.customer_id;"
  },
  {
    "title": "PostgreSQL RIGHT JOIN",
    "note": "RIGHT JOIN returns all rows from the right table and the matched rows from the left table. If no match is found, NULL values are returned for left table columns. RIGHT JOIN is less commonly used than LEFT JOIN, as the same result can usually be achieved by swapping tables and using LEFT JOIN. It's included for completeness and specific use cases where the right table is primary.",
    "code": "SELECT * FROM orders RIGHT JOIN customers ON orders.customer_id = customers.id;"
  },
  {
    "title": "PostgreSQL FULL JOIN",
    "note": "FULL JOIN returns all rows when there is a match in either left or right table. It combines the results of both LEFT and RIGHT JOINs. Where no match exists, NULL values are filled in for the missing side. FULL JOIN is useful for finding records that exist in one table but not the other, or for combining complete sets from both tables. It's less common than INNER or LEFT JOINs.",
    "code": "SELECT * FROM table1 FULL JOIN table2 ON table1.id = table2.id;"
  },
  {
    "title": "PostgreSQL CROSS JOIN",
    "note": "CROSS JOIN returns the Cartesian product of rows from the joined tables (every combination of rows). It doesn't require a join condition. The result set size is the product of the row counts of both tables. CROSS JOIN is useful for generating combinations or when no specific relationship exists between tables. Use cautiously with large tables as the result can be enormous.",
    "code": "SELECT * FROM table1 CROSS JOIN table2;"
  },
  {
    "title": "PostgreSQL UNION",
    "note": "UNION combines the result sets of two or more SELECT statements, removing duplicate rows. All SELECT statements must have the same number of columns with compatible data types. UNION ALL includes all rows, including duplicates, and is faster as it doesn't require duplicate removal. UNION is useful for combining data from different tables or queries that have similar structure.",
    "code": "SELECT city FROM customers UNION SELECT city FROM suppliers;"
  },
  {
    "title": "PostgreSQL GROUP BY",
    "note": "GROUP BY groups rows that have the same values in specified columns, typically used with aggregate functions. It allows you to perform calculations on each group rather than the entire result set. GROUP BY can group by multiple columns, creating hierarchical groups. PostgreSQL also supports GROUPING SETS, CUBE, and ROLLUP for advanced grouping operations and multi-dimensional analysis.",
    "code": "SELECT city, COUNT(*) FROM customers GROUP BY city;"
  },
  {
    "title": "PostgreSQL HAVING",
    "note": "HAVING filters groups after aggregation, similar to how WHERE filters rows before aggregation. It's used with GROUP BY to specify conditions on aggregate values. HAVING can reference aggregate functions (COUNT, SUM, AVG, etc.) and grouped columns. Conditions that don't involve aggregates should typically be in the WHERE clause for better performance, as they reduce the number of rows before grouping.",
    "code": "SELECT city, COUNT(*) FROM customers GROUP BY city HAVING COUNT(*) > 5;"
  },
  {
    "title": "PostgreSQL EXISTS",
    "note": "EXISTS checks if a subquery returns any rows. It returns true if the subquery returns at least one row, false otherwise. EXISTS is often used with correlated subqueries (subqueries that reference outer query columns). It's typically more efficient than IN for large datasets because it can stop processing after finding the first match. NOT EXISTS does the inverse check.",
    "code": "SELECT * FROM customers WHERE EXISTS (SELECT 1 FROM orders WHERE orders.customer_id = customers.id);"
  },
  {
    "title": "PostgreSQL ANY",
    "note": "The ANY operator compares a value to each value in a list or subquery result, returning true if any comparison is true. It's equivalent to IN when used with equality, but ANY can be used with other operators (<, >, <=, >=, <>, etc.). ANY is useful for comparisons where you need to check against multiple values with non-equality operators.",
    "code": "SELECT * FROM products WHERE price > ANY (SELECT price FROM discounts);"
  },
  {
    "title": "PostgreSQL ALL",
    "note": "The ALL operator compares a value to every value in a list or subquery result, returning true if all comparisons are true. It's the opposite of ANY. ALL is commonly used with comparison operators to check if a value satisfies a condition against all values in a set. Like ANY, it can be used with subqueries or literal lists of values.",
    "code": "SELECT * FROM products WHERE price > ALL (SELECT price FROM discounts);"
  },
  {
    "title": "PostgreSQL CASE",
    "note": "The CASE expression provides conditional logic in SQL queries. It has two forms: simple CASE (compares a value to multiple possibilities) and searched CASE (evaluates multiple conditions). CASE can be used in SELECT, WHERE, ORDER BY, and other clauses. It's essential for data transformation, conditional aggregation, and implementing complex business logic directly in SQL.",
    "code": "SELECT name, CASE WHEN age >= 18 THEN 'Adult' ELSE 'Minor' END AS age_group FROM users;"
  },
  {
    "title": "PostgreSQL Exercises",
    "note": "Practical exercises are crucial for mastering PostgreSQL. Practice should include: basic CRUD operations, complex queries with multiple joins and subqueries, aggregate functions with grouping, data modification statements, and transaction management. Real-world scenarios like reporting queries, data migration scripts, and performance optimization provide the most valuable practice experience.",
    "code": "// Write queries to solve real-world scenarios"
  },
  {
    "title": "PostgreSQL Quiz",
    "note": "Quizzes test understanding of PostgreSQL concepts including SQL syntax, data types, functions, performance optimization, and administration. They can include multiple-choice questions, query writing exercises, and problem-solving scenarios. Regular quizzing helps identify knowledge gaps and reinforce learning. Many online learning platforms and PostgreSQL documentation include quiz components.",
    "code": "// Use online platforms or create your own"
  },
  {
    "title": "PostgreSQL Syllabus",
    "note": "A comprehensive PostgreSQL syllabus should cover: SQL fundamentals, data types and functions, table design and constraints, queries (basic to advanced), transactions and concurrency, performance optimization, administration, and advanced features (partitioning, replication, full-text search). The syllabus should progress from basic concepts to advanced topics with hands-on projects at each stage.",
    "code": "// Follow topics from basics to advanced"
  },
  {
    "title": "PostgreSQL Study Plan",
    "note": "An effective PostgreSQL study plan might allocate: 1-2 weeks for SQL fundamentals and basic queries, 1 week for data modification and transactions, 1-2 weeks for advanced queries and optimization, 1 week for administration and performance tuning, and ongoing practice with real projects. Daily study should combine conceptual learning with hands-on query writing and database design exercises.",
    "code": "// Daily or weekly study goals"
  },
  {
    "title": "PostgreSQL Certificate",
    "note": "PostgreSQL certifications validate proficiency in database administration and development. Options include: PostgreSQL Professional Certification (from PostgreSQL Global Development Group), vendor-specific certifications from companies like EDB, and general database certifications that include PostgreSQL content. Certifications typically cover installation, configuration, SQL proficiency, performance tuning, and administration. Practical experience often complements formal certification.",
    "code": "// Look for certifications from vendors or online courses"
  }
],
MongoDB:
[
  {
    "title": "MongoDB HOME",
    "note": "Starting point for MongoDB tutorials and documentation. MongoDB is a popular NoSQL document database that provides high performance, high availability, and easy scalability. It works on the concept of collections and documents using a flexible, JSON-like format called BSON.",
    "code": "// Official site: https://www.mongodb.com/\n// MongoDB Community Server (free): https://www.mongodb.com/try/download/community\n// MongoDB Atlas (cloud): https://www.mongodb.com/atlas/database\n// Documentation: https://docs.mongodb.com/"
  },
  {
    "title": "MongoDB Get Started",
    "note": "Introduction to MongoDB, a NoSQL document database. Learn the basic concepts, installation process, and how to set up your first database. MongoDB stores data in flexible, JSON-like documents, meaning fields can vary from document to document and data structure can be changed over time.",
    "code": "// Install MongoDB and start the server.\n// For Windows: mongod.exe --dbpath=\"c:\\data\\db\"\n// For macOS/Linux: mongod --dbpath /usr/local/var/mongodb\n// Connect using MongoDB Shell: mongo\n// Check version: db.version()"
  },
  {
    "title": "MongoDB Query API",
    "note": "Learn how to query MongoDB using its rich API. The MongoDB Query API provides powerful methods to retrieve, filter, sort, and manipulate data. It supports complex queries with operators for comparison, logical operations, element evaluation, and array operations.",
    "code": "// Basic find operation\ndb.collection.find({})\n// Find with projection (select specific fields)\ndb.collection.find({}, {name: 1, age: 1})\n// Find with limit\ndb.collection.find().limit(10)\n// Sort results\ndb.collection.find().sort({age: -1})"
  },
  {
    "title": "MongoDB Create DB",
    "note": "Create a new MongoDB database. MongoDB creates databases and collections automatically when you first store data in them. The 'use' command switches to a database, and if it doesn't exist, MongoDB will create it when you first store data.",
    "code": "// Switch to or create a new database\nuse myNewDatabase\n// Show current database\ndb\n// List all databases\nshow dbs\n// Note: The database won't appear in show dbs until data is inserted"
  },
  {
    "title": "MongoDB Collection",
    "note": "Create and manage collections (tables) in MongoDB. Collections are analogous to tables in relational databases and contain documents. You can explicitly create collections or let MongoDB create them automatically when you insert documents.",
    "code": "// Create a collection explicitly\ndb.createCollection('users')\n// Create collection with options\ndb.createCollection('users', { capped: true, size: 100000 })\n// List all collections\nshow collections\n// Drop a collection\ndb.users.drop()"
  },
  {
    "title": "MongoDB Insert",
    "note": "Insert documents (records) into a collection. MongoDB supports inserting single documents or multiple documents at once. Each document is assigned a unique _id field if not provided. Documents are stored in BSON format (Binary JSON).",
    "code": "// Insert a single document\ndb.users.insertOne({name: 'Alice', age: 25, email: 'alice@example.com', created: new Date()})\n// Insert multiple documents\ndb.users.insertMany([\n  {name: 'Bob', age: 30, email: 'bob@example.com'},\n  {name: 'Charlie', age: 35, email: 'charlie@example.com'}\n])\n// Insert with custom _id\ndb.users.insertOne({_id: 1, name: 'David', age: 28})"
  },
  {
    "title": "MongoDB Find",
    "note": "Retrieve documents using queries. The find() method is used to query documents from a collection. You can specify filter conditions, projection to include/exclude fields, and chain methods like sort(), limit(), and skip() for result manipulation.",
    "code": "// Find all documents\ndb.users.find()\n// Find with equality condition\ndb.users.find({name: 'Alice'})\n// Find with projection (include only specific fields)\ndb.users.find({}, {name: 1, age: 1})\n// Find with exclusion\ndb.users.find({}, {_id: 0, name: 1})\n// Chain methods\ndb.users.find({age: {$gt: 25}}).sort({name: 1}).limit(5)"
  },
  {
    "title": "MongoDB Update",
    "note": "Update existing documents. MongoDB provides methods to update single or multiple documents. You can update specific fields, replace entire documents, or use operators to modify array fields and perform atomic operations.",
    "code": "// Update a single document\ndb.users.updateOne({name: 'Alice'}, {$set: {age: 26, lastModified: new Date()}})\n// Update multiple documents\ndb.users.updateMany({age: {$lt: 30}}, {$set: {status: 'young'}})\n// Replace a document\ndb.users.replaceOne({name: 'Alice'}, {name: 'Alice', age: 27, city: 'New York'})\n// Increment a value\ndb.users.updateOne({name: 'Alice'}, {$inc: {age: 1}})"
  },
  {
    "title": "MongoDB Delete",
    "note": "Delete documents from a collection. MongoDB provides methods to delete single or multiple documents based on specified criteria. Use delete operations carefully as they permanently remove data from the database.",
    "code": "// Delete a single document\ndb.users.deleteOne({name: 'Alice'})\n// Delete multiple documents\ndb.users.deleteMany({age: {$gt: 40}})\n// Delete all documents in collection (be careful!)\ndb.users.deleteMany({})\n// Note: deleteMany({}) removes all documents but keeps the collection structure"
  },
  {
    "title": "MongoDB Query Operators",
    "note": "Use operators like $gt, $lt, $in to filter data. MongoDB provides a rich set of query operators for comparison, logical operations, element evaluation, array operations, and more. These operators allow you to build complex queries for precise data retrieval.",
    "code": "// Comparison operators\ndb.users.find({age: {$gt: 25, $lt: 40}}) // Greater than 25 and less than 40\ndb.users.find({age: {$in: [25, 30, 35]}}) // Age is 25, 30, or 35\n// Logical operators\ndb.users.find({$or: [{age: {$lt: 25}}, {age: {$gt: 40}}]})\ndb.users.find({$and: [{age: {$gt: 25}}, {city: 'New York'}]})\n// Element operators\ndb.users.find({email: {$exists: true}}) // Documents that have email field\ndb.users.find({age: {$type: 'number'}}) // Age field is of type number"
  },
  {
    "title": "MongoDB Update Operators",
    "note": "Use operators like $set, $inc for updating fields. MongoDB update operators allow you to modify documents in various ways, including setting fields, incrementing values, pushing to arrays, renaming fields, and performing complex array operations.",
    "code": "// Set fields\ndb.users.updateOne({name: 'Alice'}, {$set: {age: 26, city: 'Boston'}})\n// Increment values\ndb.users.updateOne({name: 'Alice'}, {$inc: {age: 1, loginCount: 1}})\n// Push to arrays\ndb.users.updateOne({name: 'Alice'}, {$push: {hobbies: 'reading'}})\n// Remove fields\ndb.users.updateOne({name: 'Alice'}, {$unset: {tempField: \"\"}})\n// Rename fields\ndb.users.updateOne({name: 'Alice'}, {$rename: {'oldField': 'newField'}})"
  },
  {
    "title": "MongoDB Aggregations",
    "note": "Perform advanced data aggregation and grouping. The aggregation framework processes data records and returns computed results. Aggregation operations group values from multiple documents together and can perform a variety of operations on the grouped data.",
    "code": "// Basic grouping\ndb.orders.aggregate([{$group: {_id: '$status', count: {$sum: 1}}}])\n// Multiple grouping fields\ndb.orders.aggregate([{$group: {_id: {status: '$status', year: {$year: '$date'}}, total: {$sum: '$amount'}}}])\n// Pipeline stages\ndb.orders.aggregate([\n  {$match: {status: 'completed'}},\n  {$group: {_id: '$customer', total: {$sum: '$amount'}}},\n  {$sort: {total: -1}},\n  {$limit: 10}\n])\n// Lookup (join-like operation)\ndb.orders.aggregate([{$lookup: {from: 'customers', localField: 'customerId', foreignField: '_id', as: 'customerInfo'}}])"
  },
  {
    "title": "MongoDB Indexing/Search",
    "note": "Create indexes for faster queries and use text search. Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must perform a collection scan. Text indexes support text search queries on string content.",
    "code": "// Create a single field index\ndb.users.createIndex({email: 1})\n// Create compound index\ndb.users.createIndex({lastName: 1, firstName: 1})\n// Create unique index\ndb.users.createIndex({email: 1}, {unique: true})\n// Create text index for search\ndb.users.createIndex({name: 'text', bio: 'text'})\n// Text search query\ndb.users.find({$text: {$search: 'developer programmer'}})\n// Check existing indexes\ndb.users.getIndexes()"
  },
  {
    "title": "MongoDB Validation",
    "note": "Enforce data validation rules on collections. Document validation allows you to enforce rules on document structure, data types, and required fields. Validation rules can be applied during document updates and insertions to maintain data integrity.",
    "code": "// Create collection with validation\ndb.createCollection('users', {\n  validator: {\n    $jsonSchema: {\n      bsonType: 'object',\n      required: ['name', 'email', 'age'],\n      properties: {\n        name: {bsonType: 'string', description: 'must be a string and is required'},\n        email: {bsonType: 'string', pattern: '^.+@.+\\\\..+$', description: 'must be a valid email'},\n        age: {bsonType: 'int', minimum: 18, maximum: 120, description: 'must be an integer between 18 and 120'}\n      }\n    }\n  }\n})\n// Add validation to existing collection\ndb.runCommand({collMod: 'users', validator: { age: { $gte: 18 } } })\n// View validation rules\ndb.getCollectionInfos({name: 'users'})"
  },
  {
    "title": "MongoDB Data API",
    "note": "Interact with MongoDB using RESTful Data API endpoints. The MongoDB Data API provides HTTP endpoints to access your MongoDB data without writing backend code. It's particularly useful for serverless applications, mobile apps, and scenarios where you can't use native drivers.",
    "code": "// Use MongoDB Atlas Data API for serverless access\n// Example fetch request to find documents\n/*\nfetch('https://data.mongodb-api.com/app/your-app-id/endpoint/data/v1/action/find', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'api-key': 'your-api-key'\n  },\n  body: JSON.stringify({\n    dataSource: 'your-cluster',\n    database: 'your-database',\n    collection: 'users',\n    filter: {age: {$gt: 25}}\n  })\n})\n*/\n// Available actions: find, insertOne, insertMany, updateOne, updateMany, deleteOne, deleteMany, aggregate"
  },
  {
    "title": "MongoDB Drivers",
    "note": "Use official drivers to connect MongoDB with various languages. MongoDB provides officially supported drivers for most popular programming languages, allowing you to interact with MongoDB databases from your applications. Each driver follows similar patterns but with language-specific idioms.",
    "code": "// Examples for Node.js, Python, Java, C#\n// Node.js: npm install mongodb\n// Python: pip install pymongo\n// Java: Add MongoDB Java Driver dependency to pom.xml\n// C#: Install-Package MongoDB.Driver via NuGet\n// Go: go get go.mongodb.org/mongo-driver/mongo\n// PHP: composer require mongodb/mongodb\n// Ruby: gem install mongo\n// Official drivers documentation: https://docs.mongodb.com/drivers/"
  },
  {
    "title": "MongoDB Node.js Driver",
    "note": "Using the MongoDB driver with Node.js applications. The Node.js driver provides a asynchronous API for interacting with MongoDB. It supports promises and async/await syntax, connection pooling, and all MongoDB features including transactions, change streams, and aggregation.",
    "code": "// Basic connection and query example\nconst { MongoClient } = require('mongodb');\nconst uri = 'mongodb://localhost:27017';\nconst client = new MongoClient(uri);\n\nasync function run() {\n  try {\n    await client.connect();\n    const database = client.db('myDatabase');\n    const collection = database.collection('users');\n    \n    // Insert a document\n    const result = await collection.insertOne({name: 'Alice', age: 25});\n    console.log('Inserted document ID:', result.insertedId);\n    \n    // Find documents\n    const users = await collection.find({age: {$gt: 20}}).toArray();\n    console.log('Found users:', users);\n    \n  } finally {\n    await client.close();\n  }\n}\n\nrun().catch(console.dir);"
  },
  {
    "title": "MongoDB Charts",
    "note": "Visualize MongoDB data using MongoDB Charts. Charts is a data visualization tool that allows you to create dashboards and visualizations directly from your MongoDB data without ETL processes. It integrates seamlessly with MongoDB Atlas and supports real-time data visualization.",
    "code": "// Create dashboards and embed charts\n// Charts is typically configured through the web UI\n// Embedding example:\n/*\n<iframe \n  src=\"https://charts.mongodb.com/charts-your-project-id/embed/charts?id=chart-id\" \n  width=\"800\" \n  height=\"600\" \n  frameborder=\"0\">\n</iframe>\n*/\n// Supported chart types: bar, line, pie, scatter, geographic, tables, gauges\n// Data sources: MongoDB collections, aggregation pipelines, views\n// Access through: MongoDB Atlas UI → Charts section"
  },
  {
    "title": "MongoDB Exercises",
    "note": "Practice problems to build MongoDB skills. Exercises help reinforce learning through hands-on practice. Work on real-world scenarios like querying, data modeling, aggregation pipelines, and performance optimization to become proficient with MongoDB.",
    "code": "// Create queries, insert and update documents\n// Exercise 1: Insert 10 user documents with different ages and cities\n// Exercise 2: Find all users older than 30 from New York\n// Exercise 3: Update all users to add a 'lastLogin' field with current date\n// Exercise 4: Create an aggregation that groups users by city and calculates average age\n// Exercise 5: Create indexes for common query patterns\n// Exercise 6: Implement data validation for a new collection\n// Exercise 7: Use transactions for multiple related operations\n// Exercise 8: Set up a text search index and perform text queries"
  },
  {
    "title": "MongoDB Syllabus",
    "note": "Structured course outline for learning MongoDB. A comprehensive syllabus covers everything from basic concepts to advanced features, ensuring a thorough understanding of MongoDB's capabilities and best practices for database design and management.",
    "code": "// Progress from basics to advanced topics\n/*\nWeek 1: Introduction to NoSQL and MongoDB Basics\nWeek 2: CRUD Operations (Create, Read, Update, Delete)\nWeek 3: Query Operators and Advanced Querying\nWeek 4: Indexing and Performance Optimization\nWeek 5: Aggregation Framework\nWeek 6: Data Modeling and Schema Design\nWeek 7: MongoDB Drivers and Application Integration\nWeek 8: MongoDB Atlas and Cloud Deployment\nWeek 9: Security, Authentication, and Authorization\nWeek 10: Advanced Topics: Transactions, Change Streams, Sharding\nWeek 11: MongoDB Tools and Ecosystem (Compass, Charts, BI Connector)\nWeek 12: Real-world Projects and Best Practices\n*/"
  },
  {
    "title": "MongoDB Study Plan",
    "note": "Organized schedule to master MongoDB efficiently. A structured study plan helps you systematically learn MongoDB concepts, practice skills, and build projects. Consistent daily or weekly learning goals ensure comprehensive coverage of all important topics.",
    "code": "// Daily or weekly learning goals\n/*\nWeek 1: \n  - Day 1: Install MongoDB and explore basic commands\n  - Day 2: Learn CRUD operations with practice exercises\n  - Day 3: Study query operators and practice complex queries\n  - Day 4: Work on indexing and performance concepts\n  - Day 5: Review week and complete practice projects\n\nWeek 2:\n  - Day 1: Deep dive into aggregation framework\n  - Day 2: Practice aggregation pipelines with real datasets\n  - Day 3: Learn data modeling principles\n  - Day 4: Study application integration with drivers\n  - Day 5: Build a small application using MongoDB\n\nContinue with advanced topics, cloud deployment, security, and real-world projects\n*/"
  },
  {
    "title": "MongoDB Certificate",
    "note": "Certification programs to validate MongoDB expertise. MongoDB University offers official certifications that demonstrate your proficiency with MongoDB. These certifications are recognized by employers and can enhance your career prospects in database administration and development.",
    "code": "// MongoDB University offers official certificates\n// MongoDB Certified Developer Associate: Focuses on application development\n// MongoDB Certified DBA Associate: Focuses on database administration\n// MongoDB Certified Advanced Developer: Advanced development skills\n// MongoDB Certified Advanced DBA: Advanced administration skills\n// Preparation: Take free courses on MongoDB University, practice with hands-on labs\n// Exam format: Multiple choice questions and practical performance-based tasks\n// Registration: https://university.mongodb.com/certification\n// Renewal: Certifications are valid for 3 years"
  }

],
Kotlin:[
{
    "title": "Kotlin HOME",
    "note": "The central hub for all Kotlin learning. Kotlin is a modern, statically typed programming language developed by JetBrains that runs on the Java Virtual Machine (JVM) and can also be compiled to JavaScript or native code. It's concise, safe, interoperable with Java, and designed for clarity and tooling support.",
    "code": "// Official Kotlin website: https://kotlinlang.org/"
  },
  {
    "title": "Kotlin Intro",
    "note": "Kotlin is a cross-platform, general-purpose language that aims to be a pragmatic and more concise alternative to Java. Its key features include null safety, extension functions, smart casts, coroutines for asynchronous programming, and excellent support for functional programming patterns. It's the officially preferred language for Android development.",
    "code": "fun main() {\n    println(\"Hello, Kotlin!\")\n}"
  },
  {
    "title": "Kotlin Get Started",
    "note": "To begin, you can use the online playground, install the Kotlin plugin for IntelliJ IDEA (the IDE it was designed for), or use the command-line compiler. For Android, Android Studio has built-in Kotlin support. A simple 'Hello World' is the best first step to verify your setup.",
    "code": "// Install IntelliJ IDEA and Kotlin plugin, then run a Kotlin file.\n// Alternatively, use the online editor at play.kotlinlang.org"
  },
  {
    "title": "Kotlin Syntax",
    "note": "Kotlin's syntax is designed to be readable and concise. Key points: functions are declared with 'fun', semicolons are optional, type declarations often follow a 'name: Type' pattern, and the language heavily favors immutability (using 'val' over 'var').",
    "code": "val greeting: String = \"Hello\" // Immutable variable with explicit type\nvar count = 1 // Mutable variable with type inferred as Int\nprintln(greeting) // Function call without parentheses if no arguments are needed"
  },
  {
    "title": "Kotlin Output",
    "note": "The `println` and `print` functions are used to output text to the standard output (console). `println` adds a newline at the end, while `print` does not. You can output the result of expressions directly using string templates.",
    "code": "println(\"Hello, World!\") // Outputs with a newline\nprint(\"No newline after this.\") // Outputs without a newline\nval name = \"Bob\"\nprintln(\"Hello, $name\") // Outputs: Hello, Bob (using string template)"
  },
  {
    "title": "Kotlin Comments",
    "note": "Comments are non-executable text for documentation and code explanation. Kotlin supports single-line comments (//) and multi-line (block) comments (/* ... */). Block comments can be nested, which is a feature not available in many other languages.",
    "code": "// This is a single-line comment\n\n/* This is a\n   multi-line comment */\n\n/* This block comment\n   /* contains a nested comment */\n   which is perfectly valid. */"
  },
  {
    "title": "Kotlin Variables",
    "note": "Variables store data. Use `val` (value) to declare a read-only, immutable variable that can be assigned only once. Use `var` (variable) to declare a mutable variable that can be reassigned. Type inference allows the compiler to determine the type in many cases, but explicit types can be provided.",
    "code": "val pi = 3.14159 // Read-only, type inferred as Double\nval name: String = \"Alice\" // Read-only, explicit type\n\nvar score = 100 // Mutable, type inferred as Int\nscore = 150 // Reassignment is allowed\n\n// name = \"Bob\" // This would cause a compiler error: Val cannot be reassigned"
  },
  {
    "title": "Kotlin Data Types",
    "note": "Kotlin has a rich set of built-in data types. Everything is an object, meaning you can call methods on basic types. The main categories are: Numbers (Byte, Short, Int, Long, Float, Double), Booleans (Boolean), Characters (Char), Strings (String), and Arrays (Array). All types are non-nullable by default; nullable types are denoted with a '?' (e.g., String?).",
    "code": "val number: Int = 42 // Integer number\nval pi: Double = 3.14 // Double-precision floating point\nval isActive: Boolean = true // Boolean value (true or false)\nval letter: Char = 'A' // Single character\nval message: String = \"Hello\" // String of characters\nval ids: Array<Int> = arrayOf(1, 2, 3) // Array of integers\n\nval nullableString: String? = null // Nullable string (can be null)"
  },
  {
    "title": "Kotlin Operators",
    "note": "Operators are special symbols used to perform operations on variables and values. Kotlin has: Arithmetic operators (+, -, *, /, %), Comparison operators (==, !=, <, >, <=, >=), Assignment operator (=), Increment/Decrement (++, --), Logical operators (&&, ||, !), and the Elvis operator (?:) for handling nulls.",
    "code": "val sum = 5 + 3 // Arithmetic addition, result: 8\nval isEqual = (sum == 8) // Comparison, result: true\nval logicalAnd = (sum > 0) && (sum < 10) // Logical AND, result: true\n\nvar counter = 1\ncounter++ // Increment, counter is now 2\n\nval name: String? = null\nval length = name?.length ?: 0 // Elvis operator: if name is null, use 0"
  },
  {
    "title": "Kotlin Strings",
    "note": "Strings are immutable sequences of characters. Kotlin supports string templates: use the '$' character to incorporate a variable or the '${}' syntax to include the result of an expression directly within a string. This eliminates the need for verbose concatenation.",
    "code": "val name = \"Anna\"\nval greeting = \"Hello, $name!\" // Simple template: Hello, Anna!\n\nval a = 10\nval b = 20\nval result = \"The sum of $a and $b is ${a + b}.\" // Expression template: The sum of 10 and 20 is 30.\n\n// Multiline strings are defined with triple quotes (\"\"\")\nval text = \"\"\"\n    This is a multiline\n    string. It preserves\n    all the formatting.\n\"\"\".trimIndent()"
  },
  {
    "title": "Kotlin Booleans",
    "note": "The Boolean type represents a logical entity and can only have two values: `true` and `false`. Booleans are the result of comparison operations (==, !=, <, >) and logical operations (&&, ||, !). They are essential for controlling the flow of execution in conditional statements like `if` and loops.",
    "code": "val isAdult = true\nval hasLicense = false\n\nval canDrive = isAdult && hasLicense // Logical AND: false\nval canVote = isAdult || hasLicense // Logical OR: true\nval isMinor = !isAdult // Logical NOT: false\n\nval age = 25\nval isTwentyFive = (age == 25) // Comparison: true"
  },
  {
    "title": "Kotlin If...Else",
    "note": "The `if` statement is used to execute a block of code only if a specified condition is true. The `else` clause executes if the condition is false. `else if` allows for multiple conditions. In Kotlin, `if` is an expression, meaning it can return a value, which is the result of the last expression in the chosen branch.",
    "code": "val age = 20\n\n// 1. Traditional statement\nif (age > 18) {\n    println(\"Adult\")\n} else {\n    println(\"Minor\")\n}\n\n// 2. If as an expression (assigning its result to a variable)\nval status = if (age > 18) {\n    \"Adult\" // This value is assigned to 'status' if true\n} else {\n    \"Minor\" // This value is assigned if false\n}\nprintln(status) // Outputs: Adult\n\n// 3. Else-if chain\nval grade = if (score >= 90) \"A\"\n           else if (score >= 80) \"B\"\n           else if (score >= 70) \"C\"\n           else \"F\""
  },
  {
    "title": "Kotlin When",
    "note": "The `when` expression is a powerful replacement for the switch statement found in other languages. It matches its argument against all branches sequentially until a matching condition is found. It can be used with arbitrary expressions (not just constants), ranges (`in`), and type checks (`is`). Like `if`, it is an expression and can return a value.",
    "code": "val x = 5\n\n// 1. Basic when (like switch-case)\nwhen(x) {\n    1 -> println(\"x is 1\")\n    2 -> println(\"x is 2\")\n    else -> println(\"x is neither 1 nor 2\") // 'else' is mandatory if branches are not exhaustive\n}\n\n// 2. When as an expression\nval description = when(x) {\n    1 -> \"One\"\n    2 -> \"Two\"\n    else -> \"Other number\" // Value assigned to 'description'\n}\n\n// 3. Advanced matching with ranges and types\nval obj: Any = \"Hello\"\nval result = when (obj) {\n    in 1..10 -> \"Number in range\"\n    is String -> \"String of length ${obj.length}\"\n    else -> \"Unknown\"\n}"
  },
  {
    "title": "Kotlin While Loop",
    "note": "The `while` loop executes a block of code as long as a given condition is true. The condition is evaluated before the execution of the loop's body. Use `while` when the number of iterations is not known beforehand and depends on a dynamic condition.",
    "code": "var i = 0\n\n// Standard while loop: checks condition, then executes body\nwhile (i < 5) {\n    println(i) // Prints 0, 1, 2, 3, 4\n    i++ // Increment the counter\n}\n\n// Do-while loop: executes body at least once, then checks condition\nvar j = 10\ndo {\n    println(j) // This will print 10 once, even though condition is false\n    j++\n} while (j < 5)"
  },
  {
    "title": "Kotlin Break/Continue",
    "note": "`break` is used to terminate the nearest enclosing loop immediately, skipping any remaining iterations. `continue` skips the rest of the current iteration of the nearest enclosing loop and proceeds to the next iteration. They are typically used with conditional statements (`if`) inside loops.",
    "code": "// Break example: exit the loop when i is 5\nfor (i in 1..10) {\n    if (i == 5) {\n        break // Loop stops here when i is 5\n    }\n    println(i) // Prints 1, 2, 3, 4\n}\n\n// Continue example: skip even numbers\nfor (i in 1..10) {\n    if (i % 2 == 0) {\n        continue // Skip the println for even numbers\n    }\n    println(i) // Prints 1, 3, 5, 7, 9\n}\n\n// Labeled break: break out of a specific outer loop\nouterLoop@ for (i in 1..3) {\n    for (j in 1..3) {\n        if (i == 2 && j == 2) {\n            break@outerLoop // Breaks the outer loop, not just the inner one\n        }\n        println(\"i=$i, j=$j\")\n    }\n}"
  },
  {
    "title": "Kotlin Arrays",
    "note": "An array is a container that holds a fixed number of values of a single type. The size is defined at creation and cannot be changed. Elements are accessed by their zero-based index. Kotlin provides functions like `arrayOf()` to create arrays easily. For primitive types, specialized classes like `IntArray` offer better performance.",
    "code": "// Creating arrays\nval numbers = arrayOf(1, 2, 3, 4) // Array<Int>\nval fruits = arrayOf(\"Apple\", \"Banana\", \"Cherry\") // Array<String>\n\n// Accessing and modifying elements\nval firstNumber = numbers[0] // Read element at index 0 (value: 1)\nnumbers[2] = 99 // Change element at index 2 to 99\n\n// Specialized primitive arrays for performance\nval efficientInts = intArrayOf(5, 10, 15) // IntArray\n\n// Array size and iteration\nval size = numbers.size // Gets the length (4)\nfor (item in fruits) {\n    println(item) // Iterates through each element\n}\n\nfor (index in fruits.indices) {\n    println(\"Index $index has ${fruits[index]}\") // Iterates through indices\n}"
  },
  {
    "title": "Kotlin For Loop",
    "note": "The `for` loop in Kotlin is used to iterate over anything that provides an iterator, such as ranges, arrays, collections (List, Set, Map), or strings. It's much more concise and less error-prone than traditional index-based `for` loops. The syntax is `for (item in collection) { ... }`.",
    "code": "// Iterate over a range\nfor (i in 1..5) { // Includes both 1 and 5\n    println(i) // Prints 1, 2, 3, 4, 5\n}\n\n// Iterate over an array or collection\nval names = arrayOf(\"Alice\", \"Bob\", \"Charlie\")\nfor (name in names) {\n    println(\"Hello, $name\") // Prints greeting for each name\n}\n\n// Iterate with index\nfor ((index, value) in names.withIndex()) {\n    println(\"$index: $value\") // Prints 0: Alice, 1: Bob, 2: Charlie\n}\n\n// Iterate over a string\nval word = \"Kotlin\"\nfor (letter in word) {\n    println(letter) // Prints each character on a new line: K, o, t, l, i, n\n}\n\n// Iterate backwards or with a step\nfor (i in 5 downTo 1) { // 5, 4, 3, 2, 1\n    println(i)\n}\nfor (i in 1..10 step 2) { // 1, 3, 5, 7, 9\n    println(i)\n}"
  },
  {
    "title": "Kotlin Ranges",
    "note": "A range defines a closed interval between a start and an end value. The main operator for creating ranges is `..` (which includes both end values). Ranges are primarily used for iteration in loops and for checking if a value belongs to a range using the `in` operator. Common functions include `downTo` for reverse ranges and `step` to define the increment.",
    "code": "// Creating ranges (all are inclusive)\nval oneToFive = 1..5 // Range of integers: 1, 2, 3, 4, 5\nval aToZ = 'a'..'z' // Range of characters\n\n// Check if a value is in a range\nval isInRange = (3 in oneToFive) // true\nval isNotInRange = (10 !in oneToFive) // true\n\n// Iterating over a range (see For Loop)\nfor (i in 1..5) { println(i) }\n\n// Reverse ranges and step\nfor (i in 5 downTo 1) { println(i) } // 5, 4, 3, 2, 1\nfor (i in 1..10 step 2) { println(i) } // 1, 3, 5, 7, 9\nfor (i in 10 downTo 0 step 3) { println(i) } // 10, 7, 4, 1\n\n// Half-open range (does NOT include the end value)\nfor (i in 1 until 5) { println(i) } // 1, 2, 3, 4"
  },
  {
    "title": "Kotlin Functions",
    "note": "Functions are blocks of code designed to perform a specific task, promoting reusability and organization. They are declared using the `fun` keyword. Kotlin functions can have parameters with default values, named arguments, and can return a single value (or Unit, which is similar to void). Single-expression functions can have a concise syntax.",
    "code": "// 1. Basic function\nfun greet(name: String) {\n    println(\"Hello, $name!\")\n}\n\n// 2. Function with return type and default parameter\nfun calculateArea(width: Int, height: Int = 10): Int { // height defaults to 10\n    return width * height\n}\nval area = calculateArea(5) // Uses default height: 50\nval area2 = calculateArea(5, 6) // Uses provided height: 30\n\n// 3. Single-expression function (return type can be inferred)\nfun double(x: Int) = x * 2 // Equivalent to: fun double(x: Int): Int { return x * 2 }\n\n// 4. Named arguments (order doesn't matter)\nval area3 = calculateArea(height = 20, width = 3) // 60\n\n// 5. Function returning Unit (equivalent to void) - return type is optional\nfun printMessage(message: String): Unit {\n    println(message)\n    // `return Unit` or `return` is implied, can be omitted\n}"
  },
  {
    "title": "Kotlin Classes",
    "note": "Classes are blueprints for creating objects (instances). A class can contain properties (variables to hold state) and functions (methods to define behavior). In Kotlin, the `class` keyword is used for declaration. The primary constructor is often part of the class header. Kotlin reduces boilerplate code; for example, properties defined in the constructor automatically generate getters (and setters for `var`s).",
    "code": "// Minimal class\nclass Car\n\n// Class with a primary constructor and properties\nclass Person(val name: String, var age: Int) { // 'val' makes name read-only, 'var' makes age mutable\n    // Properties name and age are declared here in the constructor\n\n    // Member function (method)\n    fun speak() {\n        println(\"Hi, I'm $name.\")\n    }\n}\n\n// Usage: creating an instance (object)\nval person1 = Person(\"Alice\", 30) // No 'new' keyword\nprintln(person1.name) // Access property: Alice\nperson1.age = 31 // Change property\nperson1.speak() // Call method: Hi, I'm Alice.\n\n// Class with a body\nclass Rectangle(val width: Int, val height: Int) {\n    // Property with custom getter (a computed property)\n    val area: Int\n        get() = width * height // Calculated every time it's accessed\n}"
  },
  {
    "title": "Kotlin OOP",
    "note": "Object-Oriented Programming (OOP) in Kotlin is based on four main principles: 1) Encapsulation: Bundling data (properties) and methods that operate on that data within a class, controlling access via visibility modifiers (public, private, etc.). 2) Inheritance: Creating new classes (derived) based on existing ones (base), inheriting their characteristics. 3) Polymorphism: The ability to present the same interface for different underlying forms (data types), often through inheritance and interface implementation. 4) Abstraction: Hiding complex implementation details and showing only essential features, achieved through abstract classes and interfaces.",
    "code": "// This is a conceptual overview. See specific examples in other cards.\n// 1. Encapsulation: Using 'private' keyword\nclass BankAccount(private var balance: Double) {\n    fun deposit(amount: Double) { balance += amount }\n    fun getBalance() = balance // Controlled access\n}\n\n// 2. Inheritance: Using 'open' and ':'\nopen class Animal(val name: String) // Base class must be 'open'\nclass Dog(name: String) : Animal(name) // Derived class\n\n// 3. Polymorphism: A function can take a base type\nfun makeSound(animal: Animal) { /* ... */ } // Can accept any Animal, including Dog\n\n// 4. Abstraction: Using abstract classes and interfaces\nabstract class Shape { abstract fun calculateArea(): Double }\ninterface Drawable { fun draw() }"
  },
  {
    "title": "Kotlin Classes/Objects",
    "note": "A class is a blueprint. An object is a specific instance of a class, created using the constructor. Each object has its own copy of the properties defined in the class. Kotlin also has a special `object` declaration used to create a singleton (a class with only one instance) and companion objects (which are tied to a class rather than an instance, similar to static members in Java).",
    "code": "// 1. Regular class and instance (object)\nclass Book(val title: String)\nval myBook = Book(\"Kotlin Guide\") // 'myBook' is an object (instance of Book)\n\n// 2. Singleton object declaration (only one instance exists)\nobject DatabaseManager {\n    fun connect() { println(\"Connecting to DB...\") }\n}\nDatabaseManager.connect() // Called directly on the object name, no instance needed\n\n// 3. Companion object (factory methods, static members)\nclass MyClass {\n    companion object {\n        fun create(): MyClass = MyClass()\n        const val MAX_INSTANCES = 10 // Like a static constant\n    }\n}\nval obj = MyClass.create() // Call via class name\nval max = MyClass.MAX_INSTANCES // Access constant\n\n// 4. Data class (special class for holding data, automatically generates useful methods)\ndata class User(val name: String, val id: Int) // Autogenerated: toString(), equals(), hashCode(), copy()"
  },
  {
    "title": "Kotlin Constructors",
    "note": "Constructors are special functions called when an object is created. Kotlin has two types: 1) Primary Constructor: Declared in the class header. It can't contain any code; initialization code is placed in `init` blocks. 2) Secondary Constructors: Defined inside the class body using the `constructor` keyword. They must delegate to the primary constructor (if it exists) using `this()`.",
    "code": "// 1. Primary constructor (in the header)\nclass Person(val firstName: String, val lastName: String) {\n    // Initialization block (runs when the object is created)\n    init {\n        println(\"Person object created for $firstName $lastName\")\n    }\n    // Property initialized from constructor parameters\n    val fullName = \"$firstName $lastName\"\n}\n\n// 2. Primary constructor with default visibility (public). Can be marked private.\nclass Secret private constructor(val code: String) // Private constructor\n\n// 3. Secondary constructor\nclass Car(val make: String, val model: String) {\n    var color: String = \"\"\n\n    // Secondary constructor delegates to primary using 'this'\n    constructor(make: String, model: String, color: String) : this(make, model) {\n        this.color = color // Additional initialization code\n    }\n}\nval car1 = Car(\"Toyota\", \"Corolla\") // Uses primary constructor\nval car2 = Car(\"Honda\", \"Civic\", \"Red\") // Uses secondary constructor\n\n// 4. Class without primary constructor, only secondary\nclass Shape {\n    var sides: Int\n    constructor(sides: Int) {\n        this.sides = sides\n    }\n}"
  },
  {
    "title": "Kotlin Class Functions",
    "note": "Functions defined inside a class are called member functions or methods. They define the behavior of the objects created from the class. They have access to all the properties and other member functions of the class. They are called on a specific instance of the class using the dot notation (`object.function()`).",
    "code": "class Calculator {\n    // Member function (method)\n    fun add(a: Int, b: Int): Int {\n        return a + b\n    }\n\n    // Function accessing class property\n    var lastResult: Int = 0\n    fun addAndStore(a: Int, b: Int): Int {\n        lastResult = a + b // Modifies the property\n        return lastResult\n    }\n\n    // Function calling another member function\n    fun incrementLastResult(): Int {\n        return addAndStore(lastResult, 1)\n    }\n}\n\n// Usage\nval calc = Calculator() // Create an instance\nval sum = calc.add(5, 3) // Call member function: 8\nval storedSum = calc.addAndStore(10, 2) // 12, and calc.lastResult is now 12\nval incremented = calc.incrementLastResult() // 13, and calc.lastResult is now 13"
  },
  {
    "title": "Kotlin Inheritance",
    "note": "Inheritance allows a new class (derived class, subclass) to inherit the properties and functions of an existing class (base class, superclass). In Kotlin, all classes implicitly inherit from `Any`. To make a class inheritable, it must be marked with the `open` keyword. The subclass declares its superclass using a colon `:` after its name. The `override` keyword is required to override methods or properties from the superclass.",
    "code": "// Base class (must be 'open')\nopen class Animal(val name: String) {\n    open fun makeSound() { // Function must be 'open' to be overridden\n        println(\"Some generic animal sound\")\n    }\n}\n\n// Derived class (inherits from Animal)\nclass Dog(name: String) : Animal(name) { // Calls Animal's constructor\n    // Override the makeSound function\n    override fun makeSound() {\n        println(\"$name says: Woof!\")\n    }\n}\n\n// Derived class with its own property\nclass Cat(name: String, val lives: Int) : Animal(name) {\n    override fun makeSound() {\n        println(\"$name says: Meow! (I have $lives lives)\")\n    }\n}\n\n// Usage\nval animal: Animal = Animal(\"Generic\")\nanimal.makeSound() // Some generic animal sound\n\nval dog: Animal = Dog(\"Rex\") // Polymorphism: Dog treated as Animal\ndog.makeSound() // Rex says: Woof!\n\nval cat = Cat(\"Whiskers\", 9)\ncat.makeSound() // Whiskers says: Meow! (I have 9 lives)"
  },
  {
    "title": "Kotlin Examples",
    "note": "Practical code snippets demonstrating common Kotlin tasks and idioms. These examples help solidify understanding by showing how the language features work together to solve real problems, from simple calculations and data manipulation to more complex object-oriented design patterns.",
    "code": "// Example 1: Simple function and string template\nfun greetUser(username: String, age: Int) {\n    println(\"Hello, $username! You are $age years old.\")\n}\ngreetUser(\"Alex\", 28)\n\n// Example 2: Using a data class for clean data handling\ndata class Product(val id: Int, val name: String, val price: Double)\nval product = Product(101, \"Coffee Mug\", 12.99)\nprintln(\"${product.name} costs $${product.price}\") // Coffee Mug costs $12.99\n\n// Example 3: Processing a list with functional operations\nval numbers = listOf(1, 2, 3, 4, 5, 6)\nval evenSquares = numbers\n    .filter { it % 2 == 0 } // [2, 4, 6]\n    .map { it * it } // [4, 16, 36]\nprintln(evenSquares)\n\n// Example 4: Simple when expression for state\nfun getTemperatureMessage(temp: Int) = when {\n    temp < 0 -> \"Freezing\"\n    temp in 0..15 -> \"Cold\"\n    temp in 16..25 -> \"Warm\"\n    else -> \"Hot\"\n}\nprintln(getTemperatureMessage(20)) // Warm"
  },
  {
    "title": "Kotlin Compiler",
    "note": "The Kotlin compiler (`kotlinc`) translates Kotlin source code (.kt files) into executable formats. It can target: 1) JVM: Produces Java bytecode (.class files) that run on any Java Virtual Machine, allowing full interoperability with Java libraries. 2) JavaScript: Transpiles Kotlin code to JS for running in browsers or Node.js. 3) Native: Compiles directly to machine code for various platforms (iOS, Linux, Windows, Mac) via Kotlin/Native, enabling cross-platform development without a VM.",
    "code": "# Compile a Kotlin file to JVM bytecode using the command-line compiler\nkotlinc hello.kt -include-runtime -d hello.jar\n\n# Run the compiled JAR (requires JRE)\njava -jar hello.jar\n\n# Compile for JavaScript\nkotlinc-js hello.kt -output hello.js\n\n# Compile a simple script without creating a full project\nkotlinc -script listfiles.kts\n\n# Common compiler options:\n# -d : output destination\n# -classpath (-cp) : specify classpath\n# -include-runtime : include Kotlin runtime in the JAR (makes it self-contained)\n# -verbose : output detailed logs"
  },
  {
    "title": "Kotlin Exercises",
    "note": "Hands-on coding problems designed to practice and master Kotlin concepts. Exercises range from basic syntax (variables, loops, functions) to advanced topics (collections, lambdas, coroutines). Solving exercises is crucial for moving from theoretical understanding to practical proficiency. Many online platforms offer interactive Kotlin exercises.",
    "code": "// Exercise 1: Function - Check if a number is even\nfun isEven(number: Int): Boolean {\n    // Your code here: return true if number is even, false otherwise\n    return number % 2 == 0\n}\n\n// Exercise 2: Loop - Print the Fibonacci sequence up to a limit\nfun printFibonacci(limit: Int) {\n    // Your code here: e.g., printFibonacci(50) should print 0, 1, 1, 2, 3, 5, 8, 13, 21, 34\n    var a = 0\n    var b = 1\n    print(\"$a, $b\")\n    while (a + b <= limit) {\n        val next = a + b\n        print(\", $next\")\n        a = b\n        b = next\n    }\n}\n\n// Exercise 3: Data Class - Create a 'Student' class and process a list\n// Create a data class Student(val name: String, val grade: Int)\n// Write a function that takes a list of Students and returns the names of those with grade > 90\nfun getTopStudents(students: List<Student>): List<String> {\n    return students.filter { it.grade > 90 }.map { it.name }\n}\n\n// Exercise 4: String Manipulation - Reverse a string\nfun reverseString(input: String): String {\n    // Your code here: return the reversed string\n    return input.reversed() // Simple way, or implement your own logic with a loop\n}"
  },
  {
    "title": "Kotlin Quiz",
    "note": "Multiple-choice or short-answer questions to test core knowledge of Kotlin syntax, semantics, and idioms. Quizzes help identify areas that need further study. They often cover tricky aspects like null safety, scope functions (`let`, `apply`), extension functions, coroutine basics, and the differences between similar constructs (e.g., `val` vs. `const val`, `List` vs. `MutableList`).",
    "code": "// Sample quiz questions (conceptual, not executable code):\n\n/* 1. What is the output?\n   val s: String? = null\n   println(s?.length ?: -1)\n   a) null\n   b) 0\n   c) -1\n   d) Throws NullPointerException\n   Answer: c) -1\n*/\n\n/* 2. Which keyword is used to make a class inheritable?\n   a) open\n   b) abstract\n   c) public\n   d) extends\n   Answer: a) open\n*/\n\n/* 3. What does this function return?\n   fun mystery(): Int {\n       return with(\"Kotlin\") { length }\n   }\n   a) 6\n   b) \"Kotlin\"\n   c) Compilation error\n   d) null\n   Answer: a) 6 (the length of the string \"Kotlin\")\n*/\n\n/* 4. How do you create a read-only list?\n   a) val list = mutableListOf(1, 2, 3)\n   b) val list = listOf(1, 2, 3)\n   c) var list = listOf(1, 2, 3)\n   d) Both b and c\n   Answer: b) val list = listOf(1, 2, 3) - 'listOf' creates immutable list, 'val' prevents reassignment.\n*/"
  },
  {
    "title": "Kotlin Syllabus",
    "note": "A structured, ordered curriculum outlining the path to learn Kotlin effectively. It typically starts with the absolute basics (setup, syntax) and progresses systematically through fundamental concepts (variables, control flow, functions), object-oriented programming, functional programming features (lambdas, collections), and finally advanced topics (coroutines, interoperability, multiplatform).",
    "code": "// A typical learning syllabus (modules/topics):\n\n/*\nModule 1: Kotlin Fundamentals\n  - Introduction & Setup\n  - Basic Syntax (fun, vars, types)\n  - Control Flow (if, when, for, while)\n  - Functions (basics, default args)\n  - Null Safety (?., ?:, !!)\n\nModule 2: Object-Oriented Kotlin\n  - Classes and Constructors\n  - Properties (Getters/Setters)\n  - Inheritance (open, override)\n  - Data Classes, Sealed Classes\n  - Objects (Singleton, Companion)\n\nModule 3: Collections & Functional Programming\n  - Arrays, Lists, Sets, Maps (read-only vs mutable)\n  - Lambda Expressions & Higher-Order Functions\n  - Scope Functions (let, run, with, apply, also)\n  - Extension Functions/Properties\n\nModule 4: Advanced Topics\n  - Generics (in, out)\n  - Coroutines Basics (suspend, async/launch)\n  - Interoperability with Java\n  - Kotlin Standard Library Overview\n  - Introduction to KMP (Kotlin Multiplatform)\n\nModule 5: Practical Application & Tools\n  - Build Tools (Gradle with Kotlin DSL)\n  - Testing (JUnit, Kotest)\n  - Popular Libraries (Ktor, Serialization)\n  - Final Project\n*/"
  },
  {
    "title": "Kotlin Study Plan",
    "note": "A suggested timeline and schedule for working through the Kotlin syllabus. A good plan balances learning concepts, practicing with exercises, and building small projects. It should be realistic and adaptable, recommending a consistent daily or weekly time investment. For example: 'Week 1: Fundamentals (2 hours/day). Week 2: OOP & Collections (2 hours/day). Week 3: Advanced topics & first project (3 hours/day).'",
    "code": "// Example 4-week part-time study plan (~1-2 hours per day)\n\n/*\nWeek 1: Core Concepts\n  - Day 1: Install tools, run first program, learn basic syntax.\n  - Day 2: Variables (val/var), basic data types, operators.\n  - Day 3: Strings, string templates, booleans.\n  - Day 4: Conditional statements (if, when).\n  - Day 5: Loops (for, while), ranges.\n  - Weekend: Practice 10-15 basic exercises on these topics.\n\nWeek 2: Functions & Introduction to OOP\n  - Day 1: Functions (definition, parameters, return types).\n  - Day 2: Null safety, Elvis operator, safe calls.\n  - Day 3: Classes, properties, init blocks.\n  - Day 4: Constructors (primary, secondary).\n  - Day 5: Member functions, visibility modifiers.\n  - Weekend: Build a simple program (e.g., a calculator class).\n\nWeek 3: Advanced OOP & Functional Features\n  - Day 1: Inheritance, overriding, abstract classes.\n  - Day 2: Interfaces, data classes, object keyword.\n  - Day 3: Collections (List, Set, Map) - creation and basic operations.\n  - Day 4: Lambda expressions, higher-order functions (filter, map).\n  - Day 5: Scope functions (let, apply).\n  - Weekend: Process a dataset (e.g., a list of users) using collections and lambdas.\n\nWeek 4: Real-world Application\n  - Day 1: Basic coroutines (launch, async).\n  - Day 2: Gradle basics, project setup.\n  - Day 3: Java interoperability (calling Java from Kotlin).\n  - Day 4: Introduction to a library (e.g., Ktor for HTTP).\n  - Day 5: Plan and start a final mini-project.\n  - Weekend: Complete the mini-project.\n*/"
  },
  {
    "title": "Kotlin Certificate",
    "note": "Official or recognized credentials that validate Kotlin proficiency. Certificates can be valuable for career advancement. JetBrains, the creator of Kotlin, does not offer an official certificate itself. However, certifications are available from other providers, such as the 'Kotlin Certified Developer' exam from JetBrains' partner, or certifications based on Kotlin for Android development from Google. Preparation involves deep practical experience and studying the language specification and common idioms.",
    "code": "// While there's no code for a certificate, here's how to prepare:\n\n/*\n1. Master the Topics: Ensure deep understanding of all areas in the syllabus.\n   - Focus especially on null safety, extensions, lambdas, coroutines.\n\n2. Gain Practical Experience:\n   - Build several non-trivial projects (a CLI tool, a backend API, an Android app).\n   - Contribute to open-source Kotlin projects.\n\n3. Practice Exam-Style Questions:\n   - Find sample tests for the specific certification you're targeting.\n   - Understand not just the correct answer, but why the others are wrong.\n\n4. Review Official Resources:\n   - Kotlin Documentation: https://kotlinlang.org/docs/home.html\n   - Kotlin Language Specification: https://kotlinlang.org/spec/\n\n5. Consider Recognized Certifications:\n   - (Check latest offerings from JetBrains partners, Google, or other tech education platforms)\n*/"
  }
],
INTROTOBASICSPROGRAMMING:
  [
{
    "title": "Intro",
    "note": "An introduction to the fundamental concepts of programming. Programming is the process of creating instructions for computers to execute, enabling them to solve problems, process data, and perform tasks. This involves understanding algorithms (step-by-step procedures), syntax (the rules of a programming language), and basic computational thinking. Programming forms the foundation for all software development, from simple scripts to complex artificial intelligence systems.",
    "code": "// Overview of programming basics\n// A simple program structure in a generic language\n\n// 1. Include necessary libraries\n#include <iostream>\n\n// 2. Main function - entry point of the program\nint main() {\n    // 3. Output a message to the console\n    std::cout << \"Hello, World!\" << std::endl;\n    \n    // 4. Return 0 to indicate successful execution\n    return 0;\n}"
  },
  {
    "title": "Programming",
    "note": "The art and science of writing precise instructions (code) that computers can execute to perform specific tasks or solve problems. Programming involves multiple stages: understanding the problem, designing a solution (algorithm), implementing the solution in a programming language, testing and debugging the code, and maintaining it. Different programming paradigms exist, including imperative, object-oriented, functional, and declarative programming, each with its own approach to structuring code and solving problems.",
    "code": "// Write code to solve problems\n\n// Example: Solving a simple mathematical problem\n// Calculate the area of a circle given its radius\n\n#include <iostream>\n#include <cmath> // For M_PI constant\n\nint main() {\n    double radius = 5.0;\n    \n    // Algorithm: area = π * r²\n    double area = M_PI * radius * radius;\n    \n    std::cout << \"Area of circle with radius \" << radius \n              << \" is: \" << area << std::endl;\n    \n    return 0;\n}"
  },
  {
    "title": "Variables",
    "note": "Named storage locations in computer memory that hold data values which can change during program execution. Variables have three main attributes: a name (identifier), a data type (defines what kind of data it can hold), and a value. Variables must be declared before use, specifying their type and name. They provide a way to label and manipulate data, making programs more readable and maintainable. Different languages have different rules for variable naming conventions and scope.",
    "code": "// Variable declaration and initialization in different contexts\n\n// C++ example\nint age = 30; // Integer variable\nfloat temperature = 98.6f; // Floating point variable\nchar grade = 'A'; // Character variable\nbool is_valid = true; // Boolean variable\nstd::string name = \"John Doe\"; // String variable\n\n// JavaScript example (dynamic typing)\nlet age = 30; // Number\nlet message = \"Hello\"; // String\nlet isActive = true; // Boolean\n\n// Python example\nage = 30 # Integer\nname = \"Alice\" # String\nheight = 5.9 # Float\nis_student = True # Boolean"
  },
  {
    "title": "If Statements",
    "note": "Conditional statements that allow a program to execute different code blocks based on whether a specified condition evaluates to true or false. If statements are fundamental to controlling program flow and implementing decision-making logic. They can be extended with else if clauses for multiple conditions and else clauses for default cases. Conditional expressions typically use comparison operators (==, !=, <, >, <=, >=) and logical operators (&&, ||, !) to form complex conditions.",
    "code": "// Various if statement patterns\n\n// Basic if statement\nif (age > 18) {\n    std::cout << \"You are an adult\" << std::endl;\n}\n\n// If-else statement\nif (temperature > 100) {\n    std::cout << \"Fever detected\" << std::endl;\n} else {\n    std::cout << \"Temperature normal\" << std::endl;\n}\n\n// If-else if-else chain\nif (score >= 90) {\n    grade = 'A';\n} else if (score >= 80) {\n    grade = 'B';\n} else if (score >= 70) {\n    grade = 'C';\n} else {\n    grade = 'F';\n}\n\n// Nested if statements\nif (is_authenticated) {\n    if (has_permission) {\n        // Execute privileged operation\n    } else {\n        std::cout << \"Insufficient permissions\" << std::endl;\n    }\n} else {\n    std::cout << \"Please log in\" << std::endl;\n}"
  },
  {
    "title": "Arrays",
    "note": "Data structures that store fixed-size collections of elements of the same type in contiguous memory locations. Arrays provide efficient, index-based access to elements (typically starting at index 0). They are fundamental for working with collections of data and form the basis for more complex data structures. Arrays can be single-dimensional (lists) or multi-dimensional (matrices, tables). Key operations include accessing elements, iterating through elements, and sometimes sorting or searching.",
    "code": "// Array declaration, initialization, and usage\n\n// Declaration and initialization\nint numbers[5] = {1, 2, 3, 4, 5}; // Fixed-size array\nint scores[] = {95, 87, 92, 78}; // Size inferred\n\n// Multi-dimensional array (matrix)\nint matrix[2][3] = {\n    {1, 2, 3},\n    {4, 5, 6}\n};\n\n// Accessing array elements\nint first = numbers[0]; // First element (index 0)\nint last = numbers[4]; // Last element (index 4)\n\n// Modifying array elements\nnumbers[2] = 10; // Change third element\n\n// Iterating through arrays\nfor (int i = 0; i < 5; i++) {\n    std::cout << numbers[i] << \" \";\n}\nstd::cout << std::endl;\n\n// Array length (where supported)\nint length = sizeof(numbers) / sizeof(numbers[0]);"
  },
  {
    "title": "Loops",
    "note": "Control flow statements that repeatedly execute a block of code as long as a specified condition remains true. Loops are essential for automating repetitive tasks, processing collections of data, and implementing iterative algorithms. The main types are: for loops (iterate a specific number of times), while loops (execute while condition is true), and do-while loops (execute at least once, then check condition). Loop control statements like break and continue modify loop behavior.",
    "code": "// Different types of loops\n\n// For loop (definite iteration)\nfor (int i = 0; i < 5; i++) {\n    std::cout << \"Iteration \" << i << std::endl;\n}\n\n// While loop (indefinite iteration)\nint count = 0;\nwhile (count < 5) {\n    std::cout << \"Count: \" << count << std::endl;\n    count++;\n}\n\n// Do-while loop (executes at least once)\nint input;\ndo {\n    std::cout << \"Enter a positive number: \";\n    std::cin >> input;\n} while (input <= 0);\n\n// Range-based for loop (C++11 and later)\nint arr[] = {1, 2, 3, 4, 5};\nfor (int num : arr) {\n    std::cout << num << \" \";\n}\n\n// Nested loops\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        std::cout << \"(\" << i << \",\" << j << \") \";\n    }\n    std::cout << std::endl;\n}"
  },
  {
    "title": "Functions",
    "note": "Self-contained blocks of code that perform specific tasks and can be reused throughout a program. Functions promote modularity, code organization, and reuse. They typically take input parameters, perform operations, and return a result. Functions consist of: a signature (name, parameters, return type), a body (implementation), and a return statement. Well-designed functions should have a single responsibility, be named clearly, and minimize side effects. Functions can call other functions, enabling complex behavior through composition.",
    "code": "// Function declarations, definitions, and calls\n\n// Function declaration (prototype)\ndouble calculateArea(double radius);\n\n// Function definition\ndouble calculateArea(double radius) {\n    return 3.14159 * radius * radius;\n}\n\n// Function with multiple parameters\nint addNumbers(int a, int b) {\n    return a + b;\n}\n\n// Void function (no return value)\nvoid printWelcome(std::string name) {\n    std::cout << \"Welcome, \" << name << \"!\" << std::endl;\n}\n\n// Function with default parameters\nvoid displayMessage(std::string msg = \"Hello\") {\n    std::cout << msg << std::endl;\n}\n\n// Function call examples\nint main() {\n    double area = calculateArea(5.0);\n    int sum = addNumbers(10, 20);\n    printWelcome(\"Alice\");\n    displayMessage(); // Uses default parameter\n    displayMessage(\"Custom message\");\n    \n    return 0;\n}"
  },
  {
    "title": "Scope",
    "note": "The region of a program where a variable or function is visible and accessible. Scope determines the lifetime and visibility of identifiers. Main types include: global scope (accessible throughout the program), local scope (accessible only within a block, typically a function), and block scope (accessible only within a specific code block). Understanding scope is crucial for avoiding naming conflicts, managing memory efficiently, and writing maintainable code. Different languages have different scoping rules (lexical vs. dynamic scope).",
    "code": "// Examples of different scopes\n\n#include <iostream>\n\n// Global variable (global scope)\nint globalVar = 100;\n\nvoid exampleFunction(int param) { // param has function scope\n    // Local variable (function scope)\n    int localVar = 50;\n    \n    std::cout << \"Global variable: \" << globalVar << std::endl;\n    std::cout << \"Parameter: \" << param << std::endl;\n    std::cout << \"Local variable: \" << localVar << std::endl;\n    \n    // Block scope example\n    if (true) {\n        int blockVar = 25; // Only accessible in this block\n        std::cout << \"Block variable: \" << blockVar << std::endl;\n    }\n    \n    // blockVar is not accessible here - would cause error\n    // std::cout << blockVar << std::endl;\n}\n\nint main() {\n    exampleFunction(10);\n    \n    // localVar is not accessible here - would cause error\n    // std::cout << localVar << std::endl;\n    \n    return 0;\n}"
  },
  {
    "title": "Data Types",
    "note": "Classifications that specify which type of value a variable can hold and what operations can be performed on it. Data types determine how much memory is allocated, how the bits are interpreted, and what operations are valid. Primitive types include integers (whole numbers), floating-point numbers (decimals), characters (single symbols), and booleans (true/false). Composite types include arrays, strings, structures, and classes. Strongly typed languages enforce strict type rules, while weakly typed languages allow more flexibility.",
    "code": "// Examples of different data types\n\n// Integer types (various sizes and signedness)\nshort smallNumber = 100; // Typically 2 bytes\nint normalNumber = 1000; // Typically 4 bytes\nlong bigNumber = 1000000L; // Typically 4 or 8 bytes\nunsigned int positiveOnly = 500; // Non-negative\n\n// Floating-point types\nfloat price = 19.99f; // Single precision, typically 4 bytes\ndouble preciseValue = 3.1415926535; // Double precision, typically 8 bytes\n\n// Character type\nchar letter = 'A'; // Single character\nchar newline = '\\n'; // Escape sequence\n\n// Boolean type\nbool is_valid = true;\nbool is_finished = false;\n\n// String type (not primitive in C++)\n#include <string>\nstd::string name = \"John Smith\";\n\n// Type modifiers\nconst int MAX_SIZE = 100; // Constant, cannot be changed\nvolatile int sensorReading; // May change unexpectedly\n\n// Type conversion\nint integerPart = (int)preciseValue; // Explicit cast\ndouble result = normalNumber + preciseValue; // Implicit conversion"
  },
  {
    "title": "Operators",
    "note": "Symbols that perform operations on variables and values. Operators are classified by their functionality: arithmetic (mathematical operations), comparison (compare values), logical (boolean logic), assignment (assign values), bitwise (manipulate bits), and others. Operators have precedence rules that determine the order of operations when multiple operators appear in an expression. Understanding operators is essential for writing expressions that manipulate data and control program flow correctly.",
    "code": "// Examples of different operator types\n\n// Arithmetic operators\nint sum = 5 + 3; // Addition: 8\nint difference = 5 - 3; // Subtraction: 2\nint product = 5 * 3; // Multiplication: 15\nint quotient = 15 / 4; // Division: 3 (integer division)\nint remainder = 15 % 4; // Modulus: 3\n\n// Comparison operators\nbool isEqual = (5 == 3); // Equal to: false\nbool notEqual = (5 != 3); // Not equal to: true\nbool greater = (5 > 3); // Greater than: true\nbool less = (5 < 3); // Less than: false\nbool greaterOrEqual = (5 >= 3); // Greater or equal: true\nbool lessOrEqual = (5 <= 3); // Less or equal: false\n\n// Logical operators\nbool andResult = (true && false); // Logical AND: false\nbool orResult = (true || false); // Logical OR: true\nbool notResult = !true; // Logical NOT: false\n\n// Assignment operators\nint x = 10; // Simple assignment\nx += 5; // Add and assign: x = x + 5\nx -= 3; // Subtract and assign: x = x - 3\nx *= 2; // Multiply and assign: x = x * 2\nx /= 4; // Divide and assign: x = x / 4\nx %= 3; // Modulus and assign: x = x % 3\n\n// Increment/decrement operators\nint y = 5;\ny++; // Post-increment: y = 6\n++y; // Pre-increment: y = 7\ny--; // Post-decrement: y = 6\n--y; // Pre-decrement: y = 5\n\n// Ternary operator\nint max = (x > y) ? x : y; // Returns larger value"
  },
  {
    "title": "Comments",
    "note": "Non-executable annotations in source code that explain functionality, provide context, or temporarily disable code. Comments are ignored by compilers and interpreters but are essential for human readers. They improve code readability, maintainability, and collaboration. Types include: single-line comments (//), multi-line comments (/* */), and documentation comments (/** */) that can generate API documentation. Good comments explain why code exists, not what it does (which should be clear from the code itself).",
    "code": "// Examples of different comment types and styles\n\n// Single-line comment - explains the following line\nint count = 0; // Initialize counter variable\n\n/*\n * Multi-line comment\n * Provides detailed explanation across multiple lines\n * Often used for file headers or complex algorithm explanations\n */\n\n/**\n * Documentation comment (often used with tools like Doxygen or Javadoc)\n * @brief Calculates the area of a circle\n * @param radius The radius of the circle\n * @return The area of the circle\n */\ndouble calculateCircleArea(double radius) {\n    return 3.14159 * radius * radius;\n}\n\n// TODO comments mark unfinished work or future improvements\n// TODO: Implement error handling for negative radii\n\n// FIXME comments mark known issues that need correction\n// FIXME: This algorithm is inefficient for large inputs\n\n// NOTE comments highlight important information\n// NOTE: This function assumes input is already validated\n\n// Commented-out code (temporarily disabled)\n// std::cout << \"Debug: value is \" << value << std::endl;\n\n// Good comments explain why, not what\n// Using bitwise AND for efficiency with large datasets\nint result = value & mask;"
  },
  {
    "title": "Bits and Bytes",
    "note": "The fundamental units of digital information. A bit (binary digit) is the smallest unit, representing either 0 or 1. A byte is a group of 8 bits, capable of representing 256 different values (2^8). Bytes are the basic addressable units in most computer architectures. Understanding bits and bytes is essential for low-level programming, memory management, data representation, and working with binary data. Larger units include kilobyte (KB, 1024 bytes), megabyte (MB), gigabyte (GB), and terabyte (TB).",
    "code": "// Examples of bit and byte manipulation\n\n#include <iostream>\n#include <bitset> // For binary representation\n\nint main() {\n    // A byte (8 bits) can represent values from 0 to 255\n    unsigned char byte = 65; // Decimal 65\n    std::cout << \"Decimal: \" << (int)byte << std::endl; // 65\n    std::cout << \"Binary: \" << std::bitset<8>(byte) << std::endl; // 01000001\n    std::cout << \"Hexadecimal: 0x\" << std::hex << (int)byte << std::endl; // 0x41\n    std::cout << \"Character: \" << byte << std::endl; // 'A' (ASCII)\n    \n    // Bit manipulation\n    byte = 0b00001111; // Binary literal (C++14)\n    std::cout << \"Original: \" << std::bitset<8>(byte) << std::endl; // 00001111\n    \n    // Setting a bit (bit 5, 0-indexed from right)\n    byte |= (1 << 5); // OR with 00100000\n    std::cout << \"Set bit 5: \" << std::bitset<8>(byte) << std::endl; // 00101111\n    \n    // Clearing a bit (bit 2)\n    byte &= ~(1 << 2); // AND with 11111011\n    std::cout << \"Clear bit 2: \" << std::bitset<8>(byte) << std::endl; // 00101011\n    \n    // Toggling a bit (bit 3)\n    byte ^= (1 << 3); // XOR with 00001000\n    std::cout << \"Toggle bit 3: \" << std::bitset<8>(byte) << std::endl; // 00100011\n    \n    // Checking a bit (bit 5)\n    bool isSet = (byte & (1 << 5)) != 0;\n    std::cout << \"Bit 5 is set: \" << isSet << std::endl; // true\n    \n    return 0;\n}"
  },
  {
    "title": "Binary Numbers",
    "note": "A base-2 numeral system that uses only two symbols: 0 and 1. Each digit in a binary number is called a bit. Binary is the fundamental language of computers, as digital circuits naturally represent two states (on/off, high/low voltage). Understanding binary is essential for low-level programming, bit manipulation, and understanding how computers represent and process data. Binary numbers can be converted to and from decimal (base-10), hexadecimal (base-16), and other numeral systems.",
    "code": "// Binary number examples and operations\n\n#include <iostream>\n#include <bitset>\n#include <cmath>\n\n// Function to convert decimal to binary (as string)\nstd::string decimalToBinary(int n) {\n    if (n == 0) return \"0\";\n    std::string binary;\n    while (n > 0) {\n        binary = (n % 2 == 0 ? \"0\" : \"1\") + binary;\n        n /= 2;\n    }\n    return binary;\n}\n\n// Function to convert binary to decimal\nint binaryToDecimal(std::string binary) {\n    int decimal = 0;\n    int power = 0;\n    for (int i = binary.length() - 1; i >= 0; i--) {\n        if (binary[i] == '1') {\n            decimal += pow(2, power);\n        }\n        power++;\n    }\n    return decimal;\n}\n\nint main() {\n    // Binary literals (C++14)\n    int bin1 = 0b1010; // Decimal 10\n    int bin2 = 0b1100; // Decimal 12\n    \n    std::cout << \"Binary 1010 = \" << bin1 << std::endl;\n    std::cout << \"Binary 1100 = \" << bin2 << std::endl;\n    \n    // Binary operations\n    int andResult = bin1 & bin2; // Bitwise AND: 0b1000 (8)\n    int orResult = bin1 | bin2;  // Bitwise OR: 0b1110 (14)\n    int xorResult = bin1 ^ bin2; // Bitwise XOR: 0b0110 (6)\n    \n    std::cout << \"1010 AND 1100 = \" << std::bitset<4>(andResult) \n              << \" (\" << andResult << \")\" << std::endl;\n    std::cout << \"1010 OR 1100 = \" << std::bitset<4>(orResult) \n              << \" (\" << orResult << \")\" << std::endl;\n    std::cout << \"1010 XOR 1100 = \" << std::bitset<4>(xorResult) \n              << \" (\" << xorResult << \")\" << std::endl;\n    \n    // Bit shifting\n    int leftShift = bin1 << 2; // 1010 << 2 = 101000 (40)\n    int rightShift = bin1 >> 1; // 1010 >> 1 = 0101 (5)\n    \n    std::cout << \"1010 << 2 = \" << std::bitset<6>(leftShift) \n              << \" (\" << leftShift << \")\" << std::endl;\n    std::cout << \"1010 >> 1 = \" << std::bitset<4>(rightShift) \n              << \" (\" << rightShift << \")\" << std::endl;\n    \n    // Conversion functions\n    std::cout << \"Decimal 25 to binary: \" << decimalToBinary(25) << std::endl;\n    std::cout << \"Binary 11001 to decimal: \" << binaryToDecimal(\"11001\") << std::endl;\n    \n    return 0;\n}"
  },
  {
    "title": "Hexadecimal Numbers",
    "note": "A base-16 numeral system that uses 16 symbols: 0-9 and A-F (or a-f), where A=10, B=11, C=12, D=13, E=14, F=15. Hexadecimal is widely used in programming because it provides a more compact representation of binary data (each hex digit represents 4 bits) and is easier for humans to read than long binary strings. Hex is commonly used for memory addresses, color codes, bitmask representations, and debugging low-level code.",
    "code": "// Hexadecimal number examples and operations\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n\n// Function to convert decimal to hexadecimal (as string)\nstd::string decimalToHex(int n) {\n    std::stringstream ss;\n    ss << std::hex << n;\n    return ss.str();\n}\n\n// Function to convert hexadecimal to decimal\nint hexToDecimal(std::string hex) {\n    int decimal;\n    std::stringstream ss;\n    ss << std::hex << hex;\n    ss >> decimal;\n    return decimal;\n}\n\nint main() {\n    // Hexadecimal literals\n    int hex1 = 0x1A; // Decimal 26\n    int hex2 = 0xFF; // Decimal 255\n    int hex3 = 0xDEAD; // Decimal 57005\n    \n    std::cout << \"0x1A = \" << hex1 << \" decimal\" << std::endl;\n    std::cout << \"0xFF = \" << hex2 << \" decimal\" << std::endl;\n    std::cout << \"0xDEAD = \" << hex3 << \" decimal\" << std::endl;\n    \n    // Output in hexadecimal format\n    int decimal = 42;\n    std::cout << \"Decimal \" << decimal << \" = 0x\" \n              << std::hex << std::uppercase << decimal << std::endl;\n    \n    // Reset to decimal output\n    std::cout << std::dec << \"Back to decimal: \" << decimal << std::endl;\n    \n    // Hexadecimal for memory addresses\n    int value = 100;\n    std::cout << \"Value address: 0x\" << &value << std::endl;\n    \n    // Hexadecimal for RGB color representation\n    int red = 0xFF0000; // Pure red\n    int green = 0x00FF00; // Pure green\n    int blue = 0x0000FF; // Pure blue\n    int white = 0xFFFFFF; // White\n    \n    std::cout << \"Red: #\" << std::setw(6) << std::setfill('0') \n              << std::hex << red << std::endl;\n    std::cout << \"Green: #\" << std::setw(6) << std::setfill('0') \n              << green << std::endl;\n    std::cout << \"Blue: #\" << std::setw(6) << std::setfill('0') \n              << blue << std::endl;\n    \n    // Conversion functions\n    std::cout << \"Decimal 255 to hex: 0x\" << decimalToHex(255) << std::endl;\n    std::cout << \"Hex FF to decimal: \" << hexToDecimal(\"FF\") << std::endl;\n    \n    // Relationship with binary\n    // Each hex digit represents 4 bits\n    std::cout << \"Hex 0x5 = Binary \" << std::bitset<4>(0x5) << std::endl;\n    std::cout << \"Hex 0xA = Binary \" << std::bitset<4>(0xA) << std::endl;\n    std::cout << \"Hex 0xF = Binary \" << std::bitset<4>(0xF) << std::endl;\n    \n    return 0;\n}"
  },
  {
    "title": "Boolean Algebra",
    "note": "A branch of algebra that deals with binary variables and logical operations. Developed by George Boole in the 19th century, it forms the mathematical foundation of digital circuit design and computer logic. The three basic operations are AND (conjunction), OR (disjunction), and NOT (negation). Boolean algebra follows specific laws and properties (commutative, associative, distributive, identity, complement, De Morgan's laws) that allow simplification of logical expressions, which is crucial for optimizing digital circuits and conditional logic in programming.",
    "code": "// Boolean algebra examples and laws\n\n#include <iostream>\n#include <cmath>\n\n// Function to evaluate boolean expression\nbool evaluate(bool a, bool b, bool c) {\n    return (a && b) || (!a && c);\n}\n\n// Function to demonstrate De Morgan's Laws\nvoid deMorgansLaws(bool a, bool b) {\n    bool left1 = !(a && b);\n    bool right1 = !a || !b;\n    \n    bool left2 = !(a || b);\n    bool right2 = !a && !b;\n    \n    std::cout << \"De Morgan's First Law: !(a && b) = !a || !b\" << std::endl;\n    std::cout << \"For a=\" << a << \", b=\" << b << \": \" << left1 << \" = \" << right1 << std::endl;\n    \n    std::cout << \"De Morgan's Second Law: !(a || b) = !a && !b\" << std::endl;\n    std::cout << \"For a=\" << a << \", b=\" << b << \": \" << left2 << \" = \" << right2 << std::endl;\n}\n\nint main() {\n    // Truth table for basic operations\n    std::cout << \"AND Truth Table (a && b):\" << std::endl;\n    std::cout << \"0 AND 0 = \" << (false && false) << std::endl;\n    std::cout << \"0 AND 1 = \" << (false && true) << std::endl;\n    std::cout << \"1 AND 0 = \" << (true && false) << std::endl;\n    std::cout << \"1 AND 1 = \" << (true && true) << std::endl;\n    \n    std::cout << \"\\nOR Truth Table (a || b):\" << std::endl;\n    std::cout << \"0 OR 0 = \" << (false || false) << std::endl;\n    std::cout << \"0 OR 1 = \" << (false || true) << std::endl;\n    std::cout << \"1 OR 0 = \" << (true || false) << std::endl;\n    std::cout << \"1 OR 1 = \" << (true || true) << std::endl;\n    \n    std::cout << \"\\nNOT Truth Table (!a):\" << std::endl;\n    std::cout << \"NOT 0 = \" << (!false) << std::endl;\n    std::cout << \"NOT 1 = \" << (!true) << std::endl;\n    \n    // Boolean algebra laws\n    bool a = true, b = false, c = true;\n    \n    // Commutative Law: a && b = b && a, a || b = b || a\n    std::cout << \"\\nCommutative Law:\" << std::endl;\n    std::cout << \"a && b = \" << (a && b) << \", b && a = \" << (b && a) << std::endl;\n    std::cout << \"a || b = \" << (a || b) << \", b || a = \" << (b || a) << std::endl;\n    \n    // Associative Law: (a && b) && c = a && (b && c)\n    std::cout << \"\\nAssociative Law:\" << std::endl;\n    std::cout << \"(a && b) && c = \" << ((a && b) && c) << std::endl;\n    std::cout << \"a && (b && c) = \" << (a && (b && c)) << std::endl;\n    \n    // Distributive Law: a && (b || c) = (a && b) || (a && c)\n    std::cout << \"\\nDistributive Law:\" << std::endl;\n    std::cout << \"a && (b || c) = \" << (a && (b || c)) << std::endl;\n    std::cout << \"(a && b) || (a && c) = \" << ((a && b) || (a && c)) << std::endl;\n    \n    // De Morgan's Laws\n    std::cout << \"\\n\";\n    deMorgansLaws(a, b);\n    \n    // Boolean expression evaluation\n    std::cout << \"\\nExpression: (a && b) || (!a && c)\" << std::endl;\n    std::cout << \"For a=\" << a << \", b=\" << b << \", c=\" << c \n              << \": \" << evaluate(a, b, c) << std::endl;\n    \n    // Application: Conditional logic\n    int age = 25;\n    bool hasLicense = true;\n    bool canDrive = (age >= 16) && hasLicense;\n    \n    std::cout << \"\\nDriving eligibility:\" << std::endl;\n    std::cout << \"Age: \" << age << \", Has License: \" << hasLicense << std::endl;\n    std::cout << \"Can Drive: \" << canDrive << std::endl;\n    \n    return 0;\n}"
  }
],
Rust:
[
{
  "title": "Rust HOME",
    "note": "Rust is a modern systems programming language focused on safety, performance, and concurrency. Official resources include: The Rust Programming Language book (The Book), Rust by Example, Standard Library Documentation, Cargo package manager, Crates.io registry, and Rust Playground for online coding.",
    "code": "// Official website: https://www.rust-lang.org/\n// Documentation: https://doc.rust-lang.org/\n// Community: https://users.rust-lang.org/"
  },
  {
    "title": "Rust Intro",
    "note": "Rust provides zero-cost abstractions, memory safety without garbage collection, and fearless concurrency. Key features: ownership system, pattern matching, trait system, and strong type inference. Used for system programming, web assembly, CLI tools, and embedded systems.",
    "code": "// Key principles: Safety, Speed, Concurrency\n// Compiles to native code with LLVM backend\n// No runtime or garbage collector"
  },
  {
    "title": "Rust Get Started",
    "note": "Install Rust using rustup toolchain manager. Verify installation with rustc --version and cargo --version. Create new projects with cargo new project_name. Build and run with cargo build and cargo run. Cargo.toml manages dependencies and project metadata.",
    "code": "// Installation command:\n// curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n// Create and run project:\n// cargo new hello_world\n// cd hello_world\n// cargo run"
  },
  {
    "title": "Rust Syntax",
    "note": "Rust uses semicolons to end statements. Variables declared with let keyword. Functions use fn keyword. Blocks are enclosed in curly braces {}. Type annotations often optional due to type inference. Snake_case convention for variables and functions.",
    "code": "// Basic syntax structure:\nfn function_name(param: Type) -> ReturnType {\n    let variable = expression;\n    statement;\n    return_value\n}"
  },
  {
    "title": "Rust Output",
    "note": "println! macro prints to stdout with newline. print! macro prints without newline. format! macro returns formatted string. eprintln! and eprint! for stderr. Supports positional and named parameters with formatting specifiers.",
    "code": "println!(\"Hello, {}!\", \"world\");\nprintln!(\"Number: {}\", 42);\nprintln!(\"Formatted: {:.2}\", 3.14159);\nprintln!(\"Positional: {0} {1}\", \"first\", \"second\");\nprintln!(\"Named: {name} is {age}\", name=\"Alice\", age=30);"
  },
  {
    "title": "Rust Comments",
    "note": "Single-line comments start with //. Multi-line comments use /* */. Documentation comments use /// for items and //! for module/crate-level docs. Documentation comments support Markdown and generate HTML docs with cargo doc.",
    "code": "// Regular comment\n\n/// Documentation comment for function\n/// # Examples\n/// ```\n/// let result = add(2, 3);\n/// assert_eq!(result, 5);\n/// ```\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n/* Multi-line\n   comment spanning\n   multiple lines */"
  },
  {
    "title": "Rust Variables",
    "note": "Variables immutable by default for safety. mut keyword makes variables mutable. Variables are block-scoped. Shadowing allows redeclaring variables with same name. Variables must be initialized before use. Type can be inferred or explicitly annotated.",
    "code": "let x = 5;           // immutable\nlet mut y = 10;      // mutable\ny = 15;\n\nlet z = 5;           // shadowing\nlet z = z + 1;       // new variable with same name\nlet z = \"hello\";     // can change type with shadowing\n\n// Type annotations\nlet a: i32 = 42;\nlet b = 3.14_f64;    // suffix annotation"
  },
  {
    "title": "Rust Data Types",
    "note": "Scalar types: integers (i8-u128, isize-usize), floats (f32, f64), boolean (bool), character (char, 4-byte Unicode). Compound types: tuples, arrays. Integer literals: 98_222, 0xff, 0o77, 0b1111_0000, b'A'. Float has IEEE-754 representation.",
    "code": "// Integer types\nlet decimal = 98_222;\nlet hex = 0xff;\nlet octal = 0o77;\nlet binary = 0b1111_0000;\nlet byte = b'A';      // u8\n\n// Floating point\nlet x = 2.0;         // f64\nlet y: f32 = 3.0;    // f32\n\n// Boolean\nlet t = true;\nlet f: bool = false;\n\n// Character (Unicode)\nlet c = 'z';\nlet heart = '💖';\n\n// Tuple\nlet tup: (i32, f64, u8) = (500, 6.4, 1);\nlet (x, y, z) = tup;  // destructuring\n\n// Array (fixed size)\nlet a = [1, 2, 3, 4, 5];\nlet months = [\"Jan\", \"Feb\", \"Mar\"];\nlet first = a[0];"
  },
  {
    "title": "Rust Constants",
    "note": "Constants always immutable and must have type annotation. Can be declared in any scope including global. Evaluated at compile time. Naming convention: SCREAMING_SNAKE_CASE. Valid for entire program runtime. Can use simple expressions and literals.",
    "code": "const MAX_POINTS: u32 = 100_000;\nconst HOURS_IN_DAY: u32 = 24;\nconst MINUTES_IN_HOUR: u32 = 60;\nconst SECONDS_IN_MINUTE: u32 = 60;\nconst SECONDS_IN_DAY: u32 = HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE;\n\n// Global constant\nconst PI: f64 = 3.141592653589793;\n\nfn main() {\n    println!(\"Max points: {}\", MAX_POINTS);\n    println!(\"Pi: {}\", PI);\n}"
  },
  {
    "title": "Rust Operators",
    "note": "Arithmetic: +, -, *, /, %. Comparison: ==, !=, <, >, <=, >=. Logical: &&, ||, !. Bitwise: &, |, ^, <<, >>. Assignment: =, +=, -=, *=, /=, %=. Type cast: as keyword. Range: .. (exclusive), ..= (inclusive).",
    "code": "// Arithmetic\nlet sum = 5 + 10;\nlet difference = 95.5 - 4.3;\nlet product = 4 * 30;\nlet quotient = 56.7 / 32.2;\nlet remainder = 43 % 5;\n\n// Comparison\nlet equal = 5 == 5;\nlet not_equal = 5 != 3;\nlet greater = 5 > 3;\n\n// Logical\nlet and = true && false;\nlet or = true || false;\nlet not = !true;\n\n// Bitwise\nlet bit_and = 0b1010 & 0b1100;  // 0b1000\nlet bit_or = 0b1010 | 0b1100;   // 0b1110\nlet shift_left = 1 << 3;        // 8\n\n// Assignment\nlet mut x = 5;\nx += 1;      // x = x + 1\n\n// Type casting\nlet x = 5_i32 as f64;  // 5.0\n\n// Range\nlet range = 1..5;     // 1, 2, 3, 4\nlet inclusive = 1..=5; // 1, 2, 3, 4, 5"
  },
  {
    "title": "Rust Booleans",
    "note": "bool type with values true and false. Size is 1 byte. Used in conditional expressions, logical operations, and as return values for comparisons. No implicit conversion to/from other types. Can be converted explicitly with as keyword.",
    "code": "let t = true;\nlet f: bool = false;\n\n// From expressions\nlet is_greater = 5 > 3;        // true\nlet is_equal = 5 == 5;         // true\n\n// Logical operations\nlet and = true && false;       // false\nlet or = true || false;        // true\nlet not = !true;               // false\n\n// Conditional usage\nif is_greater {\n    println!(\"5 is greater than 3\");\n}\n\n// Explicit conversion\nlet from_int = 1 != 0;         // true\nlet as_u8 = true as u8;        // 1\nlet as_i32 = false as i32;     // 0"
  },
  {
    "title": "Rust If..Else",
    "note": "Condition must be bool type (no truthy/falsy values). Blocks must return same type if used in expressions. Can be used as expression returning value. else if for multiple conditions. No parentheses around condition.",
    "code": "// Basic if-else\nlet number = 6;\n\nif number % 4 == 0 {\n    println!(\"divisible by 4\");\n} else if number % 3 == 0 {\n    println!(\"divisible by 3\");\n} else if number % 2 == 0 {\n    println!(\"divisible by 2\");\n} else {\n    println!(\"not divisible by 4, 3, or 2\");\n}\n\n// If as expression\nlet condition = true;\nlet result = if condition {\n    5\n} else {\n    6\n};  // result is 5\n\n// Multiple conditions\nlet x = 5;\nlet y = 10;\n\nif x > 0 && y > 0 {\n    println!(\"Both are positive\");\n}\n\n// Pattern matching in conditions\nlet some_value = Some(5);\nif let Some(value) = some_value {\n    println!(\"Got value: {}\", value);\n}"
  },
  {
    "title": "Rust Match",
    "note": "Exhaustive - must cover all possibilities. Patterns can match literals, variables, wildcards, ranges. Can destructure tuples, arrays, structs, enums. Guards add extra conditions to patterns. @ binding captures value while matching.",
    "code": "let number = 13;\n\nmatch number {\n    1 => println!(\"One\"),\n    2 | 3 | 5 | 7 | 11 => println!(\"Prime\"),\n    13..=19 => println!(\"Teen\"),\n    n if n % 2 == 0 => println!(\"Even: {}\", n),\n    _ => println!(\"Other\"),\n}\n\n// Matching with values\nlet result = match number {\n    1 => \"one\",\n    2 => \"two\",\n    _ => \"many\",\n};\n\n// Destructuring tuples\nlet pair = (0, -2);\nmatch pair {\n    (0, y) => println!(\"First is 0, y is {}\", y),\n    (x, 0) => println!(\"Second is 0, x is {}\", x),\n    _ => println!(\"No zero\"),\n}\n\n// Guards\nmatch number {\n    n if n < 0 => println!(\"Negative\"),\n    n if n > 0 => println!(\"Positive\"),\n    _ => println!(\"Zero\"),\n}\n\n// @ binding\nmatch number {\n    n @ 1..=12 => println!(\"Small number: {}\", n),\n    n @ 13..=19 => println!(\"Teen: {}\", n),\n    n => println!(\"Other number: {}\", n),\n}"
  },
  {
    "title": "Rust Loops",
    "note": "Three types: loop (infinite), while (conditional), for (iterator-based). loop can return values with break expression. while let for pattern matching conditions. for loops work with any iterator. Labels for breaking outer loops.",
    "code": "// Infinite loop with break\nlet mut counter = 0;\nlet result = loop {\n    counter += 1;\n    if counter == 10 {\n        break counter * 2;\n    }\n};  // result = 20\n\n// While loop\nlet mut number = 3;\nwhile number != 0 {\n    println!(\"{}\", number);\n    number -= 1;\n}\n\n// For loop with range\nfor number in 1..4 {\n    println!(\"{}\", number);  // 1, 2, 3\n}\n\nfor number in (1..4).rev() {\n    println!(\"{}\", number);  // 3, 2, 1\n}\n\n// While let pattern matching\nlet mut stack = Vec::new();\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\nwhile let Some(top) = stack.pop() {\n    println!(\"{}\", top);  // 3, 2, 1\n}\n\n// Labeled loops\n'outer: loop {\n    'inner: loop {\n        break 'outer;  // breaks outer loop\n    }\n}\n\n// For with collections\nlet arr = [10, 20, 30, 40, 50];\nfor element in arr.iter() {\n    println!(\"{}\", element);\n}\n\n// For with index and value\nfor (index, value) in arr.iter().enumerate() {\n    println!(\"Index: {}, Value: {}\", index, value);\n}"
  },
  {
    "title": "Rust While Loops",
    "note": "Executes block while condition is true. Condition evaluated before each iteration. Useful when number of iterations unknown. while let combines pattern matching with looping. No do-while loop, but can emulate with loop and break.",
    "code": "// Basic while\nlet mut count = 0;\nwhile count < 5 {\n    println!(\"Count: {}\", count);\n    count += 1;\n}\n\n// While with complex condition\nlet mut a = 0;\nlet mut b = 1;\nwhile a < 100 && b < 200 {\n    println!(\"a: {}, b: {}\", a, b);\n    a += 1;\n    b += 2;\n}\n\n// While let with Option\nlet mut optional = Some(0);\nwhile let Some(i) = optional {\n    if i > 9 {\n        optional = None;\n    } else {\n        println!(\"i: {}\", i);\n        optional = Some(i + 1);\n    }\n}\n\n// While let with Result\nlet mut input = \"123\";\nwhile let Ok(num) = input.parse::<i32>() {\n    println!(\"Parsed: {}\", num);\n    input = \"done\";  // Next parse will fail\n}\n\n// Emulating do-while\nlet mut condition = true;\nwhile condition {\n    println!(\"This runs at least once\");\n    condition = false;\n}\n\n// Alternative do-while emulation\nloop {\n    println!(\"This runs at least once\");\n    if !condition {\n        break;\n    }\n}"
  },
  {
    "title": "Rust For Loops",
    "note": "Most common loop type. Works with iterators and anything implementing IntoIterator trait. Range syntax: start..end (exclusive), start..=end (inclusive). iter() for borrowing, iter_mut() for mutable borrowing, into_iter() for ownership.",
    "code": "// Range loops\nfor i in 0..5 {\n    println!(\"{}\", i);  // 0, 1, 2, 3, 4\n}\n\nfor i in 0..=5 {\n    println!(\"{}\", i);  // 0, 1, 2, 3, 4, 5\n}\n\n// Array iteration\nlet arr = [10, 20, 30, 40, 50];\nfor element in &arr {          // borrow\n    println!(\"{}\", element);\n}\n\nfor element in arr.iter() {    // same as above\n    println!(\"{}\", element);\n}\n\n// Vector iteration\nlet mut vec = vec![1, 2, 3];\nfor element in vec.iter_mut() {  // mutable borrow\n    *element *= 2;\n}\n\n// String characters\nfor c in \"hello\".chars() {\n    println!(\"{}\", c);\n}\n\n// With enumerate\nfor (index, value) in arr.iter().enumerate() {\n    println!(\"Index {}: Value {}\", index, value);\n}\n\n// Filtering with filter\nfor n in (1..10).filter(|&x| x % 2 == 0) {\n    println!(\"Even: {}\", n);  // 2, 4, 6, 8\n}\n\n// Multiple ranges with zip\nlet names = [\"Alice\", \"Bob\", \"Charlie\"];\nlet ages = [25, 30, 35];\nfor (name, age) in names.iter().zip(ages.iter()) {\n    println!(\"{} is {} years old\", name, age);\n}\n\n// Reverse iteration\nfor i in (0..5).rev() {\n    println!(\"{}\", i);  // 4, 3, 2, 1, 0\n}"
  },
  {
    "title": "Rust Functions",
    "note": "Declared with fn keyword. Parameters require type annotations. Return type specified with ->. Last expression implicitly returned, or use return keyword early. Functions can be generic. Associated functions (like static methods) use impl blocks.",
    "code": "// Basic function\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\n// Multiple parameters\nfn print_sum(a: i32, b: i32) {\n    println!(\"Sum: {}\", a + b);\n}\n\n// Explicit return\nfn early_return(x: i32) -> i32 {\n    if x < 0 {\n        return 0;  // early return\n    }\n    x * 2         // implicit return\n}\n\n// Function expressions\nlet multiply = |x, y| x * y;\nlet result = multiply(5, 3);\n\n// Generic function\nfn largest<T: PartialOrd>(list: &[T]) -> &T {\n    let mut largest = &list[0];\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n    largest\n}\n\n// Associated function\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nimpl Point {\n    fn new(x: f64, y: f64) -> Point {\n        Point { x, y }\n    }\n    \n    fn distance(&self, other: &Point) -> f64 {\n        ((other.x - self.x).powi(2) + (other.y - self.y).powi(2)).sqrt()\n    }\n}\n\n// Method call\nlet p1 = Point::new(0.0, 0.0);\nlet p2 = Point::new(3.0, 4.0);\nlet dist = p1.distance(&p2);"
  },
  {
    "title": "Rust Scope",
    "note": "Variables live from declaration to end of block. Blocks create new scopes. Inner scopes can shadow outer variables. Ownership rules apply when moving between scopes. References have lifetime scopes. const and static have global scope.",
    "code": "// Basic scoping\nlet x = 5;          // outer scope\n\n{\n    let y = 10;     // inner scope\n    println!(\"x: {}, y: {}\", x, y);  // both accessible\n}                   // y dropped here\n\n// println!(\"{}\", y);  // Error: y not in scope\n\n// Shadowing in different scopes\nlet z = 5;\n{\n    let z = 10;     // shadows outer z\n    println!(\"Inner z: {}\", z);  // 10\n}\nprintln!(\"Outer z: {}\", z);      // 5\n\n// Ownership and scoping\nlet s = String::from(\"hello\");\n{\n    let s2 = s;     // s moved to s2\n    println!(\"{}\", s2);\n}                   // s2 dropped, memory freed\n\n// println!(\"{}\", s);  // Error: s already moved\n\n// Reference scoping\nlet mut data = 5;\nlet r1 = &data;     // immutable borrow\nprintln!(\"{}\", r1);\n{\n    let r2 = &mut data;  // mutable borrow\n    *r2 += 1;\n}                   // r2 goes out of scope\nprintln!(\"{}\", data);   // 6"
  },
  {
    "title": "Rust Strings",
    "note": "&str: string slice, immutable view into UTF-8 data. String: growable, mutable, owned UTF-8 string. Conversion between them. Indexing not allowed due to UTF-8 complexity. Use chars() for character iteration. Many methods for manipulation.",
    "code": "// String literals (string slices)\nlet s1 = \"hello\";           // &'static str\nlet s2: &str = \"world\";\n\n// Owned String\nlet mut s3 = String::new();\nlet s4 = String::from(\"hello\");\nlet s5 = \"hello\".to_string();\n\n// Conversion\nlet slice: &str = &s4;      // String to &str\nlet owned = slice.to_string();  // &str to String\n\n// Mutation\ns3.push_str(\"hello\");\ns3.push('!');\ns3 += \" world\";\n\n// Concatenation\nlet s6 = s4 + \" \" + &s5;    // s4 moved, s5 borrowed\nlet s7 = format!(\"{} {}!\", \"Hello\", \"Rust\");\n\n// Iteration\nfor c in \"नमस्ते\".chars() {\n    println!(\"{}\", c);     // न, म, स, ्, त, े\n}\n\nfor b in \"hello\".bytes() {\n    println!(\"{}\", b);     // 104, 101, 108, 108, 111\n}\n\n// Methods\nlet len = \"hello\".len();    // 5 bytes\nlet chars_count = \"hello\".chars().count();  // 5 chars\nlet contains = s3.contains(\"hello\");\nlet replaced = s3.replace(\"hello\", \"hi\");\n\n// Slicing (careful with UTF-8 boundaries)\nlet hello = \"नमस्ते\";\nlet s = &hello[0..3];       // \"न\" - first 3 bytes\n// let s = &hello[0..2];    // Panic: not char boundary"
  },
  {
    "title": "Rust Ownership",
    "note": "Each value has single owner. Owner responsible for cleanup. Moving transfers ownership. Copy types (integers, bools, chars) are copied instead of moved. Drop trait handles cleanup. RAII (Resource Acquisition Is Initialization) pattern.",
    "code": "// Moving ownership\nlet s1 = String::from(\"hello\");\nlet s2 = s1;               // s1 moved to s2\n// println!(\"{}\", s1);     // Error: s1 no longer valid\n\n// Copy types (stack-only)\nlet x = 5;\nlet y = x;                 // copy, not move\nprintln!(\"{}, {}\", x, y);  // Both valid\n\n// Function parameters move ownership\nfn takes_ownership(s: String) {\n    println!(\"{}\", s);\n} // s dropped here\n\nlet s = String::from(\"hello\");\ntakes_ownership(s);\n// s no longer valid here\n\n// Return values transfer ownership\nfn gives_ownership() -> String {\n    let s = String::from(\"hello\");\n    s\n}\n\nlet s3 = gives_ownership();  // ownership received\n\n// Moving in collections\nlet v1 = vec![String::from(\"hello\"), String::from(\"world\")];\nlet v2 = v1;                // entire vector moved\n// println!(\"{:?}\", v1);   // Error: v1 moved\n\n// Clone for explicit deep copy\nlet s4 = String::from(\"hello\");\nlet s5 = s4.clone();        // deep copy\nprintln!(\"{}, {}\", s4, s5); // Both valid"
  },
  {
    "title": "Rust Borrowing",
    "note": "References allow borrowing without ownership transfer. & for immutable borrow, &mut for mutable borrow. Rules: multiple immutable borrows OR single mutable borrow, but not both. References must always be valid (lifetimes). Dangling references prevented at compile time.",
    "code": "// Immutable borrowing\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n\nlet s1 = String::from(\"hello\");\nlet len = calculate_length(&s1);\nprintln!(\"{} length: {}\", s1, len);  // s1 still valid\n\n// Mutable borrowing\nfn change(s: &mut String) {\n    s.push_str(\", world\");\n}\n\nlet mut s2 = String::from(\"hello\");\nchange(&mut s2);\nprintln!(\"{}\", s2);  // \"hello, world\"\n\n// Borrowing rules\nlet mut s = String::from(\"hello\");\n\nlet r1 = &s;           // OK: immutable borrow\nlet r2 = &s;           // OK: another immutable borrow\nprintln!(\"{}, {}\", r1, r2);\n\n// let r3 = &mut s;     // Error: cannot borrow mutable while immutable exists\n\nlet r3 = &mut s;       // OK: immutable borrows are done\nr3.push_str(\"!\");\n\n// Slices as borrowed views\nlet s = String::from(\"hello world\");\nlet hello = &s[0..5];   // borrowed slice\nlet world = &s[6..11];\n\n// Dangling reference prevention\n// fn dangle() -> &String {  // Error: missing lifetime specifier\n//     let s = String::from(\"hello\");\n//     &s\n// } // s dropped here, but reference returned"
  },
  {
    "title": "Rust Data Structures",
    "note": "Collections: Vec (growable array), String (growable UTF-8 string), HashMap (key-value store), HashSet (unique values). Compound types: arrays (fixed-size), tuples (heterogeneous fixed-size), structs (named fields), enums (variants).",
    "code": "// Array - fixed size, stack allocated\nlet arr: [i32; 5] = [1, 2, 3, 4, 5];\nlet same_values = [0; 5];  // [0, 0, 0, 0, 0]\n\n// Vector - growable, heap allocated\nlet mut vec = Vec::new();\nvec.push(1);\nvec.push(2);\nlet vec2 = vec![1, 2, 3, 4, 5];\n\n// String\nlet mut s = String::from(\"hello\");\ns.push_str(\" world\");\n\n// HashMap\nuse std::collections::HashMap;\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);\nscores.insert(\"Red\", 20);\n\n// Tuple\nlet tup: (i32, f64, char) = (500, 6.4, 'a');\nlet (x, y, z) = tup;      // destructuring\nlet first = tup.0;        // access by index\n\n// Struct\nstruct User {\n    username: String,\n    email: String,\n    sign_in_count: u64,\n    active: bool,\n}\n\nlet user = User {\n    email: String::from(\"user@example.com\"),\n    username: String::from(\"user123\"),\n    active: true,\n    sign_in_count: 1,\n};\n\n// Enum\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nlet msg = Message::Write(String::from(\"hello\"));"
  },
  {
    "title": "Rust Arrays",
    "note": "Fixed-size collection stored on stack. All elements same type. Size known at compile time. Type signature: [T; N] where T is type, N is size. Indexing with [index] syntax. Out-of-bounds checking at runtime. Implement Copy trait if elements are Copy.",
    "code": "// Array declaration\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\nlet b = [3; 5];          // [3, 3, 3, 3, 3]\n\n// Access elements\nlet first = a[0];\nlet second = a[1];\n\n// Iteration\nfor element in &a {\n    println!(\"{}\", element);\n}\n\nfor element in a.iter() {\n    println!(\"{}\", element);\n}\n\n// Methods\nlet len = a.len();\nlet is_empty = a.is_empty();  // false\n\n// Multi-dimensional\nlet matrix: [[i32; 3]; 3] = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n];\n\n// Pattern matching\nmatch a {\n    [first, second, ..] => println!(\"First: {}, Second: {}\", first, second),\n}\n\n// Array slices\nlet slice = &a[1..4];    // [2, 3, 4]\n\n// Out-of-bounds (runtime panic)\n// let element = a[10];   // Panic!\n\n// Safe access with get\nif let Some(element) = a.get(2) {\n    println!(\"Third element: {}\", element);  // 3\n}\n\nif a.get(10).is_none() {\n    println!(\"Index 10 is out of bounds\");\n}"
  },
  {
    "title": "Rust Vectors",
    "note": "Growable array type heap-allocated. Size can change at runtime. Generic over element type. Many methods for manipulation: push, pop, insert, remove. Can reserve capacity to avoid reallocations. Implement Deref to slices for slice methods.",
    "code": "// Creation\nlet mut v1: Vec<i32> = Vec::new();\nlet v2 = vec![1, 2, 3];\n\n// Adding elements\nv1.push(1);\nv1.push(2);\nv1.push(3);\n\n// Accessing elements\nlet third: &i32 = &v2[2];     // panic if out of bounds\nlet third: Option<&i32> = v2.get(2);  // safe\n\n// Iteration\nfor i in &v2 {\n    println!(\"{}\", i);\n}\n\nfor i in &mut v1 {\n    *i *= 2;  // modify in place\n}\n\n// Methods\nv1.pop();           // remove last\nv1.insert(1, 10);   // insert at index\nv1.remove(0);       // remove at index\nv1.clear();         // remove all\n\n// Capacity management\nlet mut v = Vec::with_capacity(10);\nv.push(1);\nprintln!(\"Length: {}, Capacity: {}\", v.len(), v.capacity());\nv.shrink_to_fit();\n\n// Storing different types with enums\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\n\nlet row = vec![\n    SpreadsheetCell::Int(3),\n    SpreadsheetCell::Text(String::from(\"blue\")),\n    SpreadsheetCell::Float(10.12),\n];\n\n// Converting to/from arrays\nlet arr = [1, 2, 3];\nlet vec_from_arr = arr.to_vec();\nlet slice: &[i32] = &vec_from_arr;"
  },
  {
    "title": "Rust Tuples",
    "note": "Fixed-size heterogeneous collection. Elements can have different types. Accessed by index (.0, .1, etc.) or pattern matching. Useful for returning multiple values from functions. Unit type () is empty tuple. Implement Copy if all elements are Copy.",
    "code": "// Tuple declaration\nlet tup: (i32, f64, u8) = (500, 6.4, 1);\nlet mixed = (1, \"hello\", 3.14, true);\n\n// Access by index\nlet five_hundred = tup.0;\nlet six_point_four = tup.1;\nlet one = tup.2;\n\n// Destructuring (pattern matching)\nlet (x, y, z) = tup;\nprintln!(\"x: {}, y: {}, z: {}\", x, y, z);\n\n// Function returning tuple\nfn calculate() -> (i32, i32, i32) {\n    (1, 2, 3)\n}\n\nlet (a, b, c) = calculate();\n\n// Nested tuples\nlet nested = ((1, 2), (3.0, 4.0), \"hello\");\nlet ((x1, y1), (x2, y2), text) = nested;\n\n// Tuple comparison (if elements are comparable)\nlet t1 = (1, 2, 3);\nlet t2 = (1, 2, 4);\nprintln!(\"t1 < t2: {}\", t1 < t2);  // true\n\n// Unit type (empty tuple)\nlet unit = ();\nfn returns_unit() -> () {\n    // implicitly returns ()\n}\n\n// Single-element tuple (comma required)\nlet single = (5,);   // type: (i32,)\nlet not_tuple = (5); // type: i32\n\n// Pattern matching in tuples\nmatch tup {\n    (500, y, z) => println!(\"First is 500, y: {}, z: {}\", y, z),\n    (x, 6.4, 1) => println!(\"Second is 6.4, x: {}, third is 1\", x),\n    _ => println!(\"Other tuple\"),\n}"
  },
  {
    "title": "Rust HashMap",
    "note": "Key-value store from std::collections. Keys must implement Eq and Hash traits. Values can be any type. Average O(1) time complexity for operations. Ownership: String keys are moved, &str keys are borrowed. Various methods for insertion, retrieval, iteration.",
    "code": "use std::collections::HashMap;\n\n// Creation\nlet mut scores = HashMap::new();\n\n// Insertion\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Red\"), 50);\n\n// Access\nlet blue_score = scores.get(\"Blue\");  // Option<&i32>\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"Blue score: {}\", score);\n}\n\n// Update\nscores.insert(String::from(\"Blue\"), 25);  // overwrite\n\n// Entry API for conditional insertion\nscores.entry(String::from(\"Yellow\")).or_insert(50);\nscores.entry(String::from(\"Blue\")).or_insert(50);  // no change\n\n// Iteration\nfor (key, value) in &scores {\n    println!(\"{}: {}\", key, value);\n}\n\n// Updating based on old value\nlet text = \"hello world wonderful world\";\nlet mut map = HashMap::new();\n\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    *count += 1;\n}\nprintln!(\"{:?}\", map);  // {\"world\": 2, \"hello\": 1, \"wonderful\": 1}\n\n// Methods\nprintln!(\"Length: {}\", scores.len());\nprintln!(\"Contains Blue: {}\", scores.contains_key(\"Blue\"));\n\n// Remove\nscores.remove(\"Red\");\n\n// Clear\n// scores.clear();\n\n// From vector of tuples\nlet teams = vec![\"Blue\", \"Red\"];\nlet initial_scores = vec![10, 50];\nlet scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();\n\n// Hash functions (can specify different hasher)\nuse std::collections::hash_map::RandomState;\nlet mut map = HashMap::with_hasher(RandomState::new());"
  },
  {
    "title": "Rust Structs",
    "note": "Custom data type with named fields. Fields can have different types. Three variants: classic structs (named fields), tuple structs (unnamed fields), unit structs (no fields). Methods defined in impl blocks. Associated functions (like static methods) don't take self.",
    "code": "// Classic struct\nstruct User {\n    username: String,\n    email: String,\n    sign_in_count: u64,\n    active: bool,\n}\n\n// Instantiation\nlet user1 = User {\n    email: String::from(\"user@example.com\"),\n    username: String::from(\"user123\"),\n    active: true,\n    sign_in_count: 1,\n};\n\n// Field access\nprintln!(\"Username: {}\", user1.username);\n\n// Mutable instance\nlet mut user2 = User {\n    email: String::from(\"user2@example.com\"),\n    username: String::from(\"user456\"),\n    active: false,\n    sign_in_count: 0,\n};\nuser2.active = true;\n\n// Struct update syntax\nlet user3 = User {\n    email: String::from(\"user3@example.com\"),\n    username: String::from(\"user789\"),\n    ..user1  // use remaining fields from user1\n};\n\n// Tuple struct\nstruct Color(i32, i32, i32);\nlet black = Color(0, 0, 0);\nprintln!(\"Red: {}\", black.0);\n\n// Unit struct\nstruct AlwaysEqual;\nlet subject = AlwaysEqual;\n\n// Method implementation\nimpl User {\n    // Associated function (static method)\n    fn new(email: String, username: String) -> User {\n        User {\n            email,\n            username,\n            active: true,\n            sign_in_count: 1,\n        }\n    }\n    \n    // Method (takes &self)\n    fn get_email(&self) -> &str {\n        &self.email\n    }\n    \n    // Mutable method\n    fn deactivate(&mut self) {\n        self.active = false;\n    }\n    \n    // Method taking ownership\n    fn into_tuple(self) -> (String, String, bool, u64) {\n        (self.username, self.email, self.active, self.sign_in_count)\n    }\n}\n\n// Using methods\nlet mut user = User::new(\n    String::from(\"test@example.com\"),\n    String::from(\"testuser\")\n);\nprintln!(\"Email: {}\", user.get_email());\nuser.deactivate();\n\n// Derived traits\n#[derive(Debug, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p1 = Point { x: 1, y: 2 };\nlet p2 = p1.clone();\nprintln!(\"{:?}\", p1);\nprintln!(\"Equal: {}\", p1 == p2);"
  },
  {
    "title": "Rust Enums",
    "note": "Type that can be one of several variants. Variants can contain data: no data, named fields, unnamed fields, or mixed. Powerful with pattern matching. Option and Result are built-in enums. Can have methods via impl blocks. #[derive] traits work on enums.",
    "code": "// Basic enum\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\n// Enum with data\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nlet home = IpAddr::V4(127, 0, 0, 1);\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n\n// Variants with different data types\nenum Message {\n    Quit,                       // no data\n    Move { x: i32, y: i32 },    // named fields\n    Write(String),              // single value\n    ChangeColor(i32, i32, i32), // multiple values\n}\n\n// Using enum variants\nlet quit = Message::Quit;\nlet mov = Message::Move { x: 10, y: 20 };\nlet write = Message::Write(String::from(\"hello\"));\nlet color = Message::ChangeColor(255, 0, 0);\n\n// The Option enum (built-in)\n// enum Option<T> {\n//     Some(T),\n//     None,\n// }\nlet some_number = Some(5);\nlet some_string = Some(\"a string\");\nlet absent_number: Option<i32> = None;\n\n// The Result enum (built-in)\n// enum Result<T, E> {\n//     Ok(T),\n//     Err(E),\n// }\nlet ok_result: Result<i32, String> = Ok(42);\nlet err_result: Result<i32, String> = Err(String::from(\"error\"));\n\n// Pattern matching with enums\nfn process_message(msg: Message) {\n    match msg {\n        Message::Quit => println!(\"Quit message\"),\n        Message::Move { x, y } => println!(\"Move to ({}, {})\", x, y),\n        Message::Write(text) => println!(\"Write: {}\", text),\n        Message::ChangeColor(r, g, b) => println!(\"Color: #{:02x}{:02x}{:02x}\", r, g, b),\n    }\n}\n\n// if let syntax\nif let Message::Write(text) = write {\n    println!(\"Writing: {}\", text);\n}\n\n// Methods on enums\nimpl Message {\n    fn call(&self) {\n        // method implementation\n    }\n}\n\nlet m = Message::Write(String::from(\"hello\"));\nm.call();\n\n// Derived traits\n#[derive(Debug, Clone, PartialEq)]\nenum WebEvent {\n    PageLoad,\n    PageUnload,\n    KeyPress(char),\n    Paste(String),\n    Click { x: i64, y: i64 },\n}\n\nlet event = WebEvent::KeyPress('x');\nprintln!(\"{:?}\", event);"
  }
],
ValueJS:
[
  {
    "title": "Vue.js HOME",
    "note": "Vue.js is a progressive JavaScript framework for building user interfaces. It's designed to be incrementally adoptable and focuses on the view layer. Core resources: Vue.js Documentation, Vue CLI, Vue Router, Pinia (state management), and Vite (build tool).",
    "code": "// Official website: https://vuejs.org/\n// Documentation: https://vuejs.org/guide/\n// GitHub: https://github.com/vuejs/core\n// Playground: https://sfc.vuejs.org/"
  },
  {
    "title": "Vue.js Intro",
    "note": "Vue uses a declarative and component-based approach to build UIs. Key features: reactive data binding, components, directives, single-file components (SFCs), computed properties, watchers, and lifecycle hooks.",
    "code": "// Core principles: Reactive data, Declarative templates, Component-based\n// Easy to integrate into existing projects or build SPAs\n// Supports TypeScript and modern tooling"
  },
  {
    "title": "Vue.js Get Started",
    "note": "You can start with Vue via CDN for quick prototyping or use Vite/CLI for full apps. Vue 3 uses Composition API by default but supports Options API.",
    "code": "// Quick start via CDN:\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n// Create project with Vite:\nnpm create vite@latest my-vue-app\ncd my-vue-app\nnpm install\nnpm run dev"
  },
  {
    "title": "Vue.js Syntax",
    "note": "Vue templates use HTML enhanced with directives (prefixed by v-). Data is bound using {{ }} (interpolation) or v-bind. Events are bound with v-on (@ shorthand).",
    "code": "<template>\n  <div>\n    <h1>{{ message }}</h1>\n    <button @click=\"increment\">Clicked {{ count }} times</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nconst message = 'Hello Vue!'\nconst count = ref(0)\nfunction increment() { count.value++ }\n</script>"
  },
  {
    "title": "Vue.js Reactivity",
    "note": "Vue 3 uses the Composition API with ref() and reactive() for state. ref() is for primitives and requires .value access in script, while reactive() is for objects.",
    "code": "<script setup>\nimport { ref, reactive } from 'vue'\n\nconst count = ref(0) // For primitives\nconst user = reactive({ name: 'Alice', age: 25 }) // For objects\n\nfunction increment() { count.value++ }\nuser.age++ // Direct mutation\n</script>\n\n<template>\n  <p>Count: {{ count }}</p>\n  <button @click=\"increment\">Add</button>\n  <p>{{ user.name }} - {{ user.age }}</p>\n</template>"
  },
  {
    "title": "Vue.js Computed Properties",
    "note": "Computed properties are used for derived state. They are cached based on their reactive dependencies and only re-evaluate when a dependency changes, making them highly efficient.",
    "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed(() => {\n  return `${firstName.value} ${lastName.value}`\n})\n</script>\n\n<template>\n  <p>Full Name: {{ fullName }}</p>\n</template>"
  },
  {
    "title": "Vue.js Watchers",
    "note": "Watchers allow you to perform side effects in response to data changes. `watch` tracks a specific source, while `watchEffect` tracks its dependencies automatically.",
    "code": "<script setup>\nimport { ref, watch } from 'vue'\n\nconst question = ref('')\nconst answer = ref('Questions usually contain a question mark. ;-)')\n\nwatch(question, async (newQuestion, oldQuestion) => {\n  if (newQuestion.includes('?')) {\n    answer.value = 'Thinking...'\n    // Fetching logic here\n  }\n})\n</script>\n\n<template>\n  <input v-model=\"question\" />\n  <p>{{ answer }}</p>\n</template>"
  },
  {
    "title": "Vue.js Directives",
    "note": "Directives are special attributes with the 'v-' prefix. Common ones include v-if (conditional rendering), v-for (list rendering), v-show (conditional display), v-bind (:), v-on (@), and v-model (two-way binding).",
    "code": "<p v-if=\"isVisible\">Now you see me</p>\n<ul>\n  <li v-for=\"item in items\" :key=\"item.id\">{{ item.name }}</li>\n</ul>\n<input v-model=\"username\" placeholder=\"Enter name\" />"
  },
  {
    "title": "Vue.js Lifecycle Hooks",
    "note": "Lifecycle hooks provide points to run code at different stages of a component's life, such as creation, mounting to the DOM, updating, and unmounting. Common hooks are `onMounted`, `onUpdated`, and `onUnmounted`.",
    "code": "<script setup>\nimport { onMounted, onUnmounted } from 'vue'\n\nlet intervalId\n\nonMounted(() => {\n  console.log('Component has been mounted!')\n  intervalId = setInterval(() => { /* ... */ }, 1000)\n})\n\nonUnmounted(() => {\n  console.log('Component is about to be unmounted!')\n  clearInterval(intervalId) // Cleanup side effects\n})\n</script>"
  },
  {
    "title": "Vue.js Components",
    "note": "Components are reusable building blocks for your UI. Data is passed down from parent to child via `props`, and events are sent up from child to parent using `emits`.",
    "code": "\n<MyButton label=\"Click me\" @custom-click=\"handleAction\" />\n\n\n<template>\n  <button @click=\"$emit('custom-click')\">{{ label }}</button>\n</template>\n<script setup>\ndefineProps({ label: String })\ndefineEmits(['custom-click'])\n</script>"
  },
  {
    "title": "Vue.js Slots",
    "note": "Slots are a mechanism for content distribution. They allow you to create flexible, reusable components by passing template fragments from a parent component into designated outlets in a child component.",
    "code": "\n<template>\n  <div class=\"card\">\n    <header class=\"card-header\">\n      <slot name=\"header\">Default Header</slot>\n    </header>\n    <main class=\"card-content\">\n      <slot>Default Content</slot>\n    </main>\n  </div>\n</template>\n\n\n<Card>\n  <template #header><h1>My Card Title</h1></template>\n  <p>This is the main content of the card.</p>\n</Card>"
  },
  {
    "title": "Vue.js Composables",
    "note": "Composables are a pattern for extracting and reusing stateful logic using the Composition API. They are functions that encapsulate reactive state and methods, promoting clean and organized code.",
    "code": "// composables/useMouse.js\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nexport function useMouse() {\n  const x = ref(0)\n  const y = ref(0)\n\n  function update(event) {\n    x.value = event.pageX\n    y.value = event.pageY\n  }\n\n  onMounted(() => window.addEventListener('mousemove', update))\n  onUnmounted(() => window.removeEventListener('mousemove', update))\n\n  return { x, y }\n}\n\n// MyComponent.vue\nimport { useMouse } from './composables/useMouse'\nconst { x, y } = useMouse()"
  },
  {
    "title": "Vue.js Data Fetching",
    "note": "Data fetching from an API is a common task, typically performed in the `onMounted` lifecycle hook or triggered by a watcher. You can use the native `fetch` API or libraries like Axios.",
    "code": "<script setup>\nimport { ref, onMounted } from 'vue'\n\nconst data = ref(null)\nconst error = ref(null)\n\nonMounted(async () => {\n  try {\n    const response = await fetch('https://api.example.com/data')\n    data.value = await response.json()\n  } catch (e) {\n    error.value = e\n  }\n})\n</script>\n\n<template>\n  <div v-if=\"error\">Oops! Error: {{ error.message }}</div>\n  <div v-else-if=\"data\">Data loaded: {{ data }}</div>\n  <div v-else>Loading...</div>\n</template>"
  },
  {
    "title": "Vue.js Routing",
    "note": "Vue Router is the official library for managing client-side navigation in Single-Page Applications. You define routes and map them to components, then use `<router-link>` for navigation and `<router-view>` to display the matched component.",
    "code": "import { createRouter, createWebHistory } from 'vue-router'\nimport Home from './pages/Home.vue'\nimport About from './pages/About.vue'\n\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About }\n]\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes\n})\n\nexport default router"
  },
  {
    "title": "Vue.js State Management",
    "note": "For managing global state shared across multiple components, Vue recommends Pinia. It's a lightweight, type-safe, and intuitive store library that integrates perfectly with the Composition API.",
    "code": "import { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({ count: 0, name: 'Eduardo' }),\n  getters: {\n    doubleCount: (state) => state.count * 2\n  },\n  actions: {\n    increment() { this.count++ }\n  }\n})\n\n// In component:\nimport { useCounterStore } from './stores/counter'\nconst counterStore = useCounterStore()\ncounterStore.increment()"
  },
  {
    "title": "Vue.js Ecosystem: Nuxt",
    "note": "Nuxt is a powerful open-source framework built on top of Vue.js. It simplifies the development of universal or single-page Vue apps, providing features like server-side rendering (SSR), static site generation (SSG), file-system based routing, and auto-imports.",
    "code": "// Create a new Nuxt project:\nnpx nuxi@latest init my-nuxt-app\n\n// Nuxt provides powerful features out-of-the-box.\n// For example, pages/about.vue automatically creates the /about route.\n// Components in the components/ directory are auto-imported."
  },
],
svelte:
  [
  {
    "title": "Svelte HOME",
    "note": "Svelte is a radical new approach to building user interfaces. Instead of using a virtual DOM, Svelte is a compiler that converts your components into highly efficient, imperative vanilla JavaScript at build time. This results in smaller bundles and faster performance.",
    "code": "// Official website: https://svelte.dev/\n// Interactive Tutorial: https://svelte.dev/tutorial\n// SvelteKit (App Framework): https://kit.svelte.dev/\n// Playground: https://svelte.dev/repl"
  },
  {
    "title": "Svelte Intro",
    "note": "Unlike traditional frameworks, Svelte shifts the work from the browser (runtime) to the compiler (build time). This means no virtual DOM diffing, resulting in smaller, faster applications. Its reactivity is built into the language itself, triggered by simple assignments.",
    "code": "// Key Features:\n// - Compiles to vanilla JS\n// - No Virtual DOM\n// - Truly reactive with less boilerplate\n// - Scoped CSS by default\n// - Built-in stores, transitions, and animations"
  },
  {
    "title": "Svelte Get Started",
    "note": "The quickest way to start a new Svelte project is with Vite. Svelte components are written in `.svelte` files, which encapsulate a component's logic, template, and styles in a single file.",
    "code": "// Create a new SvelteKit project (Recommended):\nnpm create svelte@latest my-app\n\n// Create a basic Svelte project with Vite:\nnpm create vite@latest my-svelte-app -- --template svelte\n\ncd my-app\nnpm install\nnpm run dev"
  },
  {
    "title": "Svelte Reactivity",
    "note": "Reactivity in Svelte is simple and powerful. Just assign a new value to a variable, and Svelte's compiler will automatically generate the code to update the DOM. For reactive statements that depend on other variables, use the `$: ` label.",
    "code": "<script>\n  let count = 0;\n\n  // $: marks a reactive declaration.\n  // It re-runs whenever the variables it depends on change.\n  $: doubled = count * 2;\n  $: console.log(`The count is ${count}`);\n\n  function increment() {\n    count += 1;\n  }\n</script>\n\n<button on:click={increment}>Clicked {count} {count === 1 ? 'time' : 'times'}</button>\n<p>{count} * 2 = {doubled}</p>"
  },
  {
    "title": "Svelte Logic Blocks",
    "note": "Svelte provides declarative logic blocks directly in your HTML. Use `{#if...}`, `{#each...}`, and `{#await...}` to conditionally render content, loop through lists, and handle asynchronous operations.",
    "code": "<script>\n  let loggedIn = true;\n  let colors = ['red', 'green', 'blue'];\n  let promise = fetch('https://api.example.com/data').then(r => r.json());\n</script>\n\n{#if loggedIn}\n  <ul>\n    {#each colors as color}\n      <li>{color}</li>\n    {/each}\n  </ul>\n{/if}\n\n{#await promise}\n  <p>...loading</p>\n{:then data}\n  <p>Data: {data.message}</p>\n{:catch error}\n  <p style=\"color: red\">{error.message}</p>\n{/await}"
  },
  {
    "title": "Svelte Events",
    "note": "Handle DOM events using the `on:` directive. You can pass event modifiers to change their behavior, such as `preventDefault`, `stopPropagation`, `once`, and `self`.",
    "code": "<script>\n  function handleClick() {\n    alert('Div was clicked, but form will not submit.');\n  }\n</script>\n\n<form on:submit|preventDefault>\n  <div on:click={handleClick}>\n    <button>Click Me</button>\n  </div>\n</form>"
  },
  {
    "title": "Svelte Bindings",
    "note": "The `bind:` directive creates two-way bindings between a variable and an element's property. This is commonly used for form inputs, but can also bind to component props or element dimensions like `clientWidth`.",
    "code": "<script>\n  let name = 'Svelte';\n  let width;\n</script>\n\n<p>What is your name?</p>\n<input bind:value={name} />\n\n<h1 bind:clientWidth={width}>\n  Hello {name}!\n</h1>\n\n<p>The h1 is {width}px wide.</p>"
  },
  {
    "title": "Svelte Components & Props",
    "note": "Components are the building blocks of Svelte apps. To pass data into a component, you declare properties (props) using the `export let` syntax in the child component's script.",
    "code": "\n<script>\n  export let name;\n  export let email = 'N/A'; // Default value\n</script>\n\n<div>\n  <h4>{name}</h4>\n  <p>{email}</p>\n</div>\n\n\n<script>\n  import ContactCard from './ContactCard.svelte';\n</script>\n\n<ContactCard name=\"John Doe\" email=\"john@example.com\" />\n<ContactCard name=\"Jane Doe\" />"
  },
  {
    "title": "Svelte Component Events",
    "note": "To send data from a child component to a parent, the child must dispatch an event. Use `createEventDispatcher` to create a `dispatch` function, which the parent can listen for using the `on:` directive.",
    "code": "\n<script>\n  import { createEventDispatcher } from 'svelte';\n  const dispatch = createEventDispatcher();\n\n  function notify() {\n    dispatch('message', { text: 'Hello from the child!' });\n  }\n</script>\n\n<button on:click={notify}>Notify Parent</button>\n\n\n<script>\n  import Notifier from './Notifier.svelte';\n  function handleMessage(event) {\n    alert(event.detail.text);\n  }\n</script>\n\n<Notifier on:message={handleMessage} />"
  },
  {
    "title": "Svelte Slots",
    "note": "Slots allow you to pass markup into a component, making them highly reusable. A component can have one default slot and multiple named slots for more complex layouts.",
    "code": "\n<div class=\"card\">\n  <div class=\"header\">\n    <slot name=\"header\">Default Header</slot>\n  </div>\n  <div class=\"content\">\n    <slot>Default Content</slot>\n  </div>\n</div>\n\n\n<Card>\n  <h1 slot=\"header\">My Title</h1>\n  <p>Some content for the card.</p>\n</Card>"
  },
  {
    "title": "Svelte Stores",
    "note": "Stores are a powerful way to manage state that needs to be shared across multiple components. To use a store's value in a component's template, prefix the store name with `$` for automatic subscription and unsubscription.",
    "code": "// stores.js\nimport { writable, readable, derived } from 'svelte/store';\n\nexport const count = writable(0);\n\nexport const time = readable(new Date(), function start(set) {\n  const interval = setInterval(() => {\n    set(new Date());\n  }, 1000);\n  return function stop() { clearInterval(interval); };\n});\n\nexport const doubled = derived(count, $count => $count * 2);"
  },
  {
    "title": "Svelte Transitions & Animations",
    "note": "Svelte includes a rich set of transition and animation tools to create beautiful UIs. Use the `transition:` directive for elements entering or leaving the DOM, and the `animate:` directive for moving items in a list.",
    "code": "<script>\n  import { fade, fly } from 'svelte/transition';\n  import { flip } from 'svelte/animate';\n  let visible = true;\n  let todos = [{id: 1, text: 'Learn Svelte'}];\n</script>\n\n<label>\n  <input type=\"checkbox\" bind:checked={visible}>\n  Toggle Visibility\n</label>\n\n{#if visible}\n  <p transition:fly={{ y: -20, duration: 500 }}>Flies in and out</p>\n{/if}\n\n\n{#each todos as todo (todo.id)}\n  <div animate:flip>{todo.text}</div>\n{/each}"
  },
  {
    "title": "Svelte Actions",
    "note": "An action is a function that runs when an element is created. It's useful for adding custom behavior or integrating with third-party libraries. Apply an action to an element with the `use:` directive.",
    "code": "<script>\n  function highlight(node, color) {\n    const originalColor = node.style.backgroundColor;\n    node.style.backgroundColor = color;\n    \n    return {\n      // Optional: runs when parameters change\n      update(newColor) { node.style.backgroundColor = newColor; },\n      // Optional: runs when element is destroyed\n      destroy() { node.style.backgroundColor = originalColor; }\n    }\n  }\n</script>\n\n<p use:highlight={'yellow'}>This text is highlighted by an action.</p>"
  },
  {
    "title": "Svelte Ecosystem: SvelteKit",
    "note": "SvelteKit is the official framework for building full-stack applications with Svelte. It provides a production-ready setup with file-system routing, server-side rendering (SSR), API routes, and adapters for easy deployment to any platform.",
    "code": "// SvelteKit file-system routing:\n// src/routes/         -> Home page (+page.svelte)\n// src/routes/about    -> About page (+page.svelte)\n// src/routes/blog/[slug] -> Dynamic route (+page.svelte)\n\n// SvelteKit server-side data loading:\n// In a +page.server.js file next to your page\nexport async function load({ params }) {\n  const post = await getPostFromDatabase(params.slug);\n  return { post };\n}"
  },
  {
    "title": "Svelte Free E-Learning",
    "note": "Ready to master Svelte? These high-quality, free resources are the perfect place to start. From the official interactive tutorial to in-depth video courses, you have everything you need to become a proficient Svelte developer.",
    "code": "// --- Official Resources ---\n// 1. Svelte Official Tutorial (The best place to start)\n// https://svelte.dev/tutorial\n\n// --- Community & Video Courses ---\n// 2. Svelte School (Free Svelte & SvelteKit courses)\n// https://svelte.school\n\n// 3. Joy of Code (Excellent SvelteKit tutorials on YouTube)\n// https://www.youtube.com/@joyofcode\n\n// 4. Svelte Society (Community events, articles, and talks)\n// https://sveltesociety.dev/\n// https://www.youtube.com/c/SvelteSociety"
  }
],
ruby:
[
  {
    "title": "Ruby HOME & Overview",
    "note": "Ruby is a dynamic, interpreted, open-source programming language designed for simplicity and productivity. It emphasizes human-friendly syntax, making it natural to read and easy to write. Created by Yukihiro 'Matz' Matsumoto in the mid-1990s, Ruby is highly popular for web development, particularly with Ruby on Rails. It supports object-oriented, functional, and imperative programming styles, and everything in Ruby is an object, including primitive types.",
    "code": "# Official Website: https://www.ruby-lang.org/\n# Documentation: https://ruby-doc.org/\n# Try Online: https://replit.com/languages/ruby\n\nputs 'Hello, Ruby!'\n\n# Ruby version\nputs RUBY_VERSION"
  },
  {
    "title": "Ruby Basics & Syntax",
    "note": "Ruby is interpreted and dynamically typed, so variable types are determined at runtime. You can define variables without specifying types. Statements end with newlines, semicolons are optional, and comments start with '#'. Everything in Ruby is an object, even numbers and booleans. Simple input/output is done with 'puts' or 'print'.",
    "code": "name = 'Alice'\nage = 25\nis_active = true\n\nputs \"Name: #{name}, Age: #{age}, Active: #{is_active}\"\n\n# Single-line comment\n# Multi-line strings can use heredoc\nmessage = <<~MSG\n  Hello #{name}!\n  Welcome to Ruby.\nMSG\nputs message"
  },
  {
    "title": "Ruby Data Types & Variables",
    "note": "Ruby supports several core data types: Strings, Numbers (Integer, Float), Symbols (lightweight constants), Arrays (ordered collections), Hashes (key-value pairs), Ranges, Booleans, and nil. Variables can hold any type without declaration, and types can change dynamically.",
    "code": "str = \"Hello\"\nnum = 42\npi = 3.14\nsym = :token\narr = [1, 2, 3]\nhash = { name: \"Alice\", age: 25 }\nrange = 1..5\n\nputs arr[0]        # 1\nputs hash[:name]   # Alice\nputs range.to_a    # [1,2,3,4,5]"
  },
  {
    "title": "Ruby Strings & Manipulations",
    "note": "Strings can use single or double quotes. Double quotes support interpolation and escape sequences. Ruby provides many useful string methods such as upcase, downcase, strip, split, include?, gsub (global substitution), start_with?, end_with?, and more.",
    "code": "name = \"Ruby\"\nputs 'Hello ' + name             # Concatenation\nputs \"Hello #{name}\"            # Interpolation\nputs name.upcase                 # RUBY\nputs name.downcase               # ruby\nputs name.include?(\"by\")       # true\nputs name.gsub('by', 'BI')      # RuBI"
  },
  {
    "title": "Ruby Numbers & Math Operations",
    "note": "Ruby supports integers and floating-point numbers. You can perform arithmetic operations: addition (+), subtraction (-), multiplication (*), division (/), modulo (%), exponentiation (**). Ruby also has a Math module with useful methods like sqrt, sin, cos, tan, log, and random number generation.",
    "code": "a = 10\nb = 3\n\nputs a + b          # 13\nputs a - b          # 7\nputs a * b          # 30\nputs a / b          # 3 (integer division)\nputs a.to_f / b     # 3.333...\nputs a % b          # 1\nputs a ** b         # 1000\n\nputs Math.sqrt(16)  # 4.0\nputs Math.sin(Math::PI / 2)  # 1.0\nputs rand(1..10)    # random number between 1 and 10"
  },
  {
    "title": "Ruby Conditionals & Logic",
    "note": "Conditional statements allow branching logic. Ruby uses if/elsif/else, unless (opposite of if), and case/when. Inline conditionals can be used for simple statements. Comparisons include ==, !=, >, <, >=, <=, and logical operators are &&, ||, !.",
    "code": "age = 18\n\nif age >= 18\n  puts 'Adult'\nelsif age >= 13\n  puts 'Teen'\nelse\n  puts 'Child'\nend\n\n# Inline conditional\nputs 'Even' if age.even?\nputs 'Odd' unless age.even?\n\n# Case statement\ncase age\nwhen 0..12 then puts 'Child'\nwhen 13..17 then puts 'Teen'\nelse puts 'Adult'\nend"
  },
  {
    "title": "Ruby Loops & Iteration",
    "note": "Ruby provides multiple looping constructs: while, until, for, loop do, and iterators like .each, .times, .map. Iterators are preferred in idiomatic Ruby.",
    "code": "i = 0\nwhile i < 3\n  puts i\n  i += 1\nend\n\n3.times { |n| puts \"Times loop #{n}\" }\n\n[1, 2, 3].each do |n|\n  puts \"Number: #{n}\"\nend\n\nfor n in 1..3 do\n  puts \"For loop: #{n}\"\nend"
  },
  {
    "title": "Ruby Methods & Functions",
    "note": "Methods are defined with 'def' and can take parameters. Default values, variable-length arguments, and keyword arguments are supported. Methods return the last evaluated expression. Methods can be defined globally, inside classes, or modules.",
    "code": "def greet(name = \"Guest\")\n  \"Hello, #{name}!\"\nend\n\nputs greet(\"Alice\")\nputs greet\n\n# Variable-length args\ndef sum(*numbers)\n  numbers.reduce(0, :+)\nend\nputs sum(1, 2, 3, 4)  # 10\n\n# Keyword arguments\ndef info(name:, age:)\n  \"#{name} is #{age} years old\"\nend\nputs info(name: 'Bob', age: 30)"
  },
  {
    "title": "Ruby Arrays & Iterators",
    "note": "Arrays are ordered collections of objects. Ruby provides powerful array methods like push, pop, shift, unshift, map, select, reject, reduce, include?, sort, and uniq. Arrays can contain any object type and are dynamic in size.",
    "code": "arr = [1, 2, 3, 4]\narr.push(5)\narr << 6\narr.pop\n\nputs arr.inspect   # [1, 2, 3, 4, 5]\n\nsquares = arr.map { |n| n * n }\nputs squares.inspect  # [1, 4, 9, 16, 25]\n\nevens = arr.select(&:even?)\nputs evens.inspect    # [2, 4]"
  },
  {
    "title": "Ruby Hashes & Key-Value Storage",
    "note": "Hashes are unordered key-value pairs. Keys are typically symbols or strings. You can access values with [], fetch, or dig. Methods include keys, values, merge, delete, each, and transform_keys. Hashes are widely used for structured data.",
    "code": "person = { name: \"Alice\", age: 25, active: true }\nputs person[:name]           # Alice\nputs person.fetch(:age)      # 25\n\nperson[:city] = \"Addis Ababa\"\nputs person.dig(:city)       # Addis Ababa\n\nperson.each { |k,v| puts \"#{k}: #{v}\" }"
  },
  {
    "title": "Ruby Classes, Objects & OOP",
    "note": "Ruby is fully object-oriented. Classes are defined with 'class', instance variables start with @, and methods can be public, private, or protected. Constructors are defined using initialize. attr_accessor, attr_reader, and attr_writer generate getters and setters automatically.",
    "code": "class Person\n  attr_accessor :name, :age\n\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\n\n  def greet\n    \"Hi, I'm #{@name}, age #{@age}\"\n  end\nend\n\np1 = Person.new(\"Alice\", 25)\nputs p1.greet"
  },
  {
    "title": "Ruby Modules & Mixins",
    "note": "Modules allow grouping related methods and constants, serve as namespaces, and can be mixed into classes using include. Mixins provide code reuse without using inheritance. Modules can also hold constants and module methods (self.method_name).",
    "code": "module MathUtils\n  def square(x)\n    x * x\n  end\n\n  def cube(x)\n    x ** 3\n  end\nend\n\nclass Calculator\n  include MathUtils\nend\n\ncalc = Calculator.new\nputs calc.square(5)  # 25\nputs calc.cube(3)    # 27"
  },
  {
    "title": "Ruby Blocks, Procs, & Lambdas",
    "note": "Blocks are anonymous chunks of code passed to methods. Procs and lambdas are objects encapsulating blocks. Lambdas check argument counts strictly, while Procs are more lenient. Blocks enable powerful iteration and callback mechanisms.",
    "code": "def repeat(n)\n  n.times { yield }\nend\nrepeat(3) { puts 'Hello' }\n\nmy_proc = Proc.new { |x| puts x }\nmy_proc.call(10)\n\nmy_lambda = ->(x) { puts x * 2 }\nmy_lambda.call(5)"
  },
  {
    "title": "Ruby Exception Handling",
    "note": "Ruby handles errors with begin/rescue/else/ensure blocks. Exceptions can be raised using raise. Custom exceptions can be created by inheriting from StandardError. The ensure block always runs for cleanup purposes.",
    "code": "begin\n  num = 10 / 0\nrescue ZeroDivisionError => e\n  puts \"Error: #{e.message}\"\nelse\n  puts 'No error!'\nensure\n  puts 'Always runs.'\nend\n\n# Custom Exception\nclass MyError < StandardError; end\nraise MyError, 'Something went wrong!'"
  },
  {
    "title": "Ruby File Handling & I/O",
    "note": "Ruby provides simple file operations. Use File.open with a block to safely read/write files. Modes include 'r' (read), 'w' (write), 'a' (append), 'r+' (read/write). File methods include read, write, each_line, and File.exist?.",
    "code": "File.open(\"test.txt\", \"w\") do |file|\n  file.puts \"Hello, File!\"\nend\n\ncontent = File.read(\"test.txt\")\nputs content\n\nFile.foreach(\"test.txt\") { |line| puts line }"
  },
  {
    "title": "Ruby Gems & Libraries",
    "note": "Gems are packaged Ruby libraries. They simplify code reuse and dependency management. RubyGems is the official gem manager. Bundler is used for project dependency management. Gems can provide APIs, utilities, or frameworks like Rails, Sinatra, or HTTParty.",
    "code": "# Install gem\n# gem install httparty\nrequire 'httparty'\n\nresponse = HTTParty.get('https://jsonplaceholder.typicode.com/todos/1')\nputs response.parsed_response\n\n# Using Bundler\n# gem 'nokogiri'\n# bundle install"
  }
],
javaspring:
  [
  {
    "title": "Java HOME & Overview",
    "note": "Java is a versatile, object-oriented, class-based programming language developed by Sun Microsystems (now Oracle). It runs on the JVM, making it platform-independent. Java is widely used for enterprise applications, Android apps, backend services, and large-scale systems. Its syntax is influenced by C/C++ but simplifies memory management with garbage collection.",
    "code": "// Official Website: https://www.oracle.com/java/\n// Documentation: https://docs.oracle.com/javase/\n// Try Online: https://www.jdoodle.com/ or https://replit.com/languages/java10\n\npublic class HelloJava {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, Java!\");\n        System.out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n    }\n}"
  },
  {
    "title": "Java Basics & Syntax",
    "note": "Java is statically typed, so you must declare variable types. Variables can be primitive types (int, double, boolean, char) or objects (String, arrays). Every Java program starts with a class and a main method. Comments use // for single-line and /* */ for multi-line.",
    "code": "public class Basics {\n    public static void main(String[] args) {\n        String name = \"Alice\";\n        int age = 25;\n        boolean isActive = true;\n\n        System.out.println(\"Name: \" + name + \", Age: \" + age + \", Active: \" + isActive);\n        \n        // Multi-line comment example\n        /* This is a multi-line\n           comment in Java */\n    }\n}"
  },
  {
    "title": "Java Data Types & Variables",
    "note": "Java has primitive types (int, double, boolean, char, byte, short, long, float) and reference types (String, arrays, classes). Strings are immutable objects. Variables must be declared before use. Constants are declared with 'final'.",
    "code": "public class DataTypes {\n    public static void main(String[] args) {\n        String str = \"Hello\";\n        int num = 42;\n        double pi = 3.14;\n        char letter = 'A';\n        boolean isTrue = true;\n        int[] arr = {1, 2, 3};\n        final double TAX = 0.15;\n\n        System.out.println(\"Array first element: \" + arr[0]);\n        System.out.println(str.toUpperCase());\n        System.out.println(\"Tax rate: \" + TAX);\n    }\n}"
  },
  {
    "title": "Java Conditionals & Logic",
    "note": "Conditional statements in Java allow branching. Use if/else, switch-case, and ternary operators. Java uses curly braces {} for code blocks. Logical operators: && (AND), || (OR), ! (NOT). Comparison operators: ==, !=, >, <, >=, <=.",
    "code": "public class Conditionals {\n    public static void main(String[] args) {\n        int age = 18;\n\n        if (age >= 18) {\n            System.out.println(\"Adult\");\n        } else if (age >= 13) {\n            System.out.println(\"Teen\");\n        } else {\n            System.out.println(\"Child\");\n        }\n\n        // Ternary operator\n        String result = (age % 2 == 0) ? \"Even\" : \"Odd\";\n        System.out.println(result);\n\n        // Switch case (Java 14+ syntax)\n        switch (age) {\n            case 0,1,2,3 -> System.out.println(\"Toddler\");\n            case 13,14,15,16,17 -> System.out.println(\"Teen\");\n            default -> System.out.println(\"Adult\");\n        }\n    }\n}"
  },
  {
    "title": "Java Loops & Iteration",
    "note": "Java supports while, do-while, for, and enhanced-for loops. Iterators are commonly used with collections like Lists, Sets, and Maps. Loops can be nested, and 'break'/'continue' control flow within loops.",
    "code": "public class Loops {\n    public static void main(String[] args) {\n        // While loop\n        int i = 0;\n        while (i < 3) {\n            System.out.println(i);\n            i++;\n        }\n\n        // For loop\n        for (int j = 0; j < 3; j++) {\n            System.out.println(\"For loop \" + j);\n        }\n\n        // Enhanced for loop\n        int[] arr = {1, 2, 3};\n        for (int n : arr) {\n            System.out.println(\"Number: \" + n);\n        }\n    }\n}"
  },
  {
    "title": "Java Methods & Functions",
    "note": "Methods in Java are defined inside classes. They can have return types, parameters, and access modifiers (public, private, protected). Static methods belong to the class; instance methods belong to objects. Methods return the last evaluated value if non-void.",
    "code": "public class Methods {\n    // Static method\n    static String greet(String name) {\n        return \"Hello, \" + name;\n    }\n\n    // Instance method\n    String farewell(String name) {\n        return \"Goodbye, \" + name;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(greet(\"Alice\"));\n        Methods obj = new Methods();\n        System.out.println(obj.farewell(\"Bob\"));\n    }\n}"
  },
  {
    "title": "Java Classes, Objects & OOP",
    "note": "Java is fully object-oriented. Classes define blueprints for objects. Fields (variables) and methods (functions) define object behavior. Constructors initialize objects. Access modifiers control visibility. Inheritance, polymorphism, and encapsulation are key OOP principles.",
    "code": "class Person {\n    String name;\n    int age;\n\n    Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    void greet() {\n        System.out.println(\"Hi, I'm \" + name + \", age \" + age);\n    }\n}\n\npublic class OOPDemo {\n    public static void main(String[] args) {\n        Person p1 = new Person(\"Alice\", 25);\n        p1.greet();\n\n        Person p2 = new Person(\"Bob\", 30);\n        p2.greet();\n    }\n}"
  },
  {
    "title": "Java Exception Handling",
    "note": "Java handles runtime errors using try-catch-finally blocks. You can throw exceptions manually. Checked exceptions must be declared or handled. The finally block always executes. Custom exceptions inherit from Exception or RuntimeException.",
    "code": "public class ExceptionsDemo {\n    public static void main(String[] args) {\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        } finally {\n            System.out.println(\"Cleanup or final code executes.\");\n        }\n\n        // Custom exception\n        try {\n            throw new Exception(\"Custom exception!\");\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}"
  },
  {
    "title": "Java Collections & Generics",
    "note": "Java Collections framework includes List, Set, Map, and Queue. Generics allow type-safe collections. Common methods: add, remove, get, size, contains, keySet, values. Iterators and enhanced for loops are used to traverse collections.",
    "code": "import java.util.*;\n\npublic class CollectionsDemo {\n    public static void main(String[] args) {\n        List<String> fruits = new ArrayList<>();\n        fruits.add(\"Apple\");\n        fruits.add(\"Banana\");\n\n        Set<Integer> numbers = new HashSet<>();\n        numbers.add(1); numbers.add(2);\n\n        Map<String, Integer> scores = new HashMap<>();\n        scores.put(\"Alice\", 90);\n        scores.put(\"Bob\", 85);\n\n        for (String fruit : fruits) System.out.println(fruit);\n        for (Integer n : numbers) System.out.println(n);\n        for (String key : scores.keySet()) System.out.println(key + \": \" + scores.get(key));\n    }\n}"
  },
  {
    "title": "Spring Boot HOME & Overview",
    "note": "Spring Boot is a Java framework for building production-ready web applications quickly. It simplifies Spring setup with auto-configuration, embedded servers, and opinionated defaults. Ideal for REST APIs, microservices, and enterprise applications.",
    "code": "// Official Website: https://spring.io/projects/spring-boot\n// Guides: https://spring.io/guides\n// Try Online: https://start.spring.io/\n\n// Create a Spring Boot app: spring init --dependencies=web demo"
  },
  {
    "title": "Spring Boot Basics & Main Class",
    "note": "A Spring Boot app starts with a main class annotated with @SpringBootApplication. It embeds a Tomcat server, so you can run it with `mvn spring-boot:run` or `./gradlew bootRun`. Configuration is minimal, thanks to convention over configuration.",
    "code": "import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n}"
  },
  {
    "title": "Spring Boot REST Controller",
    "note": "Use @RestController to define REST endpoints. @GetMapping, @PostMapping, @PutMapping, and @DeleteMapping map HTTP requests. Spring Boot automatically converts return values to JSON.",
    "code": "import org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n    @GetMapping(\"/\")\n    public String home() {\n        return \"Hello, Spring Boot!\";\n    }\n}"
  },
  {
    "title": "Spring Boot Controllers with Parameters",
    "note": "Path variables and query parameters are easily handled with @PathVariable and @RequestParam. Spring maps HTTP requests to method parameters automatically, simplifying REST API development.",
    "code": "import org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api\")\npublic class ApiController {\n\n    @GetMapping(\"/greet/{name}\")\n    public String greet(@PathVariable String name) {\n        return \"Hello, \" + name;\n    }\n\n    @GetMapping(\"/add\")\n    public int add(@RequestParam int a, @RequestParam int b) {\n        return a + b;\n    }\n}"
  },
  {
    "title": "Spring Boot with Database (JPA)",
    "note": "Spring Boot integrates with relational databases using Spring Data JPA. Define entity classes with @Entity, and repositories extending JpaRepository provide CRUD operations automatically. Supports H2, MySQL, PostgreSQL, and more.",
    "code": "import jakarta.persistence.*;\n\n@Entity\npublic class User {\n    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    private int age;\n    // Getters and setters omitted for brevity\n}\n\nimport org.springframework.data.jpa.repository.JpaRepository;\npublic interface UserRepository extends JpaRepository<User, Long> {}\n\nimport org.springframework.web.bind.annotation.*;\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n    private final UserRepository repo;\n    public UserController(UserRepository repo) { this.repo = repo; }\n\n    @GetMapping\n    public List<User> all() { return repo.findAll(); }\n\n    @PostMapping\n    public User add(@RequestBody User user) { return repo.save(user); }\n}"
  }
],
csharpdotnet:[
  {
    "title": "C# HOME",
    "note": "C# (C-Sharp) is a modern, object-oriented programming language developed by Microsoft. It runs on the .NET framework and is used for desktop apps, mobile apps, games (Unity), and web backends. It is strongly typed and supports features like async/await, LINQ, and generics.",
    "code": "// Official Website: https://learn.microsoft.com/en-us/dotnet/csharp/\n// Documentation: https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/\n// Try Online: https://dotnetfiddle.net/ or https://replit.com/languages/csharp\n\nusing System;\n\nclass Program {\n    static void Main(string[] args) {\n        Console.WriteLine(\"Hello, C#!\");\n    }\n}"
  },
  {
    "title": "C# Basics",
    "note": "C# is statically typed, so variables must be declared with types (int, string, bool, double, etc.). Methods and code execution begin inside the Main() method.",
    "code": "using System;\n\nclass Basics {\n    static void Main(string[] args) {\n        string name = \"Alice\";\n        int age = 25;\n        bool isActive = true;\n\n        Console.WriteLine($\"Name: {name}, Age: {age}, Active: {isActive}\");\n    }\n}"
  },
  {
    "title": "C# Data Types",
    "note": "C# has value types (int, double, bool, char, struct) and reference types (string, arrays, objects). Strings are immutable reference types.",
    "code": "using System;\n\nclass DataTypes {\n    static void Main() {\n        string str = \"Hello\";\n        int num = 42;\n        double pi = 3.14;\n        char letter = 'A';\n        bool isTrue = true;\n        int[] arr = {1, 2, 3};\n\n        Console.WriteLine(arr[0]);\n        Console.WriteLine(str.ToUpper());\n    }\n}"
  },
  {
    "title": "C# Conditionals",
    "note": "Conditionals in C# use if/else, switch-case, and ternary operators. Blocks are wrapped in curly braces {}.",
    "code": "using System;\n\nclass Conditionals {\n    static void Main() {\n        int age = 18;\n\n        if (age >= 18) {\n            Console.WriteLine(\"Adult\");\n        } else if (age >= 13) {\n            Console.WriteLine(\"Teen\");\n        } else {\n            Console.WriteLine(\"Child\");\n        }\n\n        // Ternary operator\n        string result = (age % 2 == 0) ? \"Even\" : \"Odd\";\n        Console.WriteLine(result);\n\n        // Switch case\n        switch (age) {\n            case < 5:\n                Console.WriteLine(\"Toddler\");\n                break;\n            case >= 13 and < 18:\n                Console.WriteLine(\"Teen\");\n                break;\n            default:\n                Console.WriteLine(\"Adult\");\n                break;\n        }\n    }\n}"
  },
  {
    "title": "C# Loops",
    "note": "C# supports while, do-while, for, and foreach loops. foreach is commonly used for collections.",
    "code": "using System;\n\nclass Loops {\n    static void Main() {\n        int i = 0;\n        while (i < 3) {\n            Console.WriteLine(i);\n            i++;\n        }\n\n        for (int j = 0; j < 3; j++) {\n            Console.WriteLine($\"For loop {j}\");\n        }\n\n        int[] arr = {1, 2, 3};\n        foreach (int n in arr) {\n            Console.WriteLine($\"Number: {n}\");\n        }\n    }\n}"
  },
  {
    "title": "C# Methods",
    "note": "Methods are defined inside classes. They can return values, accept parameters, and be static (class-level) or instance-level.",
    "code": "using System;\n\nclass Methods {\n    static string Greet(string name) {\n        return $\"Hello, {name}\";\n    }\n\n    static void Main() {\n        Console.WriteLine(Greet(\"Alice\"));\n    }\n}"
  },
  {
    "title": "C# Classes & Objects",
    "note": "C# is object-oriented. Classes define blueprints; objects are instances. Constructors initialize objects. Members can be fields, properties, and methods.",
    "code": "using System;\n\nclass Person {\n    public string Name;\n    public int Age;\n\n    public Person(string name, int age) {\n        Name = name;\n        Age = age;\n    }\n\n    public void Greet() {\n        Console.WriteLine($\"Hi, I'm {Name}, age {Age}\");\n    }\n}\n\nclass OOPDemo {\n    static void Main() {\n        Person p1 = new Person(\"Alice\", 25);\n        p1.Greet();\n    }\n}"
  },
  {
    "title": "C# Exceptions",
    "note": "C# uses try-catch-finally for error handling. Exceptions can be thrown manually with 'throw'.",
    "code": "using System;\n\nclass ExceptionsDemo {\n    static void Main() {\n        try {\n            int result = 10 / 0;\n        } catch (DivideByZeroException e) {\n            Console.WriteLine($\"Error: {e.Message}\");\n        } finally {\n            Console.WriteLine(\"Always runs.\");\n        }\n    }\n}"
  },
  {
    "title": ".NET / ASP.NET Core HOME",
    "note": "ASP.NET Core is a cross-platform, high-performance framework for building modern web apps and APIs with .NET. It provides built-in support for dependency injection, routing, security, and integrates with Entity Framework Core for databases.",
    "code": "// Official Website: https://dotnet.microsoft.com/en-us/apps/aspnet\n// Documentation: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0\n// Try Online: https://dotnetfiddle.net/ or local `dotnet new web`\n\n// Create a new ASP.NET Core app:\n// dotnet new web -o MyWebApp"
  },
  {
    "title": "ASP.NET Core Basics",
    "note": "An ASP.NET Core app starts from Program.cs. The minimal hosting model allows defining routes directly using MapGet/MapPost without controllers.",
    "code": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Hosting;\n\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\napp.MapGet(\"/\", () => \"Hello, ASP.NET Core!\");\n\napp.Run();"
  },
  {
    "title": "ASP.NET Core REST Controller",
    "note": "Controllers in ASP.NET Core use attributes like [ApiController], [Route], [HttpGet], and [HttpPost]. They make building REST APIs straightforward.",
    "code": "using Microsoft.AspNetCore.Mvc;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class HelloController : ControllerBase {\n    [HttpGet]\n    public string Get() {\n        return \"Hello from ASP.NET Core Controller!\";\n    }\n}"
  },
  {
    "title": "ASP.NET Core with Parameters",
    "note": "ASP.NET Core controllers can accept path variables and query parameters. Model binding automatically maps request data to method parameters.",
    "code": "using Microsoft.AspNetCore.Mvc;\n\n[ApiController]\n[Route(\"api\")]\npublic class ApiController : ControllerBase {\n    [HttpGet(\"greet/{name}\")]\n    public string Greet(string name) {\n        return $\"Hello, {name}\";\n    }\n\n    [HttpGet(\"add\")]\n    public int Add([FromQuery] int a, [FromQuery] int b) {\n        return a + b;\n    }\n}"
  },
  {
    "title": "ASP.NET Core with Database (Entity Framework Core)",
    "note": "ASP.NET Core integrates with databases via Entity Framework Core. You define an entity class and a DbContext; CRUD APIs can be scaffolded quickly.",
    "code": "using Microsoft.EntityFrameworkCore;\n\npublic class User {\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\npublic class AppDbContext : DbContext {\n    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) {}\n    public DbSet<User> Users { get; set; }\n}\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.Linq;\n\n[ApiController]\n[Route(\"users\")]\npublic class UserController : ControllerBase {\n    private readonly AppDbContext _context;\n    public UserController(AppDbContext context) { _context = context; }\n\n    [HttpGet]\n    public IEnumerable<User> All() => _context.Users.ToList();\n\n    [HttpPost]\n    public User Add(User user) {\n        _context.Users.Add(user);\n        _context.SaveChanges();\n        return user;\n    }\n}"
  }
],
goweb:[
  {
    "title": "Go HOME",
    "note": "Go (or Golang) is a statically typed, compiled programming language developed at Google. It is designed for simplicity, performance, and concurrency. Go is often used for backend services, cloud-native apps, and microservices because of its speed and efficiency.",
    "code": "// Official Website: https://go.dev/\n// Documentation: https://pkg.go.dev/std\n// Try Online: https://go.dev/play/\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, Go!\")\n}"
  },
  {
    "title": "Go Basics",
    "note": "Go has simple syntax with package-level functions. The main() function is the entry point. Variables can be declared explicitly with types or inferred using :=.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    var name string = \"Alice\"\n    age := 25\n    isActive := true\n\n    fmt.Printf(\"Name: %s, Age: %d, Active: %t\\n\", name, age, isActive)\n}"
  },
  {
    "title": "Go Data Types",
    "note": "Go provides basic types like int, float64, bool, string, arrays, slices, maps, and structs. Strings are UTF-8 encoded by default.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    str := \"Hello\"\n    num := 42\n    pi := 3.14\n    letter := 'A'\n    isTrue := true\n    arr := []int{1, 2, 3}\n    dict := map[string]int{\"a\": 1, \"b\": 2}\n\n    fmt.Println(arr[0])\n    fmt.Println(string(letter))\n    fmt.Println(dict[\"a\"])\n}"
  },
  {
    "title": "Go Conditionals",
    "note": "Go supports if/else and switch statements. There are no parentheses around conditions, but curly braces are required.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    age := 18\n\n    if age >= 18 {\n        fmt.Println(\"Adult\")\n    } else if age >= 13 {\n        fmt.Println(\"Teen\")\n    } else {\n        fmt.Println(\"Child\")\n    }\n\n    // Switch case\n    switch {\n    case age < 5:\n        fmt.Println(\"Toddler\")\n    case age >= 13 && age < 18:\n        fmt.Println(\"Teen\")\n    default:\n        fmt.Println(\"Adult\")\n    }\n}"
  },
  {
    "title": "Go Loops",
    "note": "Go has only the for loop (no while or foreach). It can be used in traditional, range, or infinite loop styles.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 0; i < 3; i++ {\n        fmt.Println(\"For loop\", i)\n    }\n\n    arr := []int{1, 2, 3}\n    for _, n := range arr {\n        fmt.Println(\"Number:\", n)\n    }\n\n    // Infinite loop (with break)\n    j := 0\n    for {\n        if j >= 3 {\n            break\n        }\n        fmt.Println(\"Infinite loop count:\", j)\n        j++\n    }\n}"
  },
  {
    "title": "Go Functions",
    "note": "Functions in Go can return multiple values. Parameters and return types must be declared. The main() function is the entry point.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc Greet(name string) string {\n    return fmt.Sprintf(\"Hello, %s\", name)\n}\n\nfunc Add(a int, b int) int {\n    return a + b\n}\n\nfunc main() {\n    fmt.Println(Greet(\"Alice\"))\n    fmt.Println(\"Sum:\", Add(5, 7))\n}"
  },
  {
    "title": "Go Structs & Methods",
    "note": "Go is not class-based but supports structs and methods. Methods are functions with a receiver that can be attached to a struct.",
    "code": "package main\n\nimport \"fmt\"\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc (p Person) Greet() {\n    fmt.Printf(\"Hi, I'm %s, age %d\\n\", p.Name, p.Age)\n}\n\nfunc main() {\n    p1 := Person{Name: \"Alice\", Age: 25}\n    p1.Greet()\n}"
  },
  {
    "title": "Go Error Handling",
    "note": "Go uses explicit error handling instead of exceptions. Functions often return (value, error). The error is nil if no error occurred.",
    "code": "package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc Divide(a, b int) (int, error) {\n    if b == 0 {\n        return 0, errors.New(\"cannot divide by zero\")\n    }\n    return a / b, nil\n}\n\nfunc main() {\n    result, err := Divide(10, 0)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Println(\"Result:\", result)\n    }\n}"
  },
  {
    "title": "Go Web Basics (net/http)",
    "note": "Go’s standard library has built-in support for HTTP servers. http.HandleFunc defines routes, and http.ListenAndServe starts the server.",
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"Hello, Go Web!\")\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    fmt.Println(\"Server running on http://localhost:8080\")\n    http.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "title": "Go REST API (net/http + JSON)",
    "note": "Go can easily build JSON APIs. The encoding/json package handles JSON encoding and decoding.",
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n)\n\ntype Message struct {\n    Text string `json:\"text\"`\n}\n\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\n    response := Message{Text: \"Hello from Go API!\"}\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(response)\n}\n\nfunc main() {\n    http.HandleFunc(\"/api/hello\", helloHandler)\n    http.ListenAndServe(\":8080\", nil)\n}"
  },
  {
    "title": "Go with Gin Framework",
    "note": "Gin is a popular web framework for Go, similar to Express.js for Node.js. It provides routing, middleware, and JSON handling out of the box.",
    "code": "package main\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc main() {\n    r := gin.Default()\n\n    r.GET(\"/\", func(c *gin.Context) {\n        c.JSON(200, gin.H{\"message\": \"Hello from Gin Web Framework!\"})\n    })\n\n    r.Run(\":8080\")\n}"
  }
],
javaandroid:
  [
  {
    "title": "Android Java HOME",
    "note": "Android is a mobile operating system developed by Google. Java is one of the primary languages used for Android development. Android apps run on the Android Runtime (ART) and are packaged as APK files. Android Studio is the official IDE.",
    "code": "// Official Website: https://developer.android.com/\n// Documentation: https://developer.android.com/docs\n// Try Online: https://www.jdoodle.com/\n\n// Entry point is typically MainActivity.java in Android Studio."
  },
  {
    "title": "Android Activity Basics",
    "note": "An Activity represents a single screen in Android. Each Activity extends AppCompatActivity or Activity, and the UI is set using setContentView with a layout XML file.",
    "code": "package com.example.myapp;\n\nimport android.os.Bundle;\nimport androidx.appcompat.app.AppCompatActivity;\nimport android.widget.TextView;\n\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        TextView tv = findViewById(R.id.textView);\n        tv.setText(\"Hello, Android Java!\");\n    }\n}"
  },
  {
    "title": "Android Layouts",
    "note": "Layouts define the UI in XML. Common layouts: LinearLayout, RelativeLayout, ConstraintLayout. You can arrange widgets vertically, horizontally, or in complex designs.",
    "code": "<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    android:padding=\"16dp\">\n\n    <TextView\n        android:id=\"@+id/textView\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World\" />\n\n    <Button\n        android:id=\"@+id/button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Click Me\" />\n\n</LinearLayout>"
  },
  {
    "title": "Android Buttons & Events",
    "note": "Buttons and other widgets can respond to user actions via onClick listeners.",
    "code": "Button btn = findViewById(R.id.button);\nbtn.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Toast.makeText(MainActivity.this, \"Button clicked!\", Toast.LENGTH_SHORT).show();\n    }\n});"
  },
  {
    "title": "Android Intents",
    "note": "Intents allow navigation between activities or apps. Can be explicit (target specific Activity) or implicit (perform an action like opening a URL).",
    "code": "Intent intent = new Intent(MainActivity.this, SecondActivity.class);\nstartActivity(intent);\n\n// Implicit Intent to open a web page\nIntent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(\"https://example.com\"));\nstartActivity(browserIntent);"
  },
  {
    "title": "Android RecyclerView",
    "note": "RecyclerView is a flexible, efficient list widget for displaying large datasets. Requires Adapter and ViewHolder classes.",
    "code": "RecyclerView recyclerView = findViewById(R.id.recyclerView);\nrecyclerView.setLayoutManager(new LinearLayoutManager(this));\nMyAdapter adapter = new MyAdapter(dataList);\nrecyclerView.setAdapter(adapter);"
  },
  {
    "title": "Android Fragments",
    "note": "Fragments are modular sections of UI within an activity. They can be reused in different activities and help with responsive designs.",
    "code": "public class MyFragment extends Fragment {\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_layout, container, false);\n    }\n}"
  },
  {
    "title": "Android SharedPreferences",
    "note": "SharedPreferences allows saving simple key-value data persistently, like user settings.",
    "code": "SharedPreferences prefs = getSharedPreferences(\"MyPrefs\", MODE_PRIVATE);\nSharedPreferences.Editor editor = prefs.edit();\neditor.putString(\"username\", \"Alice\");\neditor.apply();\n\nString name = prefs.getString(\"username\", \"default\");"
  },
  {
    "title": "Android SQLite Database",
    "note": "Android provides SQLite for local database storage. You can create tables, insert, update, delete, and query records.",
    "code": "SQLiteOpenHelper helper = new SQLiteOpenHelper(this, \"mydb\", null, 1) {\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        db.execSQL(\"CREATE TABLE users(id INTEGER PRIMARY KEY, name TEXT)\");\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {}\n};\n\nSQLiteDatabase db = helper.getWritableDatabase();\ndb.execSQL(\"INSERT INTO users(name) VALUES('Alice')\");"
  },
  {
    "title": "Android Networking (HTTP Requests)",
    "note": "Use libraries like Retrofit or Volley to make HTTP requests and consume APIs asynchronously.",
    "code": "Retrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.example.com/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build();\n\nMyApi api = retrofit.create(MyApi.class);\nCall<List<User>> call = api.getUsers();\ncall.enqueue(new Callback<List<User>>() {\n    @Override\n    public void onResponse(Call<List<User>> call, Response<List<User>> response) {\n        // Handle success\n    }\n\n    @Override\n    public void onFailure(Call<List<User>> call, Throwable t) {\n        // Handle failure\n    }\n});"
  },
  {
    "title": "Android Permissions",
    "note": "Android uses runtime permissions for sensitive actions (camera, location, storage). Must declare in Manifest and request at runtime for API 23+.",
    "code": "if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {\n    ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA}, 100);\n}"
  },
  {
    "title": "Android Lifecycle",
    "note": "Every Activity goes through lifecycle stages: onCreate(), onStart(), onResume(), onPause(), onStop(), onDestroy(). Managing these is crucial for saving state and performance.",
    "code": "@Override\nprotected void onStart() {\n    super.onStart();\n    Log.d(\"LIFECYCLE\", \"Activity Started\");\n}\n\n@Override\nprotected void onPause() {\n    super.onPause();\n    Log.d(\"LIFECYCLE\", \"Activity Paused\");\n}"
  },
  {
    "title": "Android Services",
    "note": "Services run background tasks without a UI. Examples: music playback, background sync. They can be started or bound to activities.",
    "code": "public class MyService extends Service {\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        Log.d(\"SERVICE\", \"Service Started\");\n        return START_STICKY;\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n}"
  },
  {
    "title": "Android Notifications",
    "note": "Notifications allow apps to alert users outside the app. Built using NotificationManager and NotificationCompat.Builder.",
    "code": "NotificationCompat.Builder builder = new NotificationCompat.Builder(this, \"default\")\n    .setSmallIcon(R.drawable.ic_launcher)\n    .setContentTitle(\"My Notification\")\n    .setContentText(\"Hello, Android User!\")\n    .setPriority(NotificationCompat.PRIORITY_DEFAULT);\n\nNotificationManagerCompat manager = NotificationManagerCompat.from(this);\nmanager.notify(1, builder.build());"
  }
],
swiftios:[
  {
    "title": "Swift iOS HOME",
    "note": "Swift is Apple’s modern, powerful, and safe programming language for iOS, macOS, watchOS, and tvOS development. Swift is strongly typed, supports optionals, protocols, and closures. Xcode is the official IDE for Swift development.",
    "code": "// Official Website: https://developer.apple.com/swift/\n// Documentation: https://developer.apple.com/documentation/swift/\n// Try Online: https://replit.com/languages/swift\n\nimport SwiftUI\n\nprint(\"Hello, Swift!\")"
  },
  {
    "title": "Swift Basics",
    "note": "Swift is statically typed, supports type inference, and variables are declared using `var` (mutable) or `let` (immutable). Functions are first-class citizens.",
    "code": "var name: String = \"Alice\"\nlet age: Int = 25\nvar isActive: Bool = true\n\nprint(\"Name: \\(name), Age: \\(age), Active: \\(isActive)\")"
  },
  {
    "title": "Swift Data Types",
    "note": "Swift has basic types like String, Int, Double, Bool, Array, Dictionary, Set, and optional types. Optionals represent values that can be nil.",
    "code": "let str: String = \"Hello\"\nlet num: Int = 42\nlet pi: Double = 3.14\nlet isTrue: Bool = true\nlet arr: [Int] = [1,2,3]\nlet dict: [String: Int] = [\"Alice\": 25]\nlet optionalValue: String? = nil\n\nprint(arr[0])\nprint(dict[\"Alice\"] ?? 0)"
  },
  {
    "title": "Swift Conditionals",
    "note": "Swift supports if/else, switch, and ternary operators. Switch is very powerful and can pattern-match ranges, tuples, and enums.",
    "code": "let age = 18\n\nif age >= 18 {\n    print(\"Adult\")\n} else if age >= 13 {\n    print(\"Teen\")\n} else {\n    print(\"Child\")\n}\n\n// Ternary\nlet result = (age % 2 == 0) ? \"Even\" : \"Odd\"\nprint(result)\n\n// Switch\nswitch age {\ncase 0..<13: print(\"Child\")\ncase 13..<18: print(\"Teen\")\ndefault: print(\"Adult\")\n}"
  },
  {
    "title": "Swift Loops",
    "note": "Swift supports for-in, while, and repeat-while loops. You can iterate over arrays, ranges, dictionaries, or custom sequences.",
    "code": "for i in 0..<3 {\n    print(\"For loop \\(i)\")\n}\n\nvar j = 0\nwhile j < 3 {\n    print(\"While loop \\(j)\")\n    j += 1\n}\n\nlet arr = [1,2,3]\nfor n in arr {\n    print(\"Number: \\(n)\")\n}"
  },
  {
    "title": "Swift Functions",
    "note": "Functions in Swift can have parameters, return types, default values, variadic parameters, and use in-out arguments. Functions are first-class citizens.",
    "code": "func greet(name: String = \"Guest\") -> String {\n    return \"Hello, \\(name)!\"\n}\nprint(greet(name: \"Alice\"))\nprint(greet())\n\nfunc sum(_ numbers: Int...) -> Int {\n    return numbers.reduce(0, +)\n}\nprint(sum(1,2,3,4))"
  },
  {
    "title": "Swift Classes & Objects",
    "note": "Swift is object-oriented. Classes define blueprints; objects are instances. Use initializers to set up properties. Use `self` to reference instance properties.",
    "code": "class Person {\n    var name: String\n    var age: Int\n\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n\n    func greet() -> String {\n        return \"Hi, I'm \\(name), age \\(age)\"\n    }\n}\n\nlet p1 = Person(name: \"Alice\", age: 25)\nprint(p1.greet())"
  },
  {
    "title": "Swift Optionals",
    "note": "Optionals represent values that may be nil. Use `?` for optional chaining, `!` for force unwrapping, or `??` for default values.",
    "code": "var optionalName: String? = \"Alice\"\nprint(optionalName?.uppercased() ?? \"No name\")\noptionalName = nil\nprint(optionalName ?? \"Default\")"
  },
  {
    "title": "Swift Closures",
    "note": "Closures are anonymous functions, similar to lambdas in other languages. They can capture variables from their surrounding context.",
    "code": "let numbers = [1,2,3,4]\nlet squares = numbers.map { $0 * $0 }\nprint(squares)\n\nlet greetClosure: (String) -> String = { name in\n    return \"Hello, \\(name)!\"\n}\nprint(greetClosure(\"Alice\"))"
  },
  {
    "title": "Swift UIKit Basics",
    "note": "UIKit is the framework for building iOS UIs. Use UIViewController for screens, UILabel for text, UIButton for buttons, and connect via IBOutlet/IBAction.",
    "code": "import UIKit\n\nclass ViewController: UIViewController {\n    @IBOutlet weak var label: UILabel!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        label.text = \"Hello, UIKit!\"\n    }\n    \n    @IBAction func buttonTapped(_ sender: UIButton) {\n        label.text = \"Button clicked!\"\n    }\n}"
  },
  {
    "title": "Swift SwiftUI Basics",
    "note": "SwiftUI is Apple’s modern declarative UI framework. Views are defined with structs conforming to View. Use @State for reactive data.",
    "code": "import SwiftUI\n\nstruct ContentView: View {\n    @State private var count = 0\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(count)\")\n            Button(\"Increment\") {\n                count += 1\n            }\n        }\n        .padding()\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}"
  },
  {
    "title": "Swift Networking",
    "note": "Use URLSession or third-party libraries like Alamofire to fetch data from APIs asynchronously.",
    "code": "import Foundation\n\nlet url = URL(string: \"https://jsonplaceholder.typicode.com/todos/1\")!\nURLSession.shared.dataTask(with: url) { data, response, error in\n    if let data = data {\n        if let json = try? JSONSerialization.jsonObject(with: data, options: []) {\n            print(json)\n        }\n    }\n}.resume()"
  },
  {
    "title": "Swift Data Persistence",
    "note": "Use UserDefaults for small key-value storage, CoreData for structured data, and FileManager for file storage.",
    "code": "// UserDefaults example\nlet defaults = UserDefaults.standard\ndefaults.set(\"Alice\", forKey: \"username\")\nlet name = defaults.string(forKey: \"username\") ?? \"Guest\"\nprint(name)"
  }
],
objectivecios:[
  {
    "title": "Objective-C iOS HOME",
    "note": "Objective-C is Apple’s original object-oriented programming language for iOS and macOS development. It’s a superset of C with Smalltalk-style messaging. While Swift is now preferred, Objective-C is still widely used in legacy projects.",
    "code": "// Official Documentation: https://developer.apple.com/documentation/objectivec/\n// Try Online: https://repl.it/languages/objectivec\n\n#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@\"Hello, Objective-C!\");\n    }\n    return 0;\n}"
  },
  {
    "title": "Objective-C Basics",
    "note": "Objective-C is statically typed. Variables are declared using types like NSString, int, BOOL, etc. Programs start with a main function using @autoreleasepool for memory management.",
    "code": "#import <Foundation/Foundation.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSString *name = @\"Alice\";\n        int age = 25;\n        BOOL isActive = YES;\n\n        NSLog(@\"Name: %@, Age: %d, Active: %d\", name, age, isActive);\n    }\n    return 0;\n}"
  },
  {
    "title": "Objective-C Data Types",
    "note": "Objective-C has basic types like int, float, double, BOOL, char and object types like NSString, NSArray, NSDictionary. Use @ for string literals and container literals.",
    "code": "#import <Foundation/Foundation.h>\n\nint main() {\n    NSString *str = @\"Hello\";\n    int num = 42;\n    double pi = 3.14;\n    BOOL isTrue = YES;\n    NSArray *arr = @[@1, @2, @3];\n    NSDictionary *dict = @{ @\"Alice\" : @25 };\n\n    NSLog(@\"Array first element: %@\", arr[0]);\n    NSLog(@\"String uppercase: %@\", [str uppercaseString]);\n    return 0;\n}"
  },
  {
    "title": "Objective-C Conditionals",
    "note": "Use if/else and switch for conditionals. BOOL values use YES/NO. Switch works with integers and enums.",
    "code": "#import <Foundation/Foundation.h>\n\nint main() {\n    int age = 18;\n    if (age >= 18) {\n        NSLog(@\"Adult\");\n    } else if (age >= 13) {\n        NSLog(@\"Teen\");\n    } else {\n        NSLog(@\"Child\");\n    }\n\n    int result = (age % 2 == 0) ? 1 : 0;\n    NSLog(@\"Even? %d\", result);\n\n    switch (age) {\n        case 0 ... 12:\n            NSLog(@\"Child\");\n            break;\n        case 13 ... 17:\n            NSLog(@\"Teen\");\n            break;\n        default:\n            NSLog(@\"Adult\");\n            break;\n    }\n    return 0;\n}"
  },
  {
    "title": "Objective-C Loops",
    "note": "Objective-C supports for, while, and do-while loops. Fast enumeration (for-in) is used to iterate over arrays and dictionaries.",
    "code": "#import <Foundation/Foundation.h>\n\nint main() {\n    for (int i = 0; i < 3; i++) {\n        NSLog(@\"For loop %d\", i);\n    }\n\n    int j = 0;\n    while (j < 3) {\n        NSLog(@\"While loop %d\", j);\n        j++;\n    }\n\n    NSArray *arr = @[@1, @2, @3];\n    for (NSNumber *n in arr) {\n        NSLog(@\"Number: %@\", n);\n    }\n    return 0;\n}"
  },
  {
    "title": "Objective-C Functions / Methods",
    "note": "Functions are defined as C functions. Methods belong to classes and are defined with - (instance) or + (class) syntax. Methods can have parameters and return values.",
    "code": "#import <Foundation/Foundation.h>\n\n@interface Greeter : NSObject\n- (NSString *)greet:(NSString *)name;\n@end\n\n@implementation Greeter\n- (NSString *)greet:(NSString *)name {\n    return [NSString stringWithFormat:@\"Hello, %@!\", name];\n}\n@end\n\nint main() {\n    @autoreleasepool {\n        Greeter *g = [[Greeter alloc] init];\n        NSLog(@\"%@\", [g greet:@\"Alice\"]);\n    }\n    return 0;\n}"
  },
  {
    "title": "Objective-C Classes & Objects",
    "note": "Objective-C is object-oriented. Classes are defined with @interface and @implementation. Use @property for getters/setters. Objects are instantiated with alloc/init.",
    "code": "#import <Foundation/Foundation.h>\n\n@interface Person : NSObject\n@property NSString *name;\n@property int age;\n- (instancetype)initWithName:(NSString *)name age:(int)age;\n- (void)greet;\n@end\n\n@implementation Person\n- (instancetype)initWithName:(NSString *)name age:(int)age {\n    self = [super init];\n    if (self) {\n        _name = name;\n        _age = age;\n    }\n    return self;\n}\n- (void)greet {\n    NSLog(@\"Hi, I'm %@, age %d\", _name, _age);\n}\n@end\n\nint main() {\n    @autoreleasepool {\n        Person *p1 = [[Person alloc] initWithName:@\"Alice\" age:25];\n        [p1 greet];\n    }\n    return 0;\n}"
  },
  {
    "title": "Objective-C Memory Management",
    "note": "Objective-C uses Automatic Reference Counting (ARC). Use strong, weak, and unowned to manage references. @autoreleasepool ensures temporary objects are released.",
    "code": "// Example handled automatically by ARC\nNSString *strongStr = [[NSString alloc] initWithFormat:@\"Hello\"];\n__weak NSString *weakStr = strongStr;\nNSLog(@\"%@\", weakStr);"
  },
  {
    "title": "Objective-C UIKit Basics",
    "note": "UIKit provides the UI framework for iOS apps. Use UIViewController for screens, UILabel for text, UIButton for buttons. Connect via IBOutlet and IBAction.",
    "code": "#import <UIKit/UIKit.h>\n\n@interface ViewController : UIViewController\n@property (weak, nonatomic) IBOutlet UILabel *label;\n- (IBAction)buttonTapped:(UIButton *)sender;\n@end\n\n@implementation ViewController\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    self.label.text = @\"Hello, UIKit!\";\n}\n- (IBAction)buttonTapped:(UIButton *)sender {\n    self.label.text = @\"Button clicked!\";\n}\n@end"
  },
  {
    "title": "Objective-C Networking",
    "note": "Use NSURLSession for asynchronous HTTP requests and JSON parsing.",
    "code": "#import <Foundation/Foundation.h>\n\nNSURL *url = [NSURL URLWithString:@\"https://jsonplaceholder.typicode.com/todos/1\"];\nNSURLSessionDataTask *task = [[NSURLSession sharedSession] dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n    if (data) {\n        NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];\n        NSLog(@\"%@\", json);\n    }\n}];\n[task resume];"
  },
  {
    "title": "Objective-C Data Persistence",
    "note": "Use NSUserDefaults for key-value storage, Core Data for structured data, and FileManager for file operations.",
    "code": "// NSUserDefaults example\nNSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];\n[defaults setObject:@\"Alice\" forKey:@\"username\"];\nNSString *name = [defaults stringForKey:@\"username\"];\nNSLog(@\"%@\", name);"
  }
],
reactnative:[
  {
    "title": "React Native HOME",
    "note": "React Native is a popular JavaScript framework for building cross-platform mobile apps (iOS & Android) using a single codebase. It uses React concepts like components, state, and props while providing native-like performance.",
    "code": "// Official Website: https://reactnative.dev/\n// Documentation: https://reactnative.dev/docs/getting-started\n// Try Online: https://snack.expo.dev/\n\nimport React from 'react';\nimport { Text, View } from 'react-native';\n\nexport default function App() {\n  return (\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\n      <Text>Hello, React Native!</Text>\n    </View>\n  );\n}"
  },
  {
    "title": "React Native Components",
    "note": "Components are the building blocks of a React Native app. Functional components and class components are supported. Use built-in components like View, Text, Image, ScrollView, FlatList.",
    "code": "import React from 'react';\nimport { View, Text, Image } from 'react-native';\n\nexport default function Profile() {\n  return (\n    <View>\n      <Text>Name: Alice</Text>\n      <Image source={{ uri: 'https://via.placeholder.com/100' }} style={{ width: 100, height: 100 }} />\n    </View>\n  );\n}"
  },
  {
    "title": "React Native Props",
    "note": "Props are used to pass data from parent to child components. They are read-only and help make components reusable.",
    "code": "import React from 'react';\nimport { View, Text } from 'react-native';\n\nfunction Greeting({ name }) {\n  return <Text>Hello, {name}!</Text>;\n}\n\nexport default function App() {\n  return (\n    <View>\n      <Greeting name=\"Alice\" />\n      <Greeting name=\"Bob\" />\n    </View>\n  );\n}"
  },
  {
    "title": "React Native State",
    "note": "State allows components to maintain internal data. Functional components use useState hook. Updating state triggers UI re-render.",
    "code": "import React, { useState } from 'react';\nimport { View, Text, Button } from 'react-native';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <View>\n      <Text>Count: {count}</Text>\n      <Button title=\"Increment\" onPress={() => setCount(count + 1)} />\n    </View>\n  );\n}"
  },
  {
    "title": "React Native Styles",
    "note": "Styles in React Native are defined as JavaScript objects or using StyleSheet.create. It uses Flexbox for layout.",
    "code": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\n\nexport default function StyledBox() {\n  return (\n    <View style={styles.container}>\n      <Text style={styles.text}>Styled Text</Text>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#f0f0f0'\n  },\n  text: {\n    fontSize: 20,\n    color: 'blue'\n  }\n});"
  },
  {
    "title": "React Native TextInput & Events",
    "note": "TextInput allows user input. Use onChangeText to capture input and onPress for button events.",
    "code": "import React, { useState } from 'react';\nimport { View, TextInput, Button, Text } from 'react-native';\n\nexport default function InputDemo() {\n  const [name, setName] = useState('');\n\n  return (\n    <View>\n      <TextInput placeholder=\"Enter name\" value={name} onChangeText={setName} style={{ borderWidth: 1, padding: 8, margin: 8 }} />\n      <Button title=\"Greet\" onPress={() => alert(`Hello, ${name}`)} />\n      <Text>Your name: {name}</Text>\n    </View>\n  );\n}"
  },
  {
    "title": "React Native FlatList",
    "note": "FlatList is used for rendering large lists efficiently. Requires data array and renderItem function.",
    "code": "import React from 'react';\nimport { View, FlatList, Text } from 'react-native';\n\nexport default function ListDemo() {\n  const data = [{id: '1', name: 'Alice'}, {id: '2', name: 'Bob'}];\n\n  return (\n    <FlatList\n      data={data}\n      keyExtractor={item => item.id}\n      renderItem={({ item }) => <Text>{item.name}</Text>}\n    />\n  );\n}"
  },
  {
    "title": "React Native Navigation",
    "note": "React Navigation is the standard library for navigation between screens. Supports stack, tab, and drawer navigation.",
    "code": "// Install: npm install @react-navigation/native @react-navigation/stack react-native-screens react-native-safe-area-context\n\nimport React from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport { View, Text, Button } from 'react-native';\n\nfunction Home({ navigation }) {\n  return (\n    <View>\n      <Text>Home Screen</Text>\n      <Button title=\"Go to Details\" onPress={() => navigation.navigate('Details')} />\n    </View>\n  );\n}\n\nfunction Details() {\n  return <View><Text>Details Screen</Text></View>;\n}\n\nconst Stack = createStackNavigator();\n\nexport default function App() {\n  return (\n    <NavigationContainer>\n      <Stack.Navigator>\n        <Stack.Screen name=\"Home\" component={Home} />\n        <Stack.Screen name=\"Details\" component={Details} />\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}"
  },
  {
    "title": "React Native API Fetch",
    "note": "Use fetch or axios to make HTTP requests. Typically done inside useEffect to load data on component mount.",
    "code": "import React, { useState, useEffect } from 'react';\nimport { View, Text } from 'react-native';\n\nexport default function APIDemo() {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetch('https://jsonplaceholder.typicode.com/todos/1')\n      .then(response => response.json())\n      .then(json => setData(json));\n  }, []);\n\n  return (\n    <View>\n      <Text>{data ? JSON.stringify(data) : 'Loading...'}</Text>\n    </View>\n  );\n}"
  },
  {
    "title": "React Native AsyncStorage",
    "note": "AsyncStorage allows persistent key-value storage. Useful for saving user preferences or tokens.",
    "code": "// Install: npm install @react-native-async-storage/async-storage\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport React, { useState, useEffect } from 'react';\nimport { View, Button, Text } from 'react-native';\n\nexport default function StorageDemo() {\n  const [name, setName] = useState('');\n\n  const saveName = async () => { await AsyncStorage.setItem('name', 'Alice'); };\n  const loadName = async () => { const n = await AsyncStorage.getItem('name'); setName(n); };\n\n  useEffect(() => { loadName(); }, []);\n\n  return (\n    <View>\n      <Button title=\"Save Name\" onPress={saveName} />\n      <Text>Saved Name: {name}</Text>\n    </View>\n  );\n}"
  }
],
flutter:
[
  {
    "title": "Flutter HOME",
    "note": "Flutter is Google's UI toolkit for building natively compiled applications for mobile, web, and desktop from a single codebase. It uses the Dart programming language and provides a rich set of pre-designed widgets for fast development.",
    "code": "// Official Website: https://flutter.dev/\n// Documentation: https://flutter.dev/docs\n// Try Online: https://dartpad.dev/\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Hello, Flutter!')),\n        body: Center(child: Text('Welcome to Flutter')),\n      ),\n    );\n  }\n}"
  },
  {
    "title": "Flutter Widgets",
    "note": "Everything in Flutter is a widget. Widgets can be Stateful (maintain state) or Stateless (immutable). Common widgets: Text, Container, Row, Column, Image, ListView, Scaffold, AppBar, and Buttons.",
    "code": "import 'package:flutter/material.dart';\n\nclass MyWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(16),\n      color: Colors.blueAccent,\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text('Hello Flutter', style: TextStyle(color: Colors.white, fontSize: 24)),\n          ElevatedButton(onPressed: () {}, child: Text('Press Me'))\n        ],\n      ),\n    );\n  }\n}"
  },
  {
    "title": "Flutter State Management",
    "note": "State management is key in Flutter. Use StatefulWidget for local state. For global state, use Provider, Riverpod, or Bloc. Updating state triggers UI rebuild.",
    "code": "import 'package:flutter/material.dart';\n\nclass Counter extends StatefulWidget {\n  @override\n  _CounterState createState() => _CounterState();\n}\n\nclass _CounterState extends State<Counter> {\n  int count = 0;\n\n  void increment() {\n    setState(() {\n      count++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text('Count: $count'),\n        ElevatedButton(onPressed: increment, child: Text('Increment'))\n      ],\n    );\n  }\n}"
  },
  {
    "title": "Flutter Layouts",
    "note": "Flutter uses widgets for layouts. Common layout widgets: Column, Row, Stack, Container, Padding, Center. Use Flex, Expanded, and Spacer for flexible layouts.",
    "code": "import 'package:flutter/material.dart';\n\nclass LayoutDemo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.spaceAround,\n      children: [\n        Container(width: 50, height: 50, color: Colors.red),\n        Container(width: 50, height: 50, color: Colors.green),\n        Container(width: 50, height: 50, color: Colors.blue),\n      ],\n    );\n  }\n}"
  },
  {
    "title": "Flutter Navigation",
    "note": "Flutter navigation allows moving between screens. Use Navigator.push for forward navigation and Navigator.pop to go back. For complex apps, consider Navigator 2.0 or packages like go_router.",
    "code": "import 'package:flutter/material.dart';\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Home')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () => Navigator.push(\n            context,\n            MaterialPageRoute(builder: (context) => DetailsScreen()),\n          ),\n          child: Text('Go to Details'),\n        ),\n      ),\n    );\n  }\n}\n\nclass DetailsScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Details')),\n      body: Center(child: Text('Details Page')),\n    );\n  }\n}"
  },
  {
    "title": "Flutter Lists (ListView)",
    "note": "ListView is used for scrolling lists. Use ListView.builder for large dynamic lists. Each item is a widget.",
    "code": "import 'package:flutter/material.dart';\n\nclass ListDemo extends StatelessWidget {\n  final List<String> items = ['Alice', 'Bob', 'Charlie'];\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: items.length,\n      itemBuilder: (context, index) {\n        return ListTile(title: Text(items[index]));\n      },\n    );\n  }\n}"
  },
  {
    "title": "Flutter Forms & TextField",
    "note": "TextField is used for user input. Forms use Form widget with GlobalKey to validate and submit inputs.",
    "code": "import 'package:flutter/material.dart';\n\nclass FormDemo extends StatefulWidget {\n  @override\n  _FormDemoState createState() => _FormDemoState();\n}\n\nclass _FormDemoState extends State<FormDemo> {\n  final _controller = TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TextField(controller: _controller, decoration: InputDecoration(labelText: 'Enter name')),\n        ElevatedButton(onPressed: () => print(_controller.text), child: Text('Submit'))\n      ],\n    );\n  }\n}"
  },
  {
    "title": "Flutter API Fetch (HTTP)",
    "note": "Use http package to fetch APIs. Typically done inside initState or FutureBuilder for async data loading.",
    "code": "import 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nclass APIDemo extends StatefulWidget {\n  @override\n  _APIDemoState createState() => _APIDemoState();\n}\n\nclass _APIDemoState extends State<APIDemo> {\n  Map<String, dynamic>? data;\n\n  @override\n  void initState() {\n    super.initState();\n    fetchData();\n  }\n\n  Future<void> fetchData() async {\n    final response = await http.get(Uri.parse('https://jsonplaceholder.typicode.com/todos/1'));\n    setState(() {\n      data = json.decode(response.body);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(child: Text(data != null ? data.toString() : 'Loading...'));\n  }\n}"
  },
  {
    "title": "Flutter Persistent Storage (SharedPreferences)",
    "note": "Use shared_preferences package to store key-value pairs persistently, such as user settings or tokens.",
    "code": "// Add dependency: shared_preferences: ^2.0.0\nimport 'package:flutter/material.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\nclass StorageDemo extends StatefulWidget {\n  @override\n  _StorageDemoState createState() => _StorageDemoState();\n}\n\nclass _StorageDemoState extends State<StorageDemo> {\n  String name = '';\n\n  void saveName() async {\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setString('name', 'Alice');\n  }\n\n  void loadName() async {\n    final prefs = await SharedPreferences.getInstance();\n    setState(() {\n      name = prefs.getString('name') ?? '';\n    });\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    loadName();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ElevatedButton(onPressed: saveName, child: Text('Save Name')),\n        Text('Saved Name: $name')\n      ],\n    );\n  }\n}"
  },
  {
    "title": "Flutter Images & Assets",
    "note": "Add images in pubspec.yaml under 'assets:'. Use Image.asset for local images or Image.network for remote images.",
    "code": "import 'package:flutter/material.dart';\n\nclass ImageDemo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Image.asset('assets/logo.png', width: 100, height: 100),\n        Image.network('https://picsum.photos/200', width: 100, height: 100),\n      ],\n    );\n  }\n}"
  },
  {
    "title": "Flutter Theming & Styling",
    "note": "Use ThemeData to define global styles. Widgets can be customized with colors, typography, and shapes.",
    "code": "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        primarySwatch: Colors.deepPurple,\n        textTheme: TextTheme(bodyText2: TextStyle(fontSize: 18)),\n      ),\n      home: Scaffold(\n        appBar: AppBar(title: Text('Theming Example')),\n        body: Center(child: Text('Styled with ThemeData')),\n      ),\n    );\n  }\n}"
  },
  {
    "title": "Flutter Animations",
    "note": "Flutter supports animations via AnimationController, Tween, and built-in widgets like AnimatedContainer or Hero.",
    "code": "import 'package:flutter/material.dart';\n\nclass AnimationDemo extends StatefulWidget {\n  @override\n  _AnimationDemoState createState() => _AnimationDemoState();\n}\n\nclass _AnimationDemoState extends State<AnimationDemo> {\n  double size = 100;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: AnimatedContainer(\n          duration: Duration(seconds: 1),\n          width: size,\n          height: size,\n          color: Colors.blue,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          setState(() {\n            size = size == 100 ? 200 : 100;\n          });\n        },\n        child: Icon(Icons.play_arrow),\n      ),\n    );\n  }\n}"
  }
],
ionic:
[
  {
    "title": "Ionic HOME",
    "note": "Ionic Framework is a powerful open-source SDK for building cross-platform mobile apps using web technologies like HTML, CSS, and JavaScript. It works with Angular, React, or Vue, and allows building apps for iOS, Android, and the web from a single codebase.",
    "code": "// Official Website: https://ionicframework.com/\n// Documentation: https://ionicframework.com/docs\n// Try Online: https://stackblitz.com/\n\n// Install Ionic CLI\nnpm install -g @ionic/cli\n\n// Create a new app\nionic start myApp blank --type=angular\n\n// Run app\nionic serve"
  },
  {
    "title": "Ionic Components",
    "note": "Ionic provides a rich library of UI components like buttons, cards, lists, inputs, tabs, and modals. Components are responsive and styled for mobile apps.",
    "code": "<ion-header>\n  <ion-toolbar>\n    <ion-title>Hello Ionic</ion-title>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content class=\"ion-padding\">\n  <ion-button expand=\"full\" (click)=\"sayHello()\">Click Me</ion-button>\n</ion-content>\n\n// In Angular Component\nsayHello() {\n  alert('Hello Ionic!');\n}"
  },
  {
    "title": "Ionic Navigation",
    "note": "Navigation in Ionic uses Angular Router (or React Router). Pages are components, and you can navigate using routerLink, NavController, or programmatic routing.",
    "code": "import { NavController } from '@ionic/angular';\n\nconstructor(private navCtrl: NavController) {}\n\ngoToDetails() {\n  this.navCtrl.navigateForward('/details');\n}\n\n// In template:\n<ion-button (click)=\"goToDetails()\">Go to Details</ion-button>"
  },
  {
    "title": "Ionic Forms & Input",
    "note": "Ionic uses standard HTML inputs enhanced with Ionic styling. You can use Angular Reactive Forms or Template-driven Forms for validation and user input handling.",
    "code": "<ion-item>\n  <ion-label position=\"floating\">Name</ion-label>\n  <ion-input [(ngModel)]=\"name\"></ion-input>\n</ion-item>\n<ion-button (click)=\"submitForm()\">Submit</ion-button>\n\nsubmitForm() {\n  console.log('Name:', this.name);\n}"
  },
  {
    "title": "Ionic Lists",
    "note": "Ionic List component displays scrolling lists of items. Supports sliding items, avatars, icons, and click events.",
    "code": "<ion-list>\n  <ion-item *ngFor=\"let item of items\" (click)=\"selectItem(item)\">\n    <ion-label>{{item}}</ion-label>\n  </ion-item>\n</ion-list>\n\nitems = ['Item 1', 'Item 2', 'Item 3'];\n\nselectItem(item) {\n  console.log('Selected:', item);\n}"
  },
  {
    "title": "Ionic Services & Dependency Injection",
    "note": "Ionic leverages Angular services for reusable logic, API calls, and state management. Services are injected into components via constructor.",
    "code": "import { Injectable } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nexport class ApiService {\n  constructor(private http: HttpClient) {}\n\n  getData() {\n    return this.http.get('https://jsonplaceholder.typicode.com/todos/1');\n  }\n}\n\n// In component:\nthis.apiService.getData().subscribe(data => console.log(data));"
  },
  {
    "title": "Ionic API Integration",
    "note": "Use Angular HttpClient or Fetch API to interact with backend APIs. Async calls can update the UI via Observables or Promises.",
    "code": "import { HttpClient } from '@angular/common/http';\n\nconstructor(private http: HttpClient) {}\n\nfetchData() {\n  this.http.get('https://jsonplaceholder.typicode.com/todos/1')\n    .subscribe(response => console.log(response));\n}"
  },
  {
    "title": "Ionic Storage",
    "note": "Use Ionic Storage for persistent key-value storage across platforms. Can store data like user preferences or tokens.",
    "code": "import { Storage } from '@ionic/storage-angular';\n\nconstructor(private storage: Storage) {\n  this.init();\n}\n\nasync init() {\n  await this.storage.create();\n}\n\nasync saveName() {\n  await this.storage.set('name', 'Alice');\n}\n\nasync loadName() {\n  const name = await this.storage.get('name');\n  console.log(name);\n}"
  },
  {
    "title": "Ionic Capacitor Plugins",
    "note": "Capacitor provides native device features like Camera, Geolocation, and Push Notifications. Use plugins to access device hardware.",
    "code": "import { Camera, CameraResultType } from '@capacitor/camera';\n\nasync takePhoto() {\n  const image = await Camera.getPhoto({\n    quality: 90,\n    allowEditing: false,\n    resultType: CameraResultType.Uri\n  });\n  console.log(image.webPath);\n}"
  },
  {
    "title": "Ionic Theming",
    "note": "Ionic supports powerful theming using CSS variables. You can customize colors, dark mode, and component styles globally or locally.",
    "code": "/* in variables.css */\n:root {\n  --ion-color-primary: #3880ff;\n  --ion-color-secondary: #0cd1e8;\n  --ion-color-tertiary: #7044ff;\n}"
  },
  {
    "title": "Ionic Lifecycle Events",
    "note": "Ionic components and pages provide lifecycle hooks like ionViewDidEnter, ionViewWillLeave. These are useful for initializing data or cleaning resources when entering or leaving a page.",
    "code": "ionViewDidEnter() {\n  console.log('Page loaded');\n}\n\nionViewWillLeave() {\n  console.log('Leaving page');\n}"
  },
  {
    "title": "Ionic Tabs",
    "note": "Tabs are a popular navigation pattern in Ionic apps. You can define multiple tab pages with icons and routes.",
    "code": "<ion-tabs>\n  <ion-tab-bar slot=\"bottom\">\n    <ion-tab-button tab=\"home\">\n      <ion-icon name=\"home\"></ion-icon>\n      <ion-label>Home</ion-label>\n    </ion-tab-button>\n    <ion-tab-button tab=\"settings\">\n      <ion-icon name=\"settings\"></ion-icon>\n      <ion-label>Settings</ion-label>\n    </ion-tab-button>\n  </ion-tab-bar>\n</ion-tabs>"
  },
  {
    "title": "Ionic Testing",
    "note": "Ionic apps can be tested using Jasmine, Karma, and Angular Testing utilities. End-to-end testing can be performed using Protractor or Cypress.",
    "code": "import { TestBed } from '@angular/core/testing';\nimport { AppComponent } from './app.component';\n\ndescribe('AppComponent', () => {\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [AppComponent]\n    }).compileComponents();\n  });\n\n  it('should create the app', () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.componentInstance;\n    expect(app).toBeTruthy();\n  });\n});"
  },
  {
    "title": "Ionic Deployment",
    "note": "Ionic apps can be deployed to browsers (as PWA), Android (via APK/AAB), and iOS (via IPA). Use 'ionic build', then integrate with Capacitor to generate native builds.",
    "code": "// Build app for production\nionic build\n\n// Add platforms\nionic cap add android\nionic cap add ios\n\n// Open Android Studio or Xcode\nionic cap open android\nionic cap open ios"
  }

],
xamarin:
[
  {
    "title": "Xamarin HOME",
    "note": "Xamarin is a Microsoft-owned framework for building cross-platform mobile apps using C#. It allows developers to write shared code for iOS, Android, and Windows. Xamarin.Forms enables UI sharing, while Xamarin.Android and Xamarin.iOS provide platform-specific control.",
    "code": "// Official Website: https://dotnet.microsoft.com/apps/xamarin\n// Documentation: https://learn.microsoft.com/xamarin/\n// Try Online: https://dotnetfiddle.net/\n\n// Install via Visual Studio with Mobile development workload\n// Create a new project -> Mobile App (Xamarin.Forms)"
  },
  {
    "title": "Xamarin Project Structure",
    "note": "Xamarin.Forms projects typically have a shared project (code + XAML UI), plus platform-specific projects for Android, iOS, and UWP. Shared project contains App.xaml, MainPage.xaml, and view models.",
    "code": "// Shared Project\nApp.xaml\nMainPage.xaml\nMainPage.xaml.cs\n\n// Android Project\nMainActivity.cs\n\n// iOS Project\nAppDelegate.cs"
  },
  {
    "title": "Xamarin Basics",
    "note": "Xamarin uses C# and .NET for development. The entry point is App.xaml.cs with a MainPage. UI is defined in XAML or C# code. Supports MVVM pattern with data binding.",
    "code": "using Xamarin.Forms;\n\npublic class App : Application {\n    public App() {\n        MainPage = new MainPage();\n    }\n}\n\npublic class MainPage : ContentPage {\n    public MainPage() {\n        Content = new Label { Text = \"Hello, Xamarin!\", VerticalOptions = LayoutOptions.CenterAndExpand, HorizontalOptions = LayoutOptions.CenterAndExpand };\n    }\n}"
  },
  {
    "title": "Xamarin Layouts",
    "note": "Xamarin provides layouts for arranging UI elements: StackLayout (vertical/horizontal), Grid (rows & columns), AbsoluteLayout, and RelativeLayout. Each layout positions child elements differently.",
    "code": "<StackLayout Padding=\"10\">\n  <Label Text=\"Hello Xamarin\" />\n  <Button Text=\"Click Me\" />\n</StackLayout>\n\n// In C#\nvar stack = new StackLayout {\n    Children = { new Label { Text = \"Hello\" }, new Button { Text = \"Click\" } }\n};"
  },
  {
    "title": "Xamarin Controls",
    "note": "Common controls include Label, Button, Entry (input), Editor (multi-line input), Image, ListView, CollectionView, Picker, Slider, and Switch. All controls support data binding and events.",
    "code": "<StackLayout>\n  <Entry Placeholder=\"Enter name\" x:Name=\"nameEntry\" />\n  <Button Text=\"Greet\" Clicked=\"OnGreetClicked\" />\n  <Label x:Name=\"greetingLabel\" />\n</StackLayout>\n\nvoid OnGreetClicked(object sender, EventArgs e) {\n    greetingLabel.Text = $\"Hello, {nameEntry.Text}!\";\n}"
  },
  {
    "title": "Xamarin Navigation",
    "note": "Navigation between pages can be done using NavigationPage. Supports push/pop for stack-based navigation and modal pages for dialogs.",
    "code": "// In App.xaml.cs\nMainPage = new NavigationPage(new MainPage());\n\n// Navigate to another page\nawait Navigation.PushAsync(new DetailsPage());\n\n// Go back\nawait Navigation.PopAsync();"
  },
  {
    "title": "Xamarin Data Binding & MVVM",
    "note": "Xamarin.Forms supports MVVM. Bind UI controls to properties in ViewModels using {Binding PropertyName}. INotifyPropertyChanged is used to notify UI of changes.",
    "code": "public class MainViewModel : INotifyPropertyChanged {\n    private string _name;\n    public string Name {\n        get => _name;\n        set { _name = value; OnPropertyChanged(); }\n    }\n\n    public event PropertyChangedEventHandler PropertyChanged;\n    void OnPropertyChanged([CallerMemberName] string propertyName = null) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n}\n\n// In XAML\n<Entry Text=\"{Binding Name}\" />\n<Label Text=\"{Binding Name}\" />"
  },
  {
    "title": "Xamarin ListView & CollectionView",
    "note": "Xamarin ListView and CollectionView display lists of data with support for templates, grouping, and selection events.",
    "code": "<ListView ItemsSource=\"{Binding Items}\">\n  <ListView.ItemTemplate>\n    <DataTemplate>\n      <TextCell Text=\"{Binding Name}\" Detail=\"{Binding Detail}\" />\n    </DataTemplate>\n  </ListView.ItemTemplate>\n</ListView>\n\n// In ViewModel\npublic ObservableCollection<Item> Items { get; set; } = new ObservableCollection<Item> {\n  new Item { Name = \"Item 1\", Detail = \"Detail 1\" }\n};"
  },
  {
    "title": "Xamarin Services & Dependency Injection",
    "note": "Xamarin allows dependency injection to provide platform-specific implementations. You can create services for API calls, local storage, or device features.",
    "code": "public interface IApiService { Task<string> GetData(); }\n\npublic class ApiService : IApiService {\n  public async Task<string> GetData() => await Task.FromResult(\"Hello from API\");\n}\n\n// Register service in App.xaml.cs or via DI container\n// var service = new ApiService();"
  },
  {
    "title": "Xamarin API Integration",
    "note": "Use HttpClient to fetch data from REST APIs. Supports async/await for non-blocking calls and JSON parsing with Newtonsoft.Json or System.Text.Json.",
    "code": "using System.Net.Http;\nusing Newtonsoft.Json;\n\nvar client = new HttpClient();\nvar response = await client.GetStringAsync(\"https://jsonplaceholder.typicode.com/todos/1\");\nvar todo = JsonConvert.DeserializeObject<Todo>(response);\nConsole.WriteLine(todo.Title);"
  },
  {
    "title": "Xamarin Local Storage",
    "note": "Xamarin provides options for local storage: Preferences for key-value, SQLite for structured data, and Files for raw storage.",
    "code": "// Using Xamarin.Essentials Preferences\nPreferences.Set(\"username\", \"Alice\");\nstring username = Preferences.Get(\"username\", \"Default\");\nConsole.WriteLine(username);"
  },
  {
    "title": "Xamarin Device Features",
    "note": "Xamarin.Essentials provides cross-platform APIs for camera, geolocation, sensors, battery, network, and more. Use async calls for device interactions.",
    "code": "var location = await Geolocation.GetLastKnownLocationAsync();\nif(location != null) {\n    Console.WriteLine($\"Lat: {location.Latitude}, Long: {location.Longitude}\");\n}"
  },
  {
    "title": "Xamarin Animations & Effects",
    "note": "Xamarin supports animations using TranslateTo, FadeTo, RotateTo, ScaleTo, and custom effects for UI enhancements.",
    "code": "await myLabel.FadeTo(0, 500);\nawait myLabel.FadeTo(1, 500);\nawait myLabel.TranslateTo(0, 100, 300);"
  },
  {
    "title": "Xamarin Dependency Services",
    "note": "Use DependencyService to call platform-specific code from shared code. Define interface in shared project and implement per platform.",
    "code": "public interface IToast {\n  void Show(string message);\n}\n\n// Android implementation\n[assembly: Dependency(typeof(ToastService))]\npublic class ToastService : IToast {\n  public void Show(string message) {\n    Android.Widget.Toast.MakeText(Android.App.Application.Context, message, ToastLength.Short).Show();\n  }\n}\n\n// Usage in shared project\nDependencyService.Get<IToast>().Show(\"Hello Xamarin\");"
  },
  {
    "title": "Xamarin Push Notifications",
    "note": "Use Firebase Cloud Messaging (FCM) for Android and APNs for iOS. Integrate via plugins like Plugin.FirebasePushNotification for cross-platform support.",
    "code": "// Configure FCM in MainActivity.cs and AppDelegate.cs\n// Subscribe to notifications\nCrossFirebasePushNotification.Current.OnNotificationReceived += (s, p) => {\n  Console.WriteLine($\"Received: {p.Data}\" );\n};"
  },
  {
    "title": "Xamarin Lifecycle",
    "note": "Xamarin.Forms Application class has lifecycle events: OnStart, OnSleep, and OnResume. Each page also has OnAppearing and OnDisappearing events.",
    "code": "protected override void OnStart() {\n  Console.WriteLine(\"App started\");\n}\n\nprotected override void OnSleep() {\n  Console.WriteLine(\"App in background\");\n}\n\nprotected override void OnResume() {\n  Console.WriteLine(\"App resumed\");\n}"
  },
  {
    "title": "Xamarin Theming & Styles",
    "note": "Xamarin supports theming using ResourceDictionaries in App.xaml. You can define styles for consistency across pages, and switch between light/dark themes.",
    "code": "<Application.Resources>\n  <ResourceDictionary>\n    <Style TargetType=\"Label\">\n      <Setter Property=\"TextColor\" Value=\"Blue\" />\n      <Setter Property=\"FontSize\" Value=\"20\" />\n    </Style>\n  </ResourceDictionary>\n</Application.Resources>"
  },
  {
    "title": "Xamarin Testing",
    "note": "Xamarin apps can be tested with NUnit, MSTest, or xUnit for unit tests, and Xamarin.UITest for UI automation tests.",
    "code": "[Test]\npublic void AddingNumbersWorks() {\n    var result = Calculator.Add(2, 3);\n    Assert.AreEqual(5, result);\n}\n\n// UI Test example\n[Test]\npublic void AppLaunches() {\n    app.Screenshot(\"First screen\");\n    Assert.IsTrue(app.Query(c => c.Marked(\"MainPage\")).Any());\n}"
  },
  {
    "title": "Xamarin Deployment",
    "note": "Xamarin apps can be deployed as Android APK/AAB, iOS IPA, or Windows UWP app. Use Visual Studio tools for publishing to Google Play or Apple App Store.",
    "code": "// Android\nRight-click Android project → Archive → Distribute → Google Play\n\n// iOS\nArchive project → Publish → App Store Connect\n\n// UWP\nCreate App Package → Upload to Microsoft Store"
  }
],
sqlite:
[
  {
    "title": "SQLite HOME",
    "note": "SQLite is a lightweight, serverless, self-contained database engine stored in a single file. It is widely used in mobile apps (iOS, Android, Xamarin) and desktop applications because it doesn’t need a separate database server. Xamarin supports SQLite via the sqlite-net-pcl NuGet package, which provides simple APIs for creating models, tables, and executing CRUD operations. SQLite is ACID-compliant, supports transactions, and works offline, making it highly reliable for small to medium data storage needs.",
    "code": "// Official Website: https://www.sqlite.org/\n// SQLite-net-pcl NuGet: https://www.nuget.org/packages/sqlite-net-pcl/\n\n// Install via NuGet in Xamarin.Forms project\n// PM> Install-Package sqlite-net-pcl"
  },
  {
    "title": "SQLite Model Definition",
    "note": "In SQLite, each table is represented as a C# class (also called a data model). The properties in the class map directly to table columns. Attributes such as [PrimaryKey], [AutoIncrement], [Unique], and [MaxLength] can be used to configure constraints. This allows strong typing and compile-time validation in Xamarin projects.",
    "code": "using SQLite;\n\npublic class User {\n    [PrimaryKey, AutoIncrement]\n    public int Id { get; set; }\n\n    [MaxLength(50)]\n    public string Name { get; set; }\n\n    public int Age { get; set; }\n    public string Email { get; set; }\n}"
  },
  {
    "title": "SQLite Database Initialization",
    "note": "Before using SQLite, you must establish a connection to the database file. Xamarin.Essentials provides FileSystem.AppDataDirectory, which ensures the database is stored securely in a platform-specific location. Once connected, call CreateTable<T>() to ensure the schema is ready. This process will create tables if they do not already exist.",
    "code": "using SQLite;\nusing System.IO;\nusing Xamarin.Essentials;\n\nstring dbPath = Path.Combine(FileSystem.AppDataDirectory, \"appdata.db\");\nvar db = new SQLiteConnection(dbPath);\ndb.CreateTable<User>();"
  },
  {
    "title": "SQLite Insert Data",
    "note": "You can insert single or multiple records into a SQLite table. Insert() is synchronous, while InsertAsync() is non-blocking and preferred in mobile apps to prevent UI freezing. For large datasets, InsertAll() improves performance by committing multiple rows in a single transaction.",
    "code": "var user = new User { Name = \"Alice\", Age = 25, Email = \"alice@mail.com\" };\ndb.Insert(user);\n\n// Async version\n// await db.InsertAsync(user);\n\n// Bulk insert\n// db.InsertAll(new List<User>{ new User{Name=\"Tom\"}, new User{Name=\"Sara\"} });"
  },
  {
    "title": "SQLite Read Data",
    "note": "Reading data is flexible with SQLite. You can fetch all records, apply filters with LINQ, or use raw SQL queries. Table<T>() returns a queryable table, supporting advanced filtering, sorting, and projection. Async versions (ToListAsync, FirstOrDefaultAsync) prevent UI blocking in Xamarin apps.",
    "code": "// Get all users\nvar users = db.Table<User>().ToList();\n\n// Filter with LINQ\nvar adults = db.Table<User>().Where(u => u.Age >= 18).ToList();\n\n// Find specific user\nvar alice = db.Table<User>().FirstOrDefault(u => u.Name == \"Alice\");\n\n// Async example\n// var usersAsync = await db.Table<User>().ToListAsync();"
  },
  {
    "title": "SQLite Update Data",
    "note": "Updating records involves modifying the model object and calling Update(). You can update single or multiple records. With async operations (UpdateAsync), you avoid blocking the UI. Always ensure that the object’s primary key exists, otherwise Update() will fail silently.",
    "code": "alice.Age = 26;\ndb.Update(alice);\n\n// Async version\n// await db.UpdateAsync(alice);"
  },
  {
    "title": "SQLite Delete Data",
    "note": "SQLite allows deleting specific rows by passing the object or primary key to Delete(). For clearing entire tables, DeleteAll<T>() is efficient. Be careful with cascading deletes—SQLite does not enable foreign key constraints by default; they must be turned on manually.",
    "code": "// Delete a user\ndb.Delete(alice);\n\n// Delete by Id\ndb.Delete<User>(alice.Id);\n\n// Delete all users\ndb.DeleteAll<User>();"
  },
  {
    "title": "SQLite Query Examples",
    "note": "You can use both LINQ and raw SQL queries. LINQ ensures type-safety, while raw SQL offers more flexibility for complex operations. SQLite supports joins, aggregations, and parameterized queries to prevent SQL injection.",
    "code": "// LINQ queries\nvar adults = db.Table<User>().Where(u => u.Age >= 18).OrderBy(u => u.Name).ToList();\n\n// Raw SQL query\nvar teens = db.Query<User>(\"SELECT * FROM User WHERE Age BETWEEN ? AND ?\", 13, 19);"
  },
  {
    "title": "SQLite Async Operations",
    "note": "Mobile apps should use SQLiteAsyncConnection to avoid blocking the UI. Async methods are essential for smooth scrolling and responsiveness. Always await operations like CreateTableAsync, InsertAsync, UpdateAsync, and DeleteAsync.",
    "code": "var dbAsync = new SQLiteAsyncConnection(dbPath);\nawait dbAsync.CreateTableAsync<User>();\nawait dbAsync.InsertAsync(new User { Name = \"Bob\", Age = 30 });\nvar users = await dbAsync.Table<User>().ToListAsync();"
  },
  {
    "title": "SQLite Integration with Xamarin.Forms UI",
    "note": "SQLite integrates with UI via data binding. Use ObservableCollection in ViewModels to automatically reflect changes in UI. Following MVVM pattern keeps database logic separate from UI code, improving maintainability.",
    "code": "public class MainViewModel : INotifyPropertyChanged {\n    private SQLiteAsyncConnection _db;\n    public ObservableCollection<User> Users { get; set; } = new ObservableCollection<User>();\n\n    public MainViewModel(string dbPath) {\n        _db = new SQLiteAsyncConnection(dbPath);\n        LoadUsers();\n    }\n\n    public async void LoadUsers() {\n        var list = await _db.Table<User>().ToListAsync();\n        Users.Clear();\n        foreach(var user in list) Users.Add(user);\n    }\n}\n\n// XAML\n// <ListView ItemsSource=\"{Binding Users}\">\n//   <ListView.ItemTemplate>\n//     <DataTemplate>\n//       <TextCell Text=\"{Binding Name}\" Detail=\"{Binding Age}\" />\n//     </DataTemplate>\n//   </ListView.ItemTemplate>\n// </ListView>"
  },
  {
    "title": "SQLite Database Migrations",
    "note": "Unlike Entity Framework, sqlite-net-pcl doesn’t have built-in migrations. Schema changes must be handled manually. You can use ALTER TABLE commands or re-create tables. A common practice is versioning your database and applying incremental updates on app startup.",
    "code": "// Example: Add new column\n// ALTER TABLE User ADD COLUMN Email TEXT;\n\n// After updating model class with Email property\n// Call db.CreateTable<User>() again to ensure schema consistency"
  }
],
sqlserver:[
  {
    "title": "SQL Server HOME",
    "note": "Microsoft SQL Server is a relational database management system (RDBMS) designed for enterprise-scale applications. It supports T-SQL (Transact-SQL) for queries, stored procedures, and triggers. SQL Server integrates well with .NET applications and provides high performance, security, and reliability for web, desktop, and enterprise apps.",
    "code": "-- Official Website: https://www.microsoft.com/en-us/sql-server\n-- Documentation: https://learn.microsoft.com/en-us/sql/sql-server/\n-- SQL Server Express for free: https://www.microsoft.com/en-us/sql-server/sql-server-downloads"
  },
  {
    "title": "SQL Server Database Creation",
    "note": "You can create databases using SQL Server Management Studio (SSMS) or via T-SQL commands. A database is a container for tables, views, stored procedures, and more.",
    "code": "CREATE DATABASE MyDatabase;\nGO\n\nUSE MyDatabase;\nGO"
  },
  {
    "title": "SQL Server Tables",
    "note": "Tables store structured data in rows and columns. Define columns with data types, primary keys, constraints, and defaults. SQL Server supports INT, BIGINT, VARCHAR, NVARCHAR, DATETIME, BIT, and more.",
    "code": "CREATE TABLE Users (\n    Id INT IDENTITY(1,1) PRIMARY KEY,\n    Name NVARCHAR(100) NOT NULL,\n    Age INT,\n    Email NVARCHAR(255) UNIQUE\n);\nGO"
  },
  {
    "title": "SQL Server Insert Data",
    "note": "Insert data into tables using the INSERT INTO statement. You can insert single or multiple rows at a time.",
    "code": "INSERT INTO Users (Name, Age, Email)\nVALUES ('Alice', 25, 'alice@example.com');\n\nINSERT INTO Users (Name, Age, Email)\nVALUES ('Bob', 30, 'bob@example.com'), ('Charlie', 22, 'charlie@example.com');"
  },
  {
    "title": "SQL Server Read Data",
    "note": "Retrieve data using SELECT statements. Use WHERE for filtering, ORDER BY for sorting, and TOP to limit results.",
    "code": "-- Get all users\nSELECT * FROM Users;\n\n-- Get users older than 25\nSELECT * FROM Users WHERE Age > 25;\n\n-- Get top 2 youngest users\nSELECT TOP 2 * FROM Users ORDER BY Age ASC;"
  },
  {
    "title": "SQL Server Update Data",
    "note": "Update existing records using the UPDATE statement with a WHERE clause. Without WHERE, all rows are updated.",
    "code": "UPDATE Users\nSET Age = 26\nWHERE Name = 'Alice';\n\n-- Update multiple fields\nUPDATE Users\nSET Age = 31, Email = 'bob_new@example.com'\nWHERE Name = 'Bob';"
  },
  {
    "title": "SQL Server Delete Data",
    "note": "Delete rows using DELETE FROM with a WHERE clause. Without WHERE, all rows are deleted.",
    "code": "DELETE FROM Users\nWHERE Name = 'Charlie';\n\n-- Delete all users\n-- DELETE FROM Users;"
  },
  {
    "title": "SQL Server Joins",
    "note": "SQL Server supports INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL OUTER JOIN to combine rows from multiple tables based on related columns.",
    "code": "CREATE TABLE Orders (\n    Id INT IDENTITY(1,1) PRIMARY KEY,\n    UserId INT,\n    Product NVARCHAR(100),\n    FOREIGN KEY (UserId) REFERENCES Users(Id)\n);\n\n-- Inner join example\nSELECT Users.Name, Orders.Product\nFROM Users\nINNER JOIN Orders ON Users.Id = Orders.UserId;"
  },
  {
    "title": "SQL Server Aggregate Functions",
    "note": "Aggregate functions summarize data. Common functions: COUNT, SUM, AVG, MIN, MAX. Combine with GROUP BY for grouped summaries.",
    "code": "-- Count total users\nSELECT COUNT(*) AS TotalUsers FROM Users;\n\n-- Average age\nSELECT AVG(Age) AS AverageAge FROM Users;\n\n-- Count users by age\nSELECT Age, COUNT(*) AS UsersCount\nFROM Users\nGROUP BY Age;"
  },
  {
    "title": "SQL Server Stored Procedures",
    "note": "Stored procedures are reusable T-SQL code blocks that can accept parameters, perform logic, and return results. They improve performance and maintainability.",
    "code": "CREATE PROCEDURE GetUserByName\n    @Name NVARCHAR(100)\nAS\nBEGIN\n    SELECT * FROM Users WHERE Name = @Name;\nEND;\nGO\n\n-- Execute stored procedure\nEXEC GetUserByName @Name = 'Alice';"
  },
  {
    "title": "SQL Server Views",
    "note": "Views are virtual tables representing the result of a query. They simplify complex queries and improve security by restricting access to specific columns or rows.",
    "code": "CREATE VIEW UserAges AS\nSELECT Name, Age FROM Users;\nGO\n\n-- Query the view\nSELECT * FROM UserAges;"
  },
  {
    "title": "SQL Server Indexes",
    "note": "Indexes improve query performance. Primary keys automatically create clustered indexes. You can create non-clustered indexes for frequently queried columns.",
    "code": "CREATE NONCLUSTERED INDEX idx_users_age ON Users(Age);\nGO"
  },
  {
    "title": "SQL Server Transactions",
    "note": "Transactions allow multiple operations to be executed as a single unit. Use BEGIN TRANSACTION, COMMIT, and ROLLBACK for consistency and rollback on errors.",
    "code": "BEGIN TRANSACTION;\n\nUPDATE Users SET Age = 27 WHERE Name = 'Alice';\nUPDATE Users SET Age = 32 WHERE Name = 'Bob';\n\n-- Commit changes\nCOMMIT;\n\n-- If error occurs, rollback\n-- ROLLBACK;"
  },
  {
    "title": "SQL Server Connection with C# (.NET)",
    "note": "Use SqlConnection, SqlCommand, and SqlDataReader to connect to SQL Server from C# applications. Supports async operations for better performance in apps.",
    "code": "using System;\nusing System.Data.SqlClient;\n\nstring connectionString = \"Server=.;Database=MyDatabase;Trusted_Connection=True;\";\nusing (SqlConnection conn = new SqlConnection(connectionString)) {\n    conn.Open();\n    string query = \"SELECT Name, Age FROM Users\";\n    SqlCommand cmd = new SqlCommand(query, conn);\n    SqlDataReader reader = cmd.ExecuteReader();\n    while(reader.Read()) {\n        Console.WriteLine($\"Name: {reader[\"Name\"]}, Age: {reader[\"Age\"]}\");\n    }\n}"
  }
],
oracle:[
  {
    "title": "Oracle HOME",
    "note": "Oracle Database is a powerful, enterprise-level relational database management system (RDBMS) developed by Oracle Corporation. It supports SQL, PL/SQL (procedural language), and provides features like high availability, scalability, and advanced security. Widely used for large enterprise applications, finance, and data warehousing.",
    "code": "-- Official Website: https://www.oracle.com/database/\n-- Documentation: https://docs.oracle.com/en/database/\n-- Oracle Live SQL (Try Online): https://livesql.oracle.com/"
  },
  {
    "title": "Oracle Database Creation",
    "note": "Oracle databases are created using Oracle Database software and managed through SQL*Plus, SQL Developer, or Enterprise Manager. Each database contains schemas, tables, views, and objects.",
    "code": "-- Creating a new user/schema\nCREATE USER myuser IDENTIFIED BY mypassword;\nGRANT CONNECT, RESOURCE TO myuser;\n\n-- Connect to the user\nCONNECT myuser/mypassword;"
  },
  {
    "title": "Oracle Tables",
    "note": "Tables store structured data in rows and columns. Each column has a data type (VARCHAR2, NUMBER, DATE, CHAR, CLOB, etc.). You can define primary keys, unique constraints, and defaults.",
    "code": "CREATE TABLE Employees (\n    EmployeeID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n    Name VARCHAR2(100) NOT NULL,\n    Age NUMBER,\n    Email VARCHAR2(255) UNIQUE\n);"
  },
  {
    "title": "Oracle Insert Data",
    "note": "Insert rows into tables using INSERT INTO. You can insert single or multiple rows. The RETURNING clause can retrieve generated IDs.",
    "code": "INSERT INTO Employees (Name, Age, Email) VALUES ('Alice', 25, 'alice@example.com');\n\nINSERT ALL\n  INTO Employees (Name, Age, Email) VALUES ('Bob', 30, 'bob@example.com')\n  INTO Employees (Name, Age, Email) VALUES ('Charlie', 22, 'charlie@example.com')\nSELECT * FROM dual;"
  },
  {
    "title": "Oracle Read Data",
    "note": "Retrieve data using SELECT statements. Use WHERE for filtering, ORDER BY for sorting, and ROWNUM or FETCH for limiting results.",
    "code": "-- Get all employees\nSELECT * FROM Employees;\n\n-- Get employees older than 25\nSELECT * FROM Employees WHERE Age > 25;\n\n-- Get top 2 youngest employees\nSELECT * FROM Employees ORDER BY Age ASC FETCH FIRST 2 ROWS ONLY;"
  },
  {
    "title": "Oracle Update Data",
    "note": "Update existing rows using the UPDATE statement. Always use WHERE to avoid updating all rows.",
    "code": "UPDATE Employees SET Age = 26 WHERE Name = 'Alice';\n\nUPDATE Employees SET Age = 31, Email = 'bob_new@example.com' WHERE Name = 'Bob';"
  },
  {
    "title": "Oracle Delete Data",
    "note": "Delete rows using DELETE FROM with WHERE. Use TRUNCATE to remove all rows quickly, but TRUNCATE cannot be rolled back in a transaction.",
    "code": "DELETE FROM Employees WHERE Name = 'Charlie';\n\n-- Delete all rows (careful!)\n-- TRUNCATE TABLE Employees;"
  },
  {
    "title": "Oracle Joins",
    "note": "Oracle supports INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN, and CROSS JOIN. Joins combine data from multiple tables based on related columns.",
    "code": "CREATE TABLE Orders (\n    OrderID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n    EmployeeID NUMBER REFERENCES Employees(EmployeeID),\n    Product VARCHAR2(100)\n);\n\n-- Inner join example\nSELECT e.Name, o.Product\nFROM Employees e\nINNER JOIN Orders o ON e.EmployeeID = o.EmployeeID;"
  },
  {
    "title": "Oracle Aggregate Functions",
    "note": "Aggregate functions summarize data. Common functions: COUNT, SUM, AVG, MIN, MAX. Use GROUP BY for grouping results and HAVING for filtering groups.",
    "code": "-- Count total employees\nSELECT COUNT(*) AS TotalEmployees FROM Employees;\n\n-- Average age\nSELECT AVG(Age) AS AverageAge FROM Employees;\n\n-- Count employees by age\nSELECT Age, COUNT(*) AS EmployeeCount FROM Employees GROUP BY Age;"
  },
  {
    "title": "Oracle PL/SQL Procedures",
    "note": "PL/SQL allows procedural programming in Oracle. Stored procedures encapsulate logic and can accept parameters. Improves maintainability and performance.",
    "code": "CREATE OR REPLACE PROCEDURE GetEmployeeByName(p_name IN VARCHAR2) IS\nBEGIN\n    FOR r IN (SELECT * FROM Employees WHERE Name = p_name) LOOP\n        DBMS_OUTPUT.PUT_LINE(r.Name || ' - ' || r.Age);\n    END LOOP;\nEND;\n/\n\n-- Execute procedure\nBEGIN\n    GetEmployeeByName('Alice');\nEND;\n/"
  },
  {
    "title": "Oracle Functions",
    "note": "PL/SQL functions return a value and can be used in SQL queries. They can encapsulate calculations or transformations.",
    "code": "CREATE OR REPLACE FUNCTION GetEmployeeAge(p_name IN VARCHAR2) RETURN NUMBER IS\n    v_age NUMBER;\nBEGIN\n    SELECT Age INTO v_age FROM Employees WHERE Name = p_name;\n    RETURN v_age;\nEND;\n/\n\n-- Call the function\nSELECT GetEmployeeAge('Alice') FROM dual;"
  },
  {
    "title": "Oracle Views",
    "note": "Views are virtual tables representing the result of a query. They simplify complex queries and restrict access to specific columns or rows.",
    "code": "CREATE OR REPLACE VIEW EmployeeNames AS\nSELECT Name, Age FROM Employees;\n\n-- Query the view\nSELECT * FROM EmployeeNames;"
  },
  {
    "title": "Oracle Indexes",
    "note": "Indexes improve query performance on large tables. Oracle supports unique, composite, bitmap, and function-based indexes.",
    "code": "CREATE INDEX idx_employees_age ON Employees(Age);"
  },
  {
    "title": "Oracle Transactions",
    "note": "Oracle supports transactions with COMMIT, ROLLBACK, and SAVEPOINT. Transactions ensure data consistency and can be rolled back in case of errors.",
    "code": "BEGIN\n    UPDATE Employees SET Age = 27 WHERE Name = 'Alice';\n    UPDATE Employees SET Age = 32 WHERE Name = 'Bob';\n    -- Commit changes\n    COMMIT;\n    -- Rollback if error occurs\n    -- ROLLBACK;\nEND;"
  },
  {
    "title": "Oracle Connection with Java (JDBC)",
    "note": "Oracle can be connected to Java applications via JDBC. Use DriverManager, Connection, Statement, and ResultSet objects for database operations.",
    "code": "import java.sql.*;\n\npublic class OracleDemo {\n    public static void main(String[] args) {\n        try {\n            Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            Connection conn = DriverManager.getConnection(\n                \"jdbc:oracle:thin:@localhost:1521:XE\", \"myuser\", \"mypassword\");\n\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"SELECT Name, Age FROM Employees\");\n            while(rs.next()) {\n                System.out.println(\"Name: \" + rs.getString(\"Name\") + \", Age: \" + rs.getInt(\"Age\"));\n            }\n\n            rs.close();\n            stmt.close();\n            conn.close();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  }
],
cassandra:
  [
  {
    "title": "Cassandra HOME",
    "note": "Apache Cassandra is a highly scalable, distributed NoSQL database designed for handling large amounts of data across many servers with no single point of failure. It is optimized for high availability, fault tolerance, and linear scalability. It uses a peer-to-peer architecture and a column-family data model.",
    "code": "-- Official Website: https://cassandra.apache.org/\n-- Documentation: https://cassandra.apache.org/doc/latest/\n-- Try Online: https://www.tutorialspoint.com/execute_cassandra_online.php"
  },
  {
    "title": "Cassandra Key Concepts",
    "note": "Cassandra is built around key concepts: Keyspaces (like databases), Tables (column families), Partitions (data distribution), Rows, Columns, and Clusters. Data is denormalized for performance. It uses CQL (Cassandra Query Language) which is similar to SQL but adapted for Cassandra's model.",
    "code": "-- Example keyspace\nCREATE KEYSPACE mykeyspace WITH replication = {\n    'class': 'SimpleStrategy', 'replication_factor': 3\n};"
  },
  {
    "title": "Creating Tables in Cassandra",
    "note": "Tables in Cassandra are defined within keyspaces. Each table requires a PRIMARY KEY, which can be composite (partition key + clustering columns). Columns can have data types like text, int, uuid, timestamp, boolean.",
    "code": "CREATE TABLE mykeyspace.users (\n    user_id UUID PRIMARY KEY,\n    name text,\n    age int,\n    email text\n);"
  },
  {
    "title": "Insert Data into Cassandra",
    "note": "Insert data using the INSERT statement. Unlike SQL, Cassandra inserts are idempotent (repeated inserts overwrite existing data for the same primary key).",
    "code": "INSERT INTO mykeyspace.users (user_id, name, age, email) VALUES (uuid(), 'Alice', 25, 'alice@example.com');\nINSERT INTO mykeyspace.users (user_id, name, age, email) VALUES (uuid(), 'Bob', 30, 'bob@example.com');"
  },
  {
    "title": "Read Data from Cassandra",
    "note": "Query data using SELECT. You can filter rows by primary key, clustering columns, and indexed columns. Secondary indexes can be used but are less efficient than primary key queries.",
    "code": "SELECT * FROM mykeyspace.users;\nSELECT name, email FROM mykeyspace.users WHERE user_id = <uuid>;"
  },
  {
    "title": "Update Data in Cassandra",
    "note": "Update existing rows using UPDATE. Specify the primary key to identify the row. Cassandra treats updates as inserts internally.",
    "code": "UPDATE mykeyspace.users SET age = 26 WHERE user_id = <uuid>;\nUPDATE mykeyspace.users SET email = 'alice_new@example.com' WHERE user_id = <uuid>;"
  },
  {
    "title": "Delete Data in Cassandra",
    "note": "Delete rows or columns using DELETE. Always use the primary key or clustering columns. You can also delete an entire table or keyspace.",
    "code": "DELETE FROM mykeyspace.users WHERE user_id = <uuid>;\n-- Drop table\nDROP TABLE mykeyspace.users;\n-- Drop keyspace\nDROP KEYSPACE mykeyspace;"
  },
  {
    "title": "Cassandra Primary & Composite Keys",
    "note": "Primary keys are composed of partition keys and clustering columns. Partition keys determine node placement. Clustering columns define row order within a partition.",
    "code": "CREATE TABLE mykeyspace.orders (\n    order_id UUID,\n    user_id UUID,\n    product text,\n    order_date timestamp,\n    PRIMARY KEY (user_id, order_date)\n);"
  },
  {
    "title": "Cassandra Indexes",
    "note": "Cassandra supports primary key-based queries natively. Secondary indexes allow querying non-primary key columns but can be inefficient on large datasets.",
    "code": "CREATE INDEX idx_users_email ON mykeyspace.users(email);"
  },
  {
    "title": "Cassandra Collections",
    "note": "Cassandra supports collection data types: LIST, SET, MAP. Useful for storing multiple values in a single column.",
    "code": "CREATE TABLE mykeyspace.students (\n    student_id UUID PRIMARY KEY,\n    name text,\n    subjects list<text>,\n    scores map<text,int>\n);\n\nINSERT INTO mykeyspace.students (student_id, name, subjects, scores) VALUES (\n    uuid(), 'Alice', ['Math', 'Physics'], {'Math':90,'Physics':85}\n);"
  },
  {
    "title": "Cassandra TTL & Expiring Data",
    "note": "Cassandra supports automatic data expiration using TTL (Time To Live). Rows or individual columns can expire after a defined period.",
    "code": "INSERT INTO mykeyspace.users (user_id, name, age) VALUES (uuid(), 'TempUser', 20) USING TTL 3600;\n-- Row expires after 1 hour (3600 seconds)"
  },
  {
    "title": "Cassandra Batch Operations",
    "note": "Batches allow grouping multiple statements for atomic execution on the same partition key. Avoid large batches; they can harm performance.",
    "code": "BEGIN BATCH\n    INSERT INTO mykeyspace.users (user_id, name, age) VALUES (uuid(), 'Charlie', 22);\n    INSERT INTO mykeyspace.users (user_id, name, age) VALUES (uuid(), 'David', 28);\nAPPLY BATCH;"
  },
  {
    "title": "Cassandra Clustering & Ordering",
    "note": "Clustering columns determine the order of rows within a partition. You can query and sort efficiently using clustering keys.",
    "code": "SELECT * FROM mykeyspace.orders WHERE user_id = <uuid> ORDER BY order_date DESC;"
  },
  {
    "title": "Cassandra Replication Strategies",
    "note": "Cassandra supports replication strategies for fault tolerance. SimpleStrategy is used for single data centers, while NetworkTopologyStrategy is recommended for multiple data centers.",
    "code": "CREATE KEYSPACE ecommerce WITH replication = {\n  'class': 'NetworkTopologyStrategy',\n  'datacenter1': 3,\n  'datacenter2': 2\n};"
  },
  {
    "title": "Cassandra Consistency Levels",
    "note": "Cassandra allows tuning consistency levels per query: ONE, QUORUM, ALL, LOCAL_QUORUM, EACH_QUORUM. This provides trade-offs between availability and accuracy.",
    "code": "CONSISTENCY QUORUM;\nSELECT * FROM mykeyspace.users WHERE user_id = <uuid>;"
  },
  {
    "title": "Cassandra Drivers",
    "note": "Cassandra can be accessed from various programming languages using official drivers: Java, Python, Node.js, C#, Go. The DataStax drivers are most widely used.",
    "code": "-- Python Example\nfrom cassandra.cluster import Cluster\ncluster = Cluster(['127.0.0.1'])\nsession = cluster.connect('mykeyspace')\nrows = session.execute('SELECT name, age FROM users')\nfor row in rows:\n    print(row.name, row.age)"
  },
  {
    "title": "Cassandra Monitoring & Tools",
    "note": "Cassandra provides monitoring via JMX (Java Management Extensions). Tools like Nodetool, Prometheus, and Grafana help in cluster health tracking.",
    "code": "-- Nodetool example\nnodetool status\nnodetool describecluster\nnodetool tpstats"
  },
  {
    "title": "Cassandra Connecting with Java (DataStax Java Driver)",
    "note": "Use the DataStax Java driver to connect Cassandra to Java applications. Perform queries using Session and PreparedStatement objects.",
    "code": "import com.datastax.oss.driver.api.core.CqlSession;\nimport com.datastax.oss.driver.api.core.cql.ResultSet;\nimport com.datastax.oss.driver.api.core.cql.Row;\nimport java.net.InetSocketAddress;\n\npublic class CassandraDemo {\n    public static void main(String[] args) {\n        try (CqlSession session = CqlSession.builder()\n            .addContactPoint(new InetSocketAddress(\"127.0.0.1\", 9042))\n            .withKeyspace(\"mykeyspace\")\n            .withLocalDatacenter(\"datacenter1\")\n            .build()) {\n\n            ResultSet rs = session.execute(\"SELECT name, age FROM users\");\n            for (Row row : rs) {\n                System.out.println(\"Name: \" + row.getString(\"name\") + \", Age: \" + row.getInt(\"age\"));\n            }\n        }\n    }\n}"
  }
],
firebase:
[
  {
    "title": "Firebase HOME",
    "note": "Firebase is a Backend-as-a-Service (BaaS) platform developed by Google that provides developers with a suite of cloud-based tools for building web and mobile applications. It includes real-time databases, authentication, cloud storage, serverless functions, analytics, push notifications, hosting, and more. Firebase accelerates development by eliminating backend management tasks such as infrastructure scaling, authentication handling, and file storage. It is highly integrated with Google Cloud and supports web, Android, iOS, and Unity.",
    "code": "// Official Website: https://firebase.google.com/\n// Documentation: https://firebase.google.com/docs\n// Try Online: https://console.firebase.google.com/"
  },
  {
    "title": "Firebase Setup",
    "note": "To get started with Firebase, create a project in the Firebase Console. Add your app (Web, Android, or iOS) to the project. Then, integrate the Firebase SDK. Each app uses a configuration object (Web) or a google-services.json / GoogleService-Info.plist file (Android/iOS). You can enable specific Firebase services such as Authentication, Firestore, Storage, or Functions as needed.",
    "code": "// For Web: Include Firebase SDK in HTML\n<script src=\"https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js\"></script>\n<script src=\"https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js\"></script>\n<script>\n  const firebaseConfig = {\n    apiKey: \"YOUR_API_KEY\",\n    authDomain: \"YOUR_PROJECT_ID.firebaseapp.com\",\n    projectId: \"YOUR_PROJECT_ID\",\n    storageBucket: \"YOUR_PROJECT_ID.appspot.com\",\n    messagingSenderId: \"SENDER_ID\",\n    appId: \"APP_ID\"\n  };\n  const app = firebase.initializeApp(firebaseConfig);\n</script>"
  },
  {
    "title": "Firebase Authentication",
    "note": "Firebase Authentication provides secure and easy-to-use methods for signing in users. It supports email/password, phone number authentication, and social providers such as Google, Facebook, Twitter, and GitHub. Firebase also provides Anonymous Authentication for guest users. Authentication state can be tracked in real-time, making it easy to implement user sessions.",
    "code": "import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged } from 'firebase/auth';\n\nconst auth = getAuth();\n\n// Sign up\ncreateUserWithEmailAndPassword(auth, 'alice@example.com', 'password123')\n  .then(userCredential => console.log(userCredential.user))\n  .catch(error => console.error(error));\n\n// Sign in\nsignInWithEmailAndPassword(auth, 'alice@example.com', 'password123')\n  .then(userCredential => console.log(userCredential.user))\n  .catch(error => console.error(error));\n\n// Observe auth state\nonAuthStateChanged(auth, (user) => {\n  if (user) console.log('User logged in:', user);\n  else console.log('User logged out');\n});"
  },
  {
    "title": "Firebase Firestore",
    "note": "Cloud Firestore is Firebase’s modern, scalable NoSQL document database. Data is organized into collections and documents. Documents are JSON-like objects with fields (key-value pairs). Firestore supports advanced querying with filters, compound queries, ordering, and real-time listeners. It provides offline persistence, so apps remain functional without internet.",
    "code": "import { getFirestore, collection, addDoc, getDocs, onSnapshot } from 'firebase/firestore';\n\nconst db = getFirestore();\n\n// Add a document\nawait addDoc(collection(db, 'users'), { name: 'Alice', age: 25 });\n\n// Read documents once\nconst querySnapshot = await getDocs(collection(db, 'users'));\nquerySnapshot.forEach(doc => console.log(doc.id, '=>', doc.data()));\n\n// Real-time listener\nonSnapshot(collection(db, 'users'), (snapshot) => {\n  snapshot.docs.forEach(doc => console.log(doc.data()));\n});"
  },
  {
    "title": "Firebase Realtime Database",
    "note": "The Realtime Database is Firebase’s original NoSQL database. It stores data as a large JSON tree and syncs data in real-time across all connected clients. It is great for chat apps, live feeds, or collaborative tools. Unlike Firestore, it is optimized for simple hierarchical data but has limited querying capabilities.",
    "code": "import { getDatabase, ref, set, onValue } from 'firebase/database';\n\nconst db = getDatabase();\n\n// Write data\nset(ref(db, 'users/1'), { name: 'Bob', age: 30 });\n\n// Read data in real-time\nonValue(ref(db, 'users/1'), (snapshot) => {\n  console.log(snapshot.val());\n});"
  },
  {
    "title": "Firebase Cloud Storage",
    "note": "Cloud Storage lets you store and serve large user-generated files such as images, videos, and documents. It integrates with Firebase Authentication for security and provides fine-grained access control with Security Rules. Files are stored in Google Cloud Storage buckets.",
    "code": "import { getStorage, ref, uploadBytes, getDownloadURL } from 'firebase/storage';\n\nconst storage = getStorage();\nconst fileRef = ref(storage, 'images/myPhoto.jpg');\n\n// Upload file\nawait uploadBytes(fileRef, fileInput.files[0]);\n\n// Get download URL\nconst url = await getDownloadURL(fileRef);\nconsole.log('File URL:', url);"
  },
  {
    "title": "Firebase Cloud Functions",
    "note": "Cloud Functions lets you run server-side code in response to Firebase events or HTTP requests. Functions are written in Node.js and deployed to Firebase's serverless infrastructure. They automatically scale and support triggers for Firestore, Realtime Database, Authentication, Analytics, and Pub/Sub.",
    "code": "// index.js\nconst functions = require('firebase-functions');\nconst admin = require('firebase-admin');\nadmin.initializeApp();\n\n// HTTP function\nexports.helloWorld = functions.https.onRequest((req, res) => {\n  res.send('Hello from Firebase Functions!');\n});\n\n// Firestore trigger\nexports.onUserCreate = functions.firestore.document('users/{userId}').onCreate((snap, context) => {\n  console.log('New user created:', snap.data());\n});"
  },
  {
    "title": "Firebase Hosting",
    "note": "Firebase Hosting provides fast and secure web hosting for web apps, static content, and microservices. It features global CDN, automatic SSL certificates, and custom domain support. It works seamlessly with SPAs and PWAs.",
    "code": "// Install Firebase CLI: npm install -g firebase-tools\n// Login: firebase login\n// Initialize project: firebase init hosting\n// Deploy: firebase deploy\n\n// Your app will be live at https://YOUR_PROJECT_ID.web.app"
  },
  {
    "title": "Firebase Push Notifications (Cloud Messaging)",
    "note": "Firebase Cloud Messaging (FCM) enables sending push notifications to Android, iOS, and web apps. You can target individual devices, groups, or topics. Notifications can be triggered manually, from backend servers, or Cloud Functions.",
    "code": "import { getMessaging, getToken, onMessage } from 'firebase/messaging';\n\nconst messaging = getMessaging();\n\n// Request permission & get token\nconst token = await getToken(messaging, { vapidKey: 'YOUR_VAPID_KEY' });\nconsole.log('FCM Token:', token);\n\n// Listen for foreground messages\nonMessage(messaging, (payload) => {\n  console.log('Message received:', payload);\n});"
  },
  {
    "title": "Firebase Analytics",
    "note": "Firebase Analytics (Google Analytics for Firebase) tracks user engagement, events, and demographics. It integrates with other Firebase services for better insights. You can log custom events and measure conversions. Data is available in Firebase Console and Google BigQuery.",
    "code": "import { getAnalytics, logEvent } from 'firebase/analytics';\n\nconst analytics = getAnalytics();\n\nlogEvent(analytics, 'notification_received');\nlogEvent(analytics, 'purchase', { item: 'Book', price: 20 });"
  },
  {
    "title": "Firebase Remote Config",
    "note": "Remote Config lets you change app behavior and appearance without publishing a new app version. You can define parameters in Firebase Console and fetch them in the app. Useful for A/B testing, feature toggles, and dynamic UI updates.",
    "code": "import { getRemoteConfig, getValue } from 'firebase/remote-config';\n\nconst remoteConfig = getRemoteConfig();\nremoteConfig.settings.minimumFetchIntervalMillis = 3600000;\n\nconst welcomeMessage = getValue(remoteConfig, 'welcome_message').asString();\nconsole.log('Welcome Message:', welcomeMessage);"
  },
  {
    "title": "Firebase Crashlytics",
    "note": "Crashlytics helps monitor app crashes and stability in real-time. It collects stack traces, device information, and user details for debugging. Developers can prioritize and fix issues quickly.",
    "code": "// For Android/iOS setup, add Crashlytics SDK\n// Example: FirebaseCrashlytics.getInstance().log(\"App started\");"
  },
  {
    "title": "Firebase Performance Monitoring",
    "note": "Performance Monitoring helps you track app performance metrics such as startup time, HTTP request latency, and screen rendering speed. Data is sent to Firebase Console for analysis.",
    "code": "// For Android: implementation 'com.google.firebase:firebase-perf'\n// For iOS: pod 'Firebase/Performance'\n// Example: traces and network monitoring are automatically collected."
  },
  {
    "title": "Firebase Security Rules",
    "note": "Firebase Security Rules define how your data can be accessed. They control read/write access for Firestore, Realtime Database, and Cloud Storage. Rules use an expression-based language to check authentication, roles, or custom logic.",
    "code": "// Firestore rules example\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /users/{userId} {\n      allow read, write: if request.auth != null && request.auth.uid == userId;\n    }\n  }\n}"
  },
  {
    "title": "Firebase Emulator Suite",
    "note": "The Emulator Suite lets you develop and test Firebase apps locally. It includes emulators for Authentication, Firestore, Realtime Database, Cloud Functions, Hosting, and more. This reduces costs and allows safe experimentation before deploying.",
    "code": "// Start emulator\nfirebase emulators:start"
  },
  {
    "title": "Firebase Dynamic Links",
    "note": "Dynamic Links are smart URLs that work across platforms. They survive app installation and can carry data for personalized onboarding or deep linking into specific app screens.",
    "code": "// Example: Create Dynamic Link via Console\nhttps://yourapp.page.link/?link=https://yourwebsite.com&apn=com.example.app"
  },
  {
    "title": "Firebase Extensions",
    "note": "Firebase Extensions are pre-packaged solutions that add functionality to your app. Examples include image resizing, text translation, and trigger-based email sending. They are easy to install and configure via the Firebase Console.",
    "code": "// Example: Install Image Resize extension\nfirebase ext:install firebase/storage-resize-images"
  },
  {
    "title": "Firebase A/B Testing",
    "note": "Firebase A/B Testing integrates with Remote Config and Analytics to test different app experiences. It allows you to run experiments and roll out the best-performing version to all users.",
    "code": "// Example: Use Remote Config parameters to create experiment groups"
  }
],
redis:
  [
  {
    "title": "Redis HOME",
    "note": "Redis is an open-source, in-memory data structure store used as a database, cache, and message broker. It supports multiple data types such as strings, hashes, lists, sets, sorted sets, bitmaps, hyperloglogs, and geospatial indexes. Redis is known for ultra-low latency, atomic operations, high performance, and persistence options (RDB snapshots and AOF logs). It is widely used for caching, session management, real-time analytics, leaderboards, rate-limiting, and pub/sub messaging.",
    "code": "// Official Website: https://redis.io/\n// Documentation: https://redis.io/documentation\n// Try Online: https://try.redis.io/"
  },
  {
    "title": "Redis Installation & Setup",
    "note": "Redis can be installed on Linux, macOS, and Windows. You can run Redis locally as a server for development or use cloud-hosted solutions such as AWS ElastiCache, Azure Redis Cache, or Redis Enterprise. After installation, verify Redis is running using redis-cli.",
    "code": "# Linux: sudo apt install redis-server\n# Start Redis server: redis-server\n# Test connection: redis-cli ping\n# Should respond: PONG\n\n# macOS: brew install redis\n# Start service: brew services start redis\n# Windows: Use Redis on WSL or download from Microsoft Open Tech."
  },
  {
    "title": "Redis String Operations",
    "note": "Strings are the simplest Redis data type. You can set, get, increment, decrement, append, and manage string values efficiently. Strings are commonly used for caching key-value pairs, counters, tokens, or configuration flags.",
    "code": "SET name \"Alice\"\nGET name\nINCR counter\nDECR counter\nAPPEND name \" Smith\"\nDEL name\nMSET key1 val1 key2 val2\nMGET key1 key2"
  },
  {
    "title": "Redis Hashes",
    "note": "Hashes store key-value pairs inside a single Redis key. Ideal for representing objects, user profiles, or records with multiple fields. You can set individual fields, increment numeric values, and fetch all fields.",
    "code": "HSET user:1 name \"Alice\" age 25 email \"alice@example.com\"\nHGET user:1 name\nHGETALL user:1\nHINCRBY user:1 age 1\nHMSET user:2 name \"Bob\" age 30\nHMGET user:2 name age"
  },
  {
    "title": "Redis Lists",
    "note": "Lists are ordered collections of strings. Support push/pop operations from both ends (LPUSH, RPUSH, LPOP, RPOP). They are useful for queues, task scheduling, timelines, and messaging.",
    "code": "LPUSH mylist \"A\" \"B\" \"C\"\nRPUSH mylist \"D\"\nLRANGE mylist 0 -1\nLPOP mylist\nRPOP mylist\nLLEN mylist\nLREM mylist 1 \"B\""
  },
  {
    "title": "Redis Sets",
    "note": "Sets are unordered collections of unique strings. Useful for tags, unique items, and membership checks. Supports set operations such as union, intersection, and difference.",
    "code": "SADD myset \"A\" \"B\" \"C\"\nSREM myset \"B\"\nSMEMBERS myset\nSISMEMBER myset \"A\"\nSUNION set1 set2\nSINTER set1 set2\nSDIFF set1 set2"
  },
  {
    "title": "Redis Sorted Sets",
    "note": "Sorted sets store unique strings with a numeric score. Elements are automatically sorted by score. Ideal for leaderboards, ranking systems, priority queues, and time-based scoring.",
    "code": "ZADD leaderboard 100 \"Alice\" 200 \"Bob\" 150 \"Charlie\"\nZRANGE leaderboard 0 -1 WITHSCORES\nZREVRANGE leaderboard 0 -1 WITHSCORES\nZINCRBY leaderboard 50 \"Alice\"\nZRANK leaderboard \"Bob\""
  },
  {
    "title": "Redis Expiration & TTL",
    "note": "Keys in Redis can have expiration times, which is essential for caching, session management, and temporary data. Commands like TTL, EXPIRE, EXPIREAT, and PERSIST control key lifetimes.",
    "code": "SET session:1 \"data\" EX 3600  # 1 hour expiration\nTTL session:1\nPERSIST session:1  # Remove expiration\nEXPIRE session:2 1800  # Set TTL in seconds"
  },
  {
    "title": "Redis Pub/Sub",
    "note": "Redis supports lightweight publish/subscribe messaging. Clients can subscribe to channels and receive messages instantly. Useful for chat systems, notifications, and event broadcasting.",
    "code": "SUBSCRIBE mychannel\nPUBLISH mychannel \"Hello, subscribers!\"\nUNSUBSCRIBE mychannel"
  },
  {
    "title": "Redis Transactions",
    "note": "Redis transactions allow grouping multiple commands to execute atomically using MULTI, EXEC, DISCARD, and WATCH. Useful for safe updates and concurrency control.",
    "code": "MULTI\nSET key1 \"A\"\nSET key2 \"B\"\nEXEC\nWATCH key1 key2\nMULTI\nINCR key1\nEXEC"
  },
  {
    "title": "Redis Lua Scripting",
    "note": "Redis allows server-side scripting using Lua for atomic multi-step operations. Lua scripts execute as a single command and can access keys and arguments.",
    "code": "EVAL \"return redis.call('SET', KEYS[1], ARGV[1])\" 1 mykey 'value'\nEVAL \"return redis.call('INCRBY', KEYS[1], ARGV[1])\" 1 counter 10"
  },
  {
    "title": "Redis Clustering & High Availability",
    "note": "Redis supports clustering to partition data across multiple nodes for horizontal scaling. Redis Sentinel provides high availability, monitoring, automatic failover, and notification.",
    "code": "# Start Redis Sentinel: redis-sentinel sentinel.conf\n# Redis Cluster setup requires multiple nodes and redis-cli --cluster create"
  },
  {
    "title": "Redis Modules",
    "note": "Redis modules extend Redis functionality with advanced data types and features. Popular modules include RedisJSON, RediSearch, RedisGraph, RedisBloom, RedisTimeSeries, and RedisAI.",
    "code": "# Example: RedisJSON commands\nJSON.SET user:1 $ '{\"name\":\"Alice\",\"age\":25}'\nJSON.GET user:1 $"
  },
  {
    "title": "Redis Monitoring & Stats",
    "note": "Redis provides commands to monitor performance, memory usage, and key metrics. Commands include INFO, MONITOR, CLIENT LIST, MEMORY USAGE, and SLOWLOG.",
    "code": "INFO\nMONITOR\nCLIENT LIST\nMEMORY USAGE key1\nSLOWLOG GET 10"
  },
  {
    "title": "Redis Security & Access Control",
    "note": "Redis supports password authentication, SSL/TLS encryption, and Access Control Lists (ACLs) to manage permissions per user and command.",
    "code": "# Set password in redis.conf: requirepass yourpassword\n# ACL Example: ACL SETUSER alice on >password +get +set"
  },
  {
    "title": "Redis Backup & Persistence",
    "note": "Redis supports persistence via RDB snapshots and AOF (Append Only File). RDB provides point-in-time snapshots, AOF logs every write command for durability. Both can be combined for safety and recovery.",
    "code": "# RDB save schedule: save 900 1\n# Enable AOF: appendonly yes\n# Redis can restore automatically from RDB or AOF on startup"
  },
  {
    "title": "Redis Client Example (Node.js)",
    "note": "Redis has clients for multiple programming languages. Node.js example using the official 'redis' package.",
    "code": "const redis = require('redis');\nconst client = redis.createClient();\n\nclient.on('error', (err) => console.log('Redis Client Error', err));\n\n(async () => {\n  await client.connect();\n  await client.set('name', 'Alice');\n  const value = await client.get('name');\n  console.log(value); // Alice\n  await client.quit();\n})();"
  },
  {
    "title": "Redis Client Example (Python)",
    "note": "Python example using the 'redis-py' package to connect, set, and get keys.",
    "code": "import redis\n\nr = redis.Redis(host='localhost', port=6379, db=0)\nr.set('name', 'Alice')\nprint(r.get('name').decode())  # Alice"
  },
  {
    "title": "Redis Use Cases",
    "note": "Redis is commonly used for:\n1. Caching frequently accessed data\n2. Session storage and management\n3. Real-time leaderboards and ranking systems\n4. Pub/Sub messaging and notification services\n5. Rate limiting and throttling\n6. Task queues, delayed jobs, and background processing\n7. Real-time analytics counters and event tracking\n8. Geospatial queries and location-based services\n9. Message brokering in microservices"
  }
],
  c:
 [
  {
    "title": "C HOME",
    "note": "C is a general-purpose, procedural programming language developed by Dennis Ritchie in 1972 at Bell Labs. It is widely used for system programming, embedded systems, operating systems, and high-performance applications. C provides low-level memory access and simple syntax, which makes it fast, efficient, and highly portable. It also forms the foundation for languages like C++ and C#.",
    "code": "#include <stdio.h>\n\nint main() {\n    printf(\"Welcome to C Programming!\\n\");\n    printf(\"C is powerful for system-level programming and embedded applications.\\n\");\n    return 0;\n}"
  },
  {
    "title": "C Basics",
    "note": "C is statically typed, meaning you must declare variable types explicitly. Programs are composed of functions, with execution starting from the 'main()' function. Basic data types include int, float, double, char, and void. Constants are declared using 'const'. Proper use of semicolons, braces, and indentation ensures readable code.",
    "code": "#include <stdio.h>\n\nint main() {\n    int age = 25;\n    float pi = 3.14159;\n    char grade = 'A';\n    const double e = 2.718;\n\n    printf(\"Age: %d, Pi: %.2f, Grade: %c, e: %.3f\\n\", age, pi, grade, e);\n    return 0;\n}"
  },
  {
    "title": "C Data Types",
    "note": "C provides primitive data types like int, float, double, and char, as well as derived types like arrays, pointers, structures, and unions. Enumerations (enum) allow symbolic constants. The sizeof() operator can be used to determine the memory size of a variable or type. Understanding data types is crucial for efficient memory management.",
    "code": "#include <stdio.h>\n\nint main() {\n    int num = 10;\n    float f = 3.14f;\n    double d = 3.141592;\n    char c = 'A';\n    int arr[3] = {1, 2, 3};\n\n    printf(\"Integer: %d\\n\", num);\n    printf(\"Float: %.2f, Double: %.6f\\n\", f, d);\n    printf(\"Char: %c\\n\", c);\n    printf(\"Array element arr[0]: %d\\n\", arr[0]);\n    printf(\"Size of double: %lu bytes\\n\", sizeof(d));\n    return 0;\n}"
  },
  {
    "title": "C Operators",
    "note": "C supports various operators including:\n- Arithmetic: +, -, *, /, %\n- Relational: ==, !=, >, <, >=, <=\n- Logical: &&, ||, !\n- Bitwise: &, |, ^, ~, <<, >>\n- Assignment: =, +=, -=, *=, /=\n- Ternary: ? :\nOperators are used to manipulate values, compare data, and control program logic.",
    "code": "#include <stdio.h>\n\nint main() {\n    int a = 10, b = 3;\n    printf(\"a + b = %d\\n\", a + b);\n    printf(\"a - b = %d\\n\", a - b);\n    printf(\"a * b = %d\\n\", a * b);\n    printf(\"a %% b = %d\\n\", a % b);\n\n    int max = (a > b) ? a : b;\n    printf(\"Max value using ternary operator: %d\\n\", max);\n    return 0;\n}"
  },
  {
    "title": "C Conditionals",
    "note": "Decision making in C is done using if, if-else, nested if, and switch-case statements. Curly braces {} define blocks of code. The break statement exits a switch-case, while continue skips an iteration inside loops. Proper conditional logic ensures correct program flow.",
    "code": "#include <stdio.h>\n\nint main() {\n    int age = 18;\n\n    if (age >= 18) {\n        printf(\"Adult\\n\");\n    } else if (age >= 13) {\n        printf(\"Teenager\\n\");\n    } else {\n        printf(\"Child\\n\");\n    }\n\n    switch(age) {\n        case 13: printf(\"Age 13 - Teenager\\n\"); break;\n        case 18: printf(\"Age 18 - Adult\\n\"); break;\n        default: printf(\"Other age\\n\");\n    }\n    return 0;\n}"
  },
  {
    "title": "C Loops",
    "note": "C supports for, while, and do-while loops for repeated execution. The break statement exits a loop, and continue skips the current iteration. Loops are essential for iterating over arrays, performing calculations, and automating repetitive tasks.",
    "code": "#include <stdio.h>\n\nint main() {\n    int i;\n    printf(\"For loop example:\\n\");\n    for(i = 0; i < 3; i++) printf(\"i = %d\\n\", i);\n\n    printf(\"While loop example:\\n\");\n    i = 0;\n    while(i < 3) {\n        printf(\"i = %d\\n\", i);\n        i++;\n    }\n\n    printf(\"Do-While loop example:\\n\");\n    i = 0;\n    do {\n        printf(\"i = %d\\n\", i);\n        i++;\n    } while(i < 3);\n\n    return 0;\n}"
  },
  {
    "title": "C Functions",
    "note": "Functions are reusable blocks of code designed to perform specific tasks. Syntax: return_type function_name(parameters) { body }. Functions can call themselves recursively. main() is also a function. Functions improve readability and modularity.",
    "code": "#include <stdio.h>\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint factorial(int n) {\n    if(n <= 1) return 1;\n    return n * factorial(n - 1);\n}\n\nint main() {\n    int sum = add(5, 3);\n    int fact = factorial(5);\n    printf(\"Sum: %d, Factorial: %d\\n\", sum, fact);\n    return 0;\n}"
  },
  {
    "title": "C Arrays",
    "note": "Arrays are fixed-size collections of elements of the same type. Indexing starts at 0. Multidimensional arrays allow tabular data storage. Arrays are essential for storing sequences, matrices, and buffers.",
    "code": "#include <stdio.h>\n\nint main() {\n    int numbers[3] = {10, 20, 30};\n    printf(\"First element: %d\\n\", numbers[0]);\n\n    int matrix[2][2] = {{1, 2}, {3, 4}};\n    printf(\"matrix[1][1]: %d\\n\", matrix[1][1]);\n    return 0;\n}"
  },
  {
    "title": "C Pointers",
    "note": "Pointers store memory addresses of variables. Use * to dereference and & to get the address. Pointers are crucial for dynamic memory allocation, passing arrays to functions, and implementing complex data structures. Proper pointer usage prevents memory errors.",
    "code": "#include <stdio.h>\n\nint main() {\n    int x = 10;\n    int *p = &x;\n\n    printf(\"Value of x: %d\\n\", *p);\n    printf(\"Address of x: %p\\n\", (void*)p);\n\n    int arr[3] = {1, 2, 3};\n    int *ptr = arr;\n    printf(\"Array first element via pointer: %d\\n\", *ptr);\n    return 0;\n}"
  },
  {
    "title": "C Structures",
    "note": "Structures group variables of different types under a single name. Useful for defining complex data objects such as records. Members are accessed using the dot (.) operator, and pointers to structures use -> operator.",
    "code": "#include <stdio.h>\n\nstruct Person {\n    char name[20];\n    int age;\n};\n\nint main() {\n    struct Person p1 = {\"Alice\", 25};\n    printf(\"Name: %s, Age: %d\\n\", p1.name, p1.age);\n    return 0;\n}"
  },
  {
    "title": "C File I/O",
    "note": "C allows file handling using FILE pointers and functions like fopen, fclose, fprintf, fscanf, fread, and fwrite. Modes include: r, w, a, rb, wb. Always check if the file is opened successfully to prevent runtime errors.",
    "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"w\");\n    if(file == NULL) {\n        printf(\"Error opening file.\\n\");\n        return 1;\n    }\n    fprintf(file, \"Hello File I/O in C\\n\");\n    fclose(file);\n\n    file = fopen(\"data.txt\", \"r\");\n    char str[50];\n    fscanf(file, \"%[^\"]\", str);\n    printf(\"Read from file: %s\\n\", str);\n    fclose(file);\n    return 0;\n}"
  },
  {
    "title": "C Dynamic Memory",
    "note": "Dynamic memory allocation in C uses malloc, calloc, realloc, and free. This allows flexible memory management for arrays and data structures. Always check for NULL pointers after allocation to avoid memory errors.",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int*)malloc(3 * sizeof(int));\n    if(arr == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        return 1;\n    }\n\n    for(int i = 0; i < 3; i++) arr[i] = (i + 1) * 10;\n    for(int i = 0; i < 3; i++) printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n\n    free(arr);\n    return 0;\n}"
  },
  {
    "title": "C Macros & Preprocessor",
    "note": "Preprocessor directives (#define, #include, #ifdef, #ifndef) are handled before compilation. Macros can define constants or inline functions. They improve code readability and allow conditional compilation for different platforms.",
    "code": "#include <stdio.h>\n#define PI 3.14159\n#define SQUARE(x) ((x)*(x))\n\nint main() {\n    double radius = 5.0;\n    printf(\"Value of PI: %.2f\\n\", PI);\n    printf(\"Square of 4: %d\\n\", SQUARE(4));\n    printf(\"Area of circle: %.2f\\n\", PI * SQUARE(radius));\n    return 0;\n}"
  },
  {
    "title": "C Common Use Cases",
    "note": "C is widely used for:\n1. Operating systems like Linux kernel and Windows.\n2. Embedded systems and microcontrollers.\n3. Game engines and graphics programming.\n4. Compilers, interpreters, and virtual machines.\n5. High-performance applications in finance and scientific computing.\n6. Networking, device drivers, and low-level hardware interaction."
  },
  {
    "title": "C Overview",
    "note": "C is a general-purpose, procedural programming language created by Dennis Ritchie in 1972 at Bell Labs. It is powerful for system programming, embedded systems, operating systems, and high-performance applications. C provides low-level access to memory, uses a simple set of keywords, and offers high efficiency. It serves as the foundation for many modern languages like C++, C#, and Java.",
    "code": "// Official Reference: https://en.cppreference.com/w/c\n// Try Online: https://www.onlinegdb.com/online_c_compiler\n#include <stdio.h>\n\nint main() {\n    printf(\"Hello, C!\\n\");\n    return 0;\n}"
  },
  {
    "title": "C Basics & Syntax",
    "note": "C is statically typed; variable types must be declared explicitly. Programs are composed of functions, with execution starting at 'main()'. Basic types include int, float, double, char, and void. Constants can be declared using 'const'. Use proper indentation and semicolons to terminate statements.",
    "code": "#include <stdio.h>\n\nint main() {\n    int age = 25;\n    float pi = 3.14;\n    char grade = 'A';\n\n    printf(\"Age: %d, Pi: %.2f, Grade: %c\\n\", age, pi, grade);\n    return 0;\n}"
  },
  {
    "title": "C Data Types & Memory",
    "note": "C provides primitive data types (int, float, double, char), derived types (arrays, pointers, structures, unions), and enumerations for symbolic constants. Use sizeof() to determine memory size of types. Understanding memory representation is key for system-level programming.",
    "code": "#include <stdio.h>\n\nint main() {\n    int num = 10;\n    float f = 3.14;\n    double d = 3.14159;\n    char c = 'A';\n    int arr[3] = {1, 2, 3};\n\n    printf(\"arr[0] = %d\\n\", arr[0]);\n    printf(\"Size of double: %lu bytes\\n\", sizeof(d));\n    return 0;\n}"
  },
  {
    "title": "C Operators",
    "note": "C supports arithmetic (+, -, *, /, %), relational (==, !=, >, <), logical (&&, ||, !), bitwise (&, |, ^, ~, <<, >>), assignment (=, +=, -=), and ternary (? :) operators. Operators are used to manipulate variables and expressions efficiently.",
    "code": "#include <stdio.h>\n\nint main() {\n    int a = 10, b = 3;\n    printf(\"a + b = %d\\n\", a + b);\n    printf(\"a %% b = %d\\n\", a % b);\n\n    int max = (a > b) ? a : b;\n    printf(\"Max: %d\\n\", max);\n    return 0;\n}"
  },
  {
    "title": "C Conditionals & Decision Making",
    "note": "C uses if, if-else, nested if, and switch-case for conditional execution. Curly braces {} define code blocks. Use break to exit switch-cases and continue to skip iterations in loops. Proper condition handling is crucial for program logic.",
    "code": "#include <stdio.h>\n\nint main() {\n    int age = 18;\n\n    if (age >= 18) {\n        printf(\"Adult\\n\");\n    } else if (age >= 13) {\n        printf(\"Teen\\n\");\n    } else {\n        printf(\"Child\\n\");\n    }\n\n    switch(age) {\n        case 13: printf(\"Teen 13\\n\"); break;\n        case 18: printf(\"Adult 18\\n\"); break;\n        default: printf(\"Other age\\n\");\n    }\n    return 0;\n}"
  },
  {
    "title": "C Loops & Iteration",
    "note": "C supports for, while, and do-while loops for repeated execution. Use break to exit a loop and continue to skip the current iteration. Loops are fundamental for tasks like iteration over arrays, counters, and repetitive computations.",
    "code": "#include <stdio.h>\n\nint main() {\n    int i;\n    for(i = 0; i < 3; i++) printf(\"For loop: %d\\n\", i);\n\n    i = 0;\n    while(i < 3) {\n        printf(\"While loop: %d\\n\", i);\n        i++;\n    }\n\n    i = 0;\n    do {\n        printf(\"Do-While loop: %d\\n\", i);\n        i++;\n    } while(i < 3);\n\n    return 0;\n}"
  },
  {
    "title": "C Functions & Recursion",
    "note": "Functions in C are reusable blocks of code performing specific tasks. Syntax: return_type function_name(parameters) { body }. Supports recursion for solving problems like factorial and Fibonacci. main() is a function like any other.",
    "code": "#include <stdio.h>\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint factorial(int n) {\n    if(n <= 1) return 1;\n    return n * factorial(n-1);\n}\n\nint main() {\n    int sum = add(5, 3);\n    int fact = factorial(5);\n    printf(\"Sum: %d, Factorial: %d\\n\", sum, fact);\n    return 0;\n}"
  },
  {
    "title": "C Arrays & Multidimensional Arrays",
    "note": "Arrays are fixed-size collections of elements of the same type. Indexing starts at 0. Multidimensional arrays allow tabular data representation. Arrays are widely used for lists, matrices, and buffers.",
    "code": "#include <stdio.h>\n\nint main() {\n    int numbers[3] = {10, 20, 30};\n    printf(\"First element: %d\\n\", numbers[0]);\n\n    int matrix[2][2] = {{1,2},{3,4}};\n    printf(\"matrix[1][1]: %d\\n\", matrix[1][1]);\n    return 0;\n}"
  },
  {
    "title": "C Pointers & Memory Addressing",
    "note": "Pointers store memory addresses of variables. Use * to dereference and & to get address. Essential for dynamic memory, arrays, function arguments, and system-level programming. Misuse can cause undefined behavior.",
    "code": "#include <stdio.h>\n\nint main() {\n    int x = 10;\n    int *p = &x;\n    printf(\"Value of x: %d\\n\", *p);\n    printf(\"Address of x: %p\\n\", (void*)p);\n    return 0;\n}"
  },
  {
    "title": "C Structures",
    "note": "Structures allow grouping variables of different types under a single name. Useful for defining complex data objects, such as records or objects. Members are accessed using dot (.) operator.",
    "code": "#include <stdio.h>\n\nstruct Person {\n    char name[20];\n    int age;\n};\n\nint main() {\n    struct Person p1 = {\"Alice\", 25};\n    printf(\"Name: %s, Age: %d\\n\", p1.name, p1.age);\n    return 0;\n}"
  },
  {
    "title": "C File I/O",
    "note": "C supports file reading/writing using FILE pointers and functions: fopen, fclose, fprintf, fscanf, fread, fwrite. Modes include: r, w, a, rb, wb. Proper error checking is essential for reliable file operations.",
    "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"w\");\n    if(file == NULL) return 1;\n    fprintf(file, \"Hello File\\n\");\n    fclose(file);\n\n    file = fopen(\"data.txt\", \"r\");\n    char str[50];\n    fscanf(file, \"%[^\"]\", str);\n    printf(\"Read from file: %s\\n\", str);\n    fclose(file);\n    return 0;\n}"
  },
  {
    "title": "C Dynamic Memory",
    "note": "Dynamic memory allocation is done using malloc, calloc, realloc, and freed using free. Enables flexible data structures like linked lists and resizable arrays. Always check for NULL pointers to avoid segmentation faults.",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr = (int*)malloc(3 * sizeof(int));\n    for(int i = 0; i < 3; i++) arr[i] = i+1;\n\n    for(int i = 0; i < 3; i++) printf(\"%d \", arr[i]);\n    free(arr);\n    return 0;\n}"
  },
  {
    "title": "C Macros & Preprocessor",
    "note": "Preprocessor directives (#define, #include, #ifdef, #ifndef) are handled before compilation. Macros can define constants or inline functions. They improve readability and can conditionally include code.",
    "code": "#include <stdio.h>\n#define PI 3.14\n\nint main() {\n    printf(\"Value of PI: %.2f\\n\", PI);\n    return 0;\n}"
  },
  {
    "title": "C Common Use Cases",
    "note": "C is widely used in:\n1. Operating systems (Linux kernel, Windows)\n2. Embedded systems\n3. Game development engines\n4. Compilers and interpreters\n5. High-performance scientific and financial applications\n6. Networking, drivers, and system utilities\nIts performance, low-level memory control, and portability make it ideal for critical system software."
  }
],
golang:
[
  {
    "title": "Go HOME & Overview",
    "note": "Go (Golang) is an open-source, statically typed, compiled programming language created by Google in 2009. It emphasizes simplicity, high performance, and maintainability. Go features fast compilation, garbage collection, strong typing, and native support for concurrency with goroutines and channels. It is widely used for backend services, cloud-native applications, DevOps tools, microservices, networking, and high-performance computing. Its clean, readable syntax makes it beginner-friendly yet powerful for building scalable applications.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, Go!\")\n    fmt.Println(\"Go is great for high-performance, concurrent programs.\")\n}"
  },
  {
    "title": "Go Basics & Syntax",
    "note": "Go programs start with a package declaration, typically 'package main'. The 'main()' function serves as the program's entry point. Variables can be declared using 'var' with explicit types or ':=' shorthand which infers types. Constants declared with 'const' are immutable. Go emphasizes simplicity, readability, and modularity. The language uses Go modules (go.mod) for dependency management. Best practices include using meaningful variable names, writing small reusable functions, organizing code in packages, and commenting effectively. Beginners should understand zero values and consistently use 'go fmt' to format code.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    var name string = \"Alice\"  // explicit type\n    age := 25                   // shorthand declaration\n    const isActive bool = true  // constant\n\n    fmt.Printf(\"Name: %s, Age: %d, Active: %t\\n\", name, age, isActive)\n\n    // Demonstrating zero values\n    var score int\n    var status bool\n    var message string\n    fmt.Printf(\"Zero values -> score: %d, status: %t, message: '%s'\\n\", score, status, message)\n}"
  },
  {
    "title": "Go Data Types",
    "note": "Go provides primitive types: integers (int, int8/16/32/64), unsigned integers (uint), floating-point numbers (float32, float64), complex numbers (complex64, complex128), booleans (bool), strings, and bytes. Composite types include arrays, slices, maps, structs, and pointers. All variables are initialized to their zero values if not explicitly assigned. Strings are immutable and UTF-8 encoded. Choosing appropriate data types improves performance, readability, and memory efficiency.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    var num int = 42\n    var pi float64 = 3.14\n    var letter byte = 'A'\n    var isTrue bool = true\n\n    arr := [3]int{1,2,3}\n    slice := []int{4,5,6}\n    myMap := map[string]int{\"Alice\":25, \"Bob\":30}\n\n    fmt.Println(\"Array element:\", arr[0], \"Slice element:\", slice[1], \"Map value:\", myMap[\"Alice\"])\n}"
  },
  {
    "title": "Go Operators",
    "note": "Go supports arithmetic operators (+, -, *, /, %), comparison operators (==, !=, >, <, >=, <=), logical operators (&&, ||, !), and bitwise operators (&, |, ^, <<, >>). Assignment operators include =, +=, -=, and *=. Go does not have a ternary operator; conditional logic uses if-else. Arithmetic with float64 requires explicit type conversion when using math functions. Understanding operators is essential for calculations, logic, and data manipulation.",
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    a, b := 10, 3\n    fmt.Println(\"a + b =\", a + b)\n    fmt.Println(\"a - b =\", a - b)\n    fmt.Println(\"a * b =\", a * b)\n    fmt.Println(\"a % b =\", a % b)\n    fmt.Println(\"a^b (bitwise XOR) =\", a ^ b)\n    fmt.Println(\"a^b float power =\", math.Pow(float64(a), float64(b)))\n}"
  },
  {
    "title": "Go Conditionals",
    "note": "Go uses if, if-else, and switch statements to control program flow. Parentheses are optional, but braces {} are mandatory. Switch statements do not fall through by default; the 'fallthrough' keyword can be used to continue to the next case. Conditionals help implement decision-making, input validation, and program logic branching. Inline if-statements can be used for concise assignments.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    age := 18\n\n    if age >= 18 {\n        fmt.Println(\"Adult\")\n    } else if age >= 13 {\n        fmt.Println(\"Teen\")\n    } else {\n        fmt.Println(\"Child\")\n    }\n\n    switch age {\n    case 13,14,15,16,17:\n        fmt.Println(\"Teen\")\n    case 18:\n        fmt.Println(\"Adult\")\n    default:\n        fmt.Println(\"Other\")\n    }\n}"
  },
  {
    "title": "Go Loops",
    "note": "Go has a single 'for' loop construct, which can act as a traditional for loop, a while-style loop, or an infinite loop. Use 'break' to exit a loop early, 'continue' to skip an iteration, and labels for controlling nested loops. Loops are essential for iterating over arrays, slices, maps, or performing repetitive tasks. Choosing the appropriate loop type improves readability and maintainability.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 0; i < 3; i++ {\n        fmt.Println(\"For loop:\", i)\n    }\n\n    j := 0\n    for j < 3 {\n        fmt.Println(\"While-style loop:\", j)\n        j++\n    }\n\n    for {\n        fmt.Println(\"Infinite loop, breaking immediately\")\n        break\n    }\n}"
  },
  {
    "title": "Go Functions",
    "note": "Functions in Go are declared using 'func' followed by the function name and parameters. Go supports multiple return values, named return variables, variadic parameters, and recursion. Functions can be passed as arguments, returned from other functions, or assigned to variables. Functions promote modular, reusable, and testable code.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc add(a, b int) int {\n    return a + b\n}\n\nfunc swap(x, y string) (string, string) {\n    return y, x\n}\n\nfunc main() {\n    sum := add(5, 3)\n    a, b := swap(\"Hello\", \"World\")\n    fmt.Println(\"Sum:\", sum)\n    fmt.Println(\"Swap:\", a, b)\n}"
  },
  {
    "title": "Go Arrays & Slices",
    "note": "Arrays in Go have fixed size and store elements of the same type. Slices are dynamic, reference underlying arrays, and can grow using append(). Slices include length and capacity, making them memory efficient. Slicing a slice returns a view of the underlying array without copying. Slices are preferred for most applications unless a fixed-size array is required.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    arr := [3]int{1,2,3}\n    slice := []int{4,5,6}\n    slice = append(slice, 7)\n\n    fmt.Println(\"Array:\", arr)\n    fmt.Println(\"Slice:\", slice)\n}"
  },
  {
    "title": "Go Maps",
    "note": "Maps are unordered collections of key-value pairs. Keys must be comparable types. Values can be any type. Maps are initialized using make() or map literals. Accessing a missing key returns the zero value of the value type. Use delete() to remove a key. Maps are useful for fast lookups, counting occurrences, and associating unique keys with values. Iterate using 'range' for processing all key-value pairs.",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    m := make(map[string]int)\n    m[\"Alice\"] = 25\n    m[\"Bob\"] = 30\n\n    fmt.Println(\"Alice's age:\", m[\"Alice\"])\n    delete(m, \"Bob\")\n    fmt.Println(\"Map after delete:\", m)\n\n    fmt.Println(\"Iterating over map:\")\n    for key, value := range m {\n        fmt.Println(key, \"->\", value)\n    }\n}"
  }
],
rlang:[
  {
    "title": "R HOME",
    "note": "R is a free, open-source programming language and environment for statistical computing, data analysis, and graphical representation. Developed by Ross Ihaka and Robert Gentleman in the 1990s, R is widely used in data science, machine learning, bioinformatics, and academia. It has extensive packages (CRAN) and strong visualization capabilities with ggplot2, lattice, and base plotting.",
    "code": "# Official Website: https://www.r-project.org/\n# Documentation: https://cran.r-project.org/manuals.html\n# Try Online: https://rdrr.io/ or https://replit.com/languages/r\n\n# Hello World in R\nprint(\"Hello, R!\")"
  },
  {
    "title": "R Basics",
    "note": "R is dynamically typed and interpreted. Variables can be assigned using <- or =. Common data types include numeric, integer, character, logical, factor, and complex. R uses vectors as the primary data structure and supports vectorized operations.",
    "code": "# Variable assignment\nname <- \"Alice\"\nage <- 25\nis_active <- TRUE\n\nprint(paste(\"Name:\", name, \"Age:\", age, \"Active:\", is_active))"
  },
  {
    "title": "R Data Types & Structures",
    "note": "R supports atomic vectors (numeric, integer, logical, character), lists (heterogeneous collections), matrices (2D homogeneous), arrays (multi-dimensional), data frames (tabular data), and factors (categorical variables). Understanding these structures is key for data manipulation.",
    "code": "# Vectors\nvec <- c(1, 2, 3, 4)\n\n# List\nmy_list <- list(name=\"Alice\", age=25, active=TRUE)\n\n# Matrix\nmat <- matrix(1:6, nrow=2, ncol=3)\n\n# Data frame\ndf <- data.frame(Name=c(\"Alice\", \"Bob\"), Age=c(25,30))\n\n# Factor\ncat <- factor(c(\"Male\", \"Female\", \"Female\"))\n\nprint(vec)\nprint(my_list)\nprint(mat)\nprint(df)\nprint(cat)"
  },
  {
    "title": "R Operators",
    "note": "R has arithmetic (+, -, *, /, ^, %% for modulus, %/% for integer division), relational (==, !=, >, <, >=, <=), logical (&&, ||, !), and assignment (<-, =, ->) operators. Vectorized operations apply element-wise on vectors and matrices.",
    "code": "a <- 10\nb <- 3\n\nprint(a + b)\nprint(a - b)\nprint(a * b)\nprint(a / b)\nprint(a %% b)   # Modulus\nprint(a %/% b)  # Integer division\nprint(a ^ b)    # Power"
  },
  {
    "title": "R Conditionals",
    "note": "R uses if, if-else, and ifelse for conditional statements. The switch statement allows selecting among multiple options. Logical conditions often operate on vectors, producing vectorized outputs.",
    "code": "age <- 18\n\nif(age >= 18){\n  print(\"Adult\")\n} else if(age >= 13){\n  print(\"Teen\")\n} else {\n  print(\"Child\")\n}\n\n# Vectorized ifelse\nx <- c(5, 10, 15)\nresult <- ifelse(x > 10, \"Big\", \"Small\")\nprint(result)\n\n# Switch\nvalue <- 2\nswitch(value, \"One\", \"Two\", \"Three\")"
  },
  {
    "title": "R Loops",
    "note": "R supports for, while, and repeat loops. Loops can iterate over vectors, sequences, and lists. Break and next are used to exit or skip iterations. However, vectorized operations are preferred for performance.",
    "code": "# For loop\nfor(i in 1:3){\n  print(paste(\"For loop\", i))\n}\n\n# While loop\nj <- 1\nwhile(j <= 3){\n  print(paste(\"While loop\", j))\n  j <- j + 1\n}\n\n# Repeat loop\nk <- 1\nrepeat {\n  print(paste(\"Repeat loop\", k))\n  k <- k + 1\n  if(k > 3) break\n}"
  },
  {
    "title": "R Functions",
    "note": "Functions in R are defined with the function() keyword. They can have default arguments, variable-length arguments (...), and can return single or multiple values. Functions are first-class objects and can be passed as arguments.",
    "code": "# Simple function\nadd <- function(a, b){\n  return(a + b)\n}\n\n# Function with default\ngreet <- function(name=\"Guest\"){\n  return(paste(\"Hello\", name))\n}\n\nprint(add(5,3))\nprint(greet(\"Alice\"))\nprint(greet())"
  },
  {
    "title": "R Apply Family",
    "note": "R provides apply, lapply, sapply, tapply, and mapply functions to perform operations on vectors, lists, and matrices. These functions replace many loops and are highly efficient.",
    "code": "vec <- 1:5\nprint(lapply(vec, function(x) x^2))\nprint(sapply(vec, function(x) x^2))\n\nmat <- matrix(1:6, 2, 3)\nprint(apply(mat, 1, sum)) # Row sums\nprint(apply(mat, 2, sum)) # Column sums"
  },
  {
    "title": "R Data Frames & Dplyr",
    "note": "Data frames are tabular data structures. The dplyr package provides a grammar for data manipulation: select, filter, mutate, arrange, summarise, and group_by. Pipes (%>%) make chaining operations intuitive.",
    "code": "library(dplyr)\n\ndf <- data.frame(Name=c(\"Alice\",\"Bob\",\"Charlie\"), Age=c(25,30,35))\n\n# Select and filter\ndf %>% select(Name) %>% filter(Age > 25)\n\n# Mutate\ndf <- df %>% mutate(IsAdult = Age >= 18)\nprint(df)\n\n# Arrange\ndf <- df %>% arrange(desc(Age))\nprint(df)"
  },
  {
    "title": "R Plotting & Visualization",
    "note": "R has powerful plotting capabilities using base R (plot, hist, boxplot), lattice, and ggplot2. Visualizations help explore and communicate data insights effectively.",
    "code": "library(ggplot2)\n\nx <- c(1,2,3,4,5)\ny <- c(5,4,3,2,1)\ndf <- data.frame(x,y)\n\n# Base plot\nplot(x,y,type='b', col='blue', main='Base Plot', xlab='X', ylab='Y')\n\n# ggplot2\nggplot(df, aes(x=x, y=y)) + geom_line(color='red') + geom_point() + ggtitle('GGPlot Line')"
  },
  {
    "title": "R Reading & Writing Files",
    "note": "R can read and write CSV, TXT, Excel, JSON, and other formats. Functions include read.csv, read.table, write.csv, and readxl package for Excel. Data I/O is essential for data analysis workflows.",
    "code": "# Write CSV\nwrite.csv(df, 'data.csv', row.names=FALSE)\n\n# Read CSV\nnew_df <- read.csv('data.csv')\nprint(new_df)\n\n# Read Excel (requires readxl)\nlibrary(readxl)\n# excel_data <- read_excel('data.xlsx')"
  },
  {
    "title": "R Statistics & Modeling",
    "note": "R is optimized for statistical analysis: mean, median, sd, cor, lm (linear regression), glm (generalized linear models), t.test, ANOVA, and more. It is widely used in research and data science pipelines.",
    "code": "# Basic statistics\nvec <- c(1,2,3,4,5)\nmean(vec)\nmedian(vec)\nsd(vec)\n\n# Linear regression\ndf <- data.frame(x=1:5, y=c(2,4,5,4,5))\nmodel <- lm(y ~ x, data=df)\nsummary(model)"
  },
  {
    "title": "R Advanced Topics",
    "note": "R supports advanced programming with S3/S4 classes, reference classes, parallel computing (parallel package), string manipulation (stringr), regular expressions, and integration with databases (DBI, RSQLite). It also supports interactive dashboards with Shiny.",
    "code": "# S3 class example\nperson <- list(name='Alice', age=25)\nclass(person) <- 'Person'\nprint(person)\n\n# Parallel computation\nlibrary(parallel)\nncores <- detectCores()\ncl <- makeCluster(ncores)\nstopCluster(cl)"
  },
  {
    "title": "R Packages & CRAN",
    "note": "R has a rich ecosystem of packages. Use install.packages() to install from CRAN and library() to load. Popular packages include tidyverse, data.table, ggplot2, shiny, lubridate, caret, and plotly.",
    "code": "# Install package\ninstall.packages('ggplot2')\n\n# Load package\nlibrary(ggplot2)\n\n# Use package\nggplot(df, aes(x=x, y=y)) + geom_point()"
  }
],
matlab:[
  {
    "title": "MATLAB HOME",
    "note": "MATLAB (Matrix Laboratory) is a high-level programming language and interactive environment developed by MathWorks for numerical computation, data analysis, visualization, and algorithm development. It is widely used in engineering, scientific research, machine learning, control systems, and simulations. MATLAB provides extensive built-in functions, toolboxes, and supports object-oriented programming.",
    "code": "% Official Website: https://www.mathworks.com/products/matlab.html\n% Documentation: https://www.mathworks.com/help/matlab/\n\n% Hello World\ndisp('Hello, MATLAB!')"
  },
  {
    "title": "MATLAB Basics",
    "note": "MATLAB is dynamically typed. Variables are assigned using = and can store numbers, strings, arrays, or matrices. MATLAB uses 1-based indexing and supports vectorized operations, which are faster than loops for matrix computations.",
    "code": "% Variable assignment\nname = 'Alice';\nage = 25;\nisActive = true;\n\nfprintf('Name: %s, Age: %d, Active: %d\\n', name, age, isActive);"
  },
  {
    "title": "MATLAB Data Types & Structures",
    "note": "MATLAB data types include numeric (double, single, int), logical, char, string, cell arrays (heterogeneous), structures, tables (tabular data), and categorical arrays. Matrices and arrays are fundamental, as MATLAB was designed for matrix operations.",
    "code": "% Numeric vector\nvec = [1, 2, 3, 4];\n\n% Cell array\nmyCell = {'Alice', 25, true};\n\n% Structure\nperson.name = 'Alice'; person.age = 25;\n\n% Matrix\nmat = [1 2 3; 4 5 6];\n\n% Table\ndf = table({'Alice';'Bob'}, [25;30], 'VariableNames', {'Name','Age'});\n\ndisp(vec)\ndisp(myCell)\ndisp(person)\ndisp(mat)\ndisp(df)"
  },
  {
    "title": "MATLAB Operators",
    "note": "MATLAB supports arithmetic (+, -, *, /, ^, .^ for element-wise power, mod), relational (==, ~=, >, <, >=, <=), logical (&, |, ~, xor), and assignment operators. Element-wise operations use a dot (.) for arrays.",
    "code": "a = 10; b = 3;\n\ndisp(a + b)\ndisp(a - b)\ndisp(a * b)\ndisp(a / b)\ndisp(mod(a,b))\ndisp(a^b)\ndisp(a.^b) % element-wise"
  },
  {
    "title": "MATLAB Conditionals",
    "note": "MATLAB uses if, elseif, else, and switch statements. Logical conditions are evaluated with relational and logical operators. Vectorized conditional operations are possible using logical indexing.",
    "code": "age = 18;\n\nif age >= 18\n    disp('Adult');\nelseif age >= 13\n    disp('Teen');\nelse\n    disp('Child');\nend\n\n% Switch\nvalue = 2;\nswitch value\n    case 1\n        disp('One');\n    case 2\n        disp('Two');\n    otherwise\n        disp('Other');\nend"
  },
  {
    "title": "MATLAB Loops",
    "note": "MATLAB supports for, while, and nested loops. Break and continue control flow. Loops can iterate over vectors, arrays, and matrices, but vectorized operations are preferred for performance.",
    "code": "% For loop\nfor i = 1:3\n    fprintf('For loop %d\\n', i);\nend\n\n% While loop\nj = 1;\nwhile j <= 3\n    fprintf('While loop %d\\n', j);\n    j = j + 1;\nend"
  },
  {
    "title": "MATLAB Functions",
    "note": "Functions in MATLAB are defined using the function keyword. Functions can return multiple values, accept default or variable-length arguments, and be saved in separate files. MATLAB supports anonymous functions for short operations.",
    "code": "% Function definition\nfunction sumVal = add(a,b)\n    sumVal = a + b;\nend\n\n% Call function\nresult = add(5,3);\ndisp(result)\n\n% Anonymous function\nsquare = @(x) x^2;\ndisp(square(5))"
  },
  {
    "title": "MATLAB Matrices & Linear Algebra",
    "note": "Matrices are fundamental in MATLAB. Common operations include transpose, inverse, determinant, eigenvalues, multiplication, and element-wise operations. MATLAB excels at linear algebra and numerical computations.",
    "code": "% Matrix operations\nA = [1 2; 3 4];\nB = [5 6; 7 8];\n\ndisp(A * B)   % Matrix multiplication\ndisp(A .* B)  % Element-wise multiplication\ndisp(A')      % Transpose\ndisp(inv(A))   % Inverse\ndisp(det(A))   % Determinant\ndisp(eig(A))   % Eigenvalues"
  },
  {
    "title": "MATLAB Plotting & Visualization",
    "note": "MATLAB provides built-in plotting functions: plot, scatter, bar, histogram, pie, surf, contour. Customization includes labels, titles, legends, colors, and styles. Visualization is essential for data analysis and simulations.",
    "code": "% Data\nx = 1:5; y = [2,4,6,8,10];\n\n% Line plot\nplot(x,y,'-o','Color','r');\ntitle('Line Plot'); xlabel('X'); ylabel('Y');\n\n% Scatter plot\nscatter(x,y,100,'filled')\n\n% 3D surface\n[X,Y] = meshgrid(1:0.5:3,1:20);\nZ = sin(X) + cos(Y);\nsurf(X,Y,Z)"
  },
  {
    "title": "MATLAB File I/O",
    "note": "MATLAB can read and write files: CSV, TXT, Excel, MAT. Functions include readtable, writetable, xlsread, xlswrite, load, and save. File I/O is essential for importing data and saving results.",
    "code": "% Write CSV\ntbl = table({'Alice';'Bob'}, [25;30], 'VariableNames', {'Name','Age'});\nwritetable(tbl, 'data.csv');\n\n% Read CSV\nnewTbl = readtable('data.csv');\ndisp(newTbl)\n\n% Save MAT file\ndata = rand(5);\nsave('mydata.mat','data');\n\n% Load MAT file\nload('mydata.mat');\ndisp(data)"
  },
  {
    "title": "MATLAB Statistics & Modeling",
    "note": "MATLAB includes functions for descriptive statistics (mean, median, std, var), probability distributions, regression (fitlm), ANOVA, t-tests, and machine learning (Statistics and Machine Learning Toolbox).",
    "code": "% Statistics\nvec = [1,2,3,4,5];\nmeanVal = mean(vec);\nmedianVal = median(vec);\nstdVal = std(vec);\ndisp([meanVal, medianVal, stdVal])\n\n% Linear regression\nX = (1:5)'; Y = [2,4,5,4,5]';\nmodel = fitlm(X,Y);\ndisp(model)"
  },
  {
    "title": "MATLAB Advanced Topics",
    "note": "Advanced MATLAB includes object-oriented programming (classes, properties, methods), GUI development (App Designer), parallel computing (parfor, spmd), integration with Python, C/C++, and Simulink for modeling and simulation.",
    "code": "% OOP class\nclassdef Person\n    properties\n        Name\n        Age\n    end\n    methods\n        function obj = Person(name, age)\n            obj.Name = name;\n            obj.Age = age;\n        end\n        function greet(obj)\n            fprintf('Hi, I am %s, age %d\\n', obj.Name, obj.Age);\n        end\n    end\nend\n\np = Person('Alice',25);\np.greet();\n\n% Parallel loop example\nparfor i = 1:4\n    disp(['Parallel iteration: ', num2str(i)])\nend"
  }
],
scala:
  [
  {
    "title": "Scala HOME & Overview",
    "note": "Scala is a modern, high-level programming language that integrates object-oriented and functional programming paradigms. Running on the JVM, it is fully compatible with Java libraries. Scala is used for web development, big data processing (e.g., Apache Spark), concurrent applications, and distributed systems. Its expressive syntax, type inference, and functional features make it concise and powerful for scalable, high-performance software.",
    "code": "// Official Website: https://www.scala-lang.org/\n// Documentation: https://docs.scala-lang.org/\n// Try Online: https://scastie.scala-lang.org/\n\nobject HelloScala {\n  def main(args: Array[String]): Unit = {\n    println(\"Hello, Scala!\")\n    println(\"Scala combines object-oriented and functional programming.\")\n  }\n}"
  },
  {
    "title": "Scala Basics & Syntax",
    "note": "Scala is statically typed but supports type inference, reducing boilerplate code. Variables can be immutable (val) or mutable (var). The program entry point is usually an object with a main method. Scala emphasizes concise, readable code with functional programming constructs such as expressions and immutability. Expressions return values, which allows chaining operations. Beginners should learn the difference between val and var, and prefer immutability for safer code.",
    "code": "object Basics {\n  def main(args: Array[String]): Unit = {\n    val name: String = \"Alice\"  // Immutable\n    var age: Int = 25            // Mutable\n    val isActive: Boolean = true\n\n    println(s\"Name: $name, Age: $age, Active: $isActive\")\n\n    // Demonstrating type inference\n    val score = 100\n    println(s\"Score: $score\")\n  }\n}"
  },
  {
    "title": "Scala Data Types & Collections",
    "note": "Scala has primitive types: Int, Double, Boolean, Char, and reference types: String, Array, List, Map, Option. Collections are immutable by default for safety and functional programming, but mutable versions exist. Arrays are fixed-size, Lists are linked lists, and Maps store key-value pairs. Option is used to represent optional values, reducing null errors. Proper use of types and collections ensures performance, readability, and robustness.",
    "code": "object DataTypes {\n  def main(args: Array[String]): Unit = {\n    val str: String = \"Hello\"\n    val num: Int = 42\n    val pi: Double = 3.14\n    val isTrue: Boolean = true\n    val arr: Array[Int] = Array(1, 2, 3)\n    val list: List[Int] = List(1, 2, 3)\n    val map: Map[String, Int] = Map(\"Alice\" -> 25, \"Bob\" -> 30)\n    val maybeValue: Option[Int] = Some(100)\n\n    println(arr(0))\n    println(str.toUpperCase)\n    println(list.head)\n    println(map(\"Alice\"))\n    println(maybeValue.getOrElse(0))\n  }\n}"
  },
  {
    "title": "Scala Conditionals & Pattern Matching",
    "note": "Scala supports if-else expressions, which return values. Pattern matching is a more powerful alternative to switch-case, enabling matching on types, values, and structures. Conditional expressions and pattern matching allow concise, readable decision-making. Ternary-like behavior can be achieved with inline if expressions. Pattern matching is especially useful for case classes and decomposing complex data.",
    "code": "object Conditionals {\n  def main(args: Array[String]): Unit = {\n    val age = 18\n\n    if (age >= 18) println(\"Adult\")\n    else if (age >= 13) println(\"Teen\")\n    else println(\"Child\")\n\n    // Inline if expression (ternary-like)\n    val result = if (age % 2 == 0) \"Even\" else \"Odd\"\n    println(result)\n\n    // Pattern matching\n    age match {\n      case x if x < 13 => println(\"Child\")\n      case x if x < 18 => println(\"Teen\")\n      case _ => println(\"Adult\")\n    }\n  }\n}"
  },
  {
    "title": "Scala Loops & For-Comprehensions",
    "note": "Scala supports while, do-while, for loops, and for-comprehensions. For-comprehensions provide a functional approach to iterating and transforming collections. They can include guards (filters) and yield new collections. Loops are used for repeated execution, iteration over arrays, lists, maps, and more complex transformations. Choosing functional constructs often leads to more concise and readable code than imperative loops.",
    "code": "object Loops {\n  def main(args: Array[String]): Unit = {\n    var i = 0\n    while (i < 3) {\n      println(i)\n      i += 1\n    }\n\n    for (j <- 0 until 3) println(s\"For loop $j\")\n\n    val arr = Array(1,2,3)\n    for (n <- arr) println(s\"Number: $n\")\n\n    // For-comprehension with filter\n    val evens = for (n <- arr if n % 2 == 0) yield n\n    println(evens.mkString(\", \"))\n  }\n}"
  },
  {
    "title": "Scala Functions & Lambdas",
    "note": "Functions are declared with def and can have default arguments, variable-length parameters, multiple return values via tuples, and recursion. Anonymous functions (lambdas) use the => syntax. Functions are first-class citizens: they can be passed as parameters, returned from other functions, or stored in variables. This enables functional programming patterns, modular code, and higher-order operations on collections.",
    "code": "object Functions {\n  def add(a: Int, b: Int): Int = a + b\n  def greet(name: String = \"Guest\"): String = s\"Hello, $name\"\n\n  def main(args: Array[String]): Unit = {\n    println(add(5,3))\n    println(greet(\"Alice\"))\n    println(greet())\n\n    // Anonymous function\n    val square = (x: Int) => x * x\n    println(square(5))\n  }\n}"
  },
  {
    "title": "Scala Collections - Advanced Operations",
    "note": "Scala collections support functional operations such as map, filter, reduce, fold, foreach, flatMap, and zip. Lazy collections (Streams) allow deferred computation for efficiency. Parallel collections enable parallel processing for high-performance computation. These features are essential for big data processing, transforming datasets, and writing concise functional code.",
    "code": "object CollectionsAdvanced {\n  def main(args: Array[String]): Unit = {\n    val nums = (1 to 10).toList\n\n    val squares = nums.map(x => x * x).filter(_ % 2 == 0)\n    println(squares)\n\n    // Lazy collection\n    val lazySeq = LazyList.from(1)\n    println(lazySeq.take(5).toList)\n\n    // Parallel collection\n    val parSum = nums.par.map(_ * 2).sum\n    println(parSum)\n  }\n}"
  },
  {
    "title": "Scala Classes, Objects & Case Classes",
    "note": "Scala supports object-oriented programming. Classes can have fields, methods, and constructors. Singleton objects are declared with object keyword. Case classes provide immutable data structures with auto-generated methods like equals, hashCode, toString, and support pattern matching. Proper use of classes and objects enables modular, reusable, and testable code.",
    "code": "class Person(val name: String, val age: Int) {\n  def greet(): Unit = println(s\"Hi, I'm $name, age $age\")\n}\n\nobject OOPDemo {\n  def main(args: Array[String]): Unit = {\n    val p1 = new Person(\"Alice\",25)\n    p1.greet()\n\n    // Case class\n    case class User(name: String, age: Int)\n    val user = User(\"Bob\",30)\n    println(user)\n  }\n}"
  },
  {
    "title": "Scala Traits & Mixins",
    "note": "Traits in Scala are similar to interfaces but can contain method implementations. Classes can mix in multiple traits to compose behavior. Traits enable code reuse, modular design, and polymorphism without deep inheritance hierarchies.",
    "code": "trait Greeter {\n  def greet(): Unit = println(\"Hello!\")\n}\n\nclass Person(name: String) extends Greeter {\n  override def greet(): Unit = println(s\"Hi, $name\")\n}\n\nobject TraitDemo {\n  def main(args: Array[String]): Unit = {\n    val p = new Person(\"Alice\")\n    p.greet()\n  }\n}"
  },
  {
    "title": "Scala Concurrency (Futures & Threads)",
    "note": "Scala supports concurrency using Futures, Promises, and Actors (via Akka). Futures represent asynchronous computations and can be composed using map, flatMap, or for-comprehensions. This enables non-blocking, parallel, and scalable applications. Futures require an implicit ExecutionContext for thread management.",
    "code": "import scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Success, Failure}\n\nobject ConcurrencyDemo {\n  def main(args: Array[String]): Unit = {\n    val f = Future {\n      Thread.sleep(1000)\n      42\n    }\n\n    f.onComplete {\n      case Success(value) => println(s\"Result: $value\")\n      case Failure(e) => println(s\"Error: ${e.getMessage}\")\n    }\n\n    Thread.sleep(2000) // Wait for future to complete\n  }\n}"
  }
],
};


















    

  
